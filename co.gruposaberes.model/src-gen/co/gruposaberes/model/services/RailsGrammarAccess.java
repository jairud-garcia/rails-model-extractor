/*
* generated by Xtext
*/
package co.gruposaberes.model.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class RailsGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCLASS_WORDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSpaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameNamespacedModuleNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSpaceKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Keyword cLessThanSignKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Keyword cSpaceKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cSuperTypeAssignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cSuperTypeNamespacedModuleNameParserRuleCall_3_3_0 = (RuleCall)cSuperTypeAssignment_3_3.eContents().get(0);
		private final Keyword cSpaceKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cClassElementsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cClassElementsClassElementParserRuleCall_5_0 = (RuleCall)cClassElementsAssignment_5.eContents().get(0);
		private final RuleCall cEND_WORDTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		
		//Class returns RubyClass:
		//	CLASS_WORD " "* name=NamespacedModuleName (" "* "<" " "* superType=NamespacedModuleName)? " "*
		//	classElements+=ClassElement* END_WORD;
		public ParserRule getRule() { return rule; }

		//CLASS_WORD " "* name=NamespacedModuleName (" "* "<" " "* superType=NamespacedModuleName)? " "*
		//classElements+=ClassElement* END_WORD
		public Group getGroup() { return cGroup; }

		//CLASS_WORD
		public RuleCall getCLASS_WORDTerminalRuleCall_0() { return cCLASS_WORDTerminalRuleCall_0; }

		//" "*
		public Keyword getSpaceKeyword_1() { return cSpaceKeyword_1; }

		//name=NamespacedModuleName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//NamespacedModuleName
		public RuleCall getNameNamespacedModuleNameParserRuleCall_2_0() { return cNameNamespacedModuleNameParserRuleCall_2_0; }

		//(" "* "<" " "* superType=NamespacedModuleName)?
		public Group getGroup_3() { return cGroup_3; }

		//" "*
		public Keyword getSpaceKeyword_3_0() { return cSpaceKeyword_3_0; }

		//"<"
		public Keyword getLessThanSignKeyword_3_1() { return cLessThanSignKeyword_3_1; }

		//" "*
		public Keyword getSpaceKeyword_3_2() { return cSpaceKeyword_3_2; }

		//superType=NamespacedModuleName
		public Assignment getSuperTypeAssignment_3_3() { return cSuperTypeAssignment_3_3; }

		//NamespacedModuleName
		public RuleCall getSuperTypeNamespacedModuleNameParserRuleCall_3_3_0() { return cSuperTypeNamespacedModuleNameParserRuleCall_3_3_0; }

		//" "*
		public Keyword getSpaceKeyword_4() { return cSpaceKeyword_4; }

		//classElements+=ClassElement*
		public Assignment getClassElementsAssignment_5() { return cClassElementsAssignment_5; }

		//ClassElement
		public RuleCall getClassElementsClassElementParserRuleCall_5_0() { return cClassElementsClassElementParserRuleCall_5_0; }

		//END_WORD
		public RuleCall getEND_WORDTerminalRuleCall_6() { return cEND_WORDTerminalRuleCall_6; }
	}

	public class NamespacedModuleNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamespacedModuleName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cColonColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//NamespacedModuleName:
		//	(ID "::")* ID;
		public ParserRule getRule() { return rule; }

		//(ID "::")* ID
		public Group getGroup() { return cGroup; }

		//(ID "::")*
		public Group getGroup_0() { return cGroup_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }

		//"::"
		public Keyword getColonColonKeyword_0_1() { return cColonColonKeyword_0_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}

	public class ClassElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMethodParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationshipParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ClassElement:
		//	Method | Relationship;
		public ParserRule getRule() { return rule; }

		//Method | Relationship
		public Alternatives getAlternatives() { return cAlternatives; }

		//Method
		public RuleCall getMethodParserRuleCall_0() { return cMethodParserRuleCall_0; }

		//Relationship
		public RuleCall getRelationshipParserRuleCall_1() { return cRelationshipParserRuleCall_1; }
	}

	public class RelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Relationship");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cHasManyParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHasAndBelongsToManyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBelongsToParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Relationship:
		//	HasMany | HasAndBelongsToMany | BelongsTo;
		public ParserRule getRule() { return rule; }

		//HasMany | HasAndBelongsToMany | BelongsTo
		public Alternatives getAlternatives() { return cAlternatives; }

		//HasMany
		public RuleCall getHasManyParserRuleCall_0() { return cHasManyParserRuleCall_0; }

		//HasAndBelongsToMany
		public RuleCall getHasAndBelongsToManyParserRuleCall_1() { return cHasAndBelongsToManyParserRuleCall_1; }

		//BelongsTo
		public RuleCall getBelongsToParserRuleCall_2() { return cBelongsToParserRuleCall_2; }
	}

	public class HasManyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HasMany");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHAS_MANY_WORDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//HasMany:
		//	HAS_MANY_WORD name=STRING;
		public ParserRule getRule() { return rule; }

		//HAS_MANY_WORD name=STRING
		public Group getGroup() { return cGroup; }

		//HAS_MANY_WORD
		public RuleCall getHAS_MANY_WORDTerminalRuleCall_0() { return cHAS_MANY_WORDTerminalRuleCall_0; }

		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
	}

	public class HasAndBelongsToManyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HasAndBelongsToMany");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHAS_AND_BELONGS_TO_MANY_WORDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//HasAndBelongsToMany:
		//	HAS_AND_BELONGS_TO_MANY_WORD name=STRING;
		public ParserRule getRule() { return rule; }

		//HAS_AND_BELONGS_TO_MANY_WORD name=STRING
		public Group getGroup() { return cGroup; }

		//HAS_AND_BELONGS_TO_MANY_WORD
		public RuleCall getHAS_AND_BELONGS_TO_MANY_WORDTerminalRuleCall_0() { return cHAS_AND_BELONGS_TO_MANY_WORDTerminalRuleCall_0; }

		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
	}

	public class ClassNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ClassName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSpaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cClass_nameKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cClass_nameKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cAlternatives_2.eContents().get(2);
		private final Keyword cClass_nameKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cSpaceKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2_2_2 = (Keyword)cGroup_2_2.eContents().get(2);
		private final Keyword cSpaceKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cClass_nameAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cClass_nameSTRINGTerminalRuleCall_4_0 = (RuleCall)cClass_nameAssignment_4.eContents().get(0);
		
		//ClassName returns EString:
		//	"," " "* ("class_name:" | ":class_name=>" | ":class_name" " "* "=>") " "* class_name=STRING;
		public ParserRule getRule() { return rule; }

		//"," " "* ("class_name:" | ":class_name=>" | ":class_name" " "* "=>") " "* class_name=STRING
		public Group getGroup() { return cGroup; }

		//","
		public Keyword getCommaKeyword_0() { return cCommaKeyword_0; }

		//" "*
		public Keyword getSpaceKeyword_1() { return cSpaceKeyword_1; }

		//"class_name:" | ":class_name=>" | ":class_name" " "* "=>"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"class_name:"
		public Keyword getClass_nameKeyword_2_0() { return cClass_nameKeyword_2_0; }

		//":class_name=>"
		public Keyword getClass_nameKeyword_2_1() { return cClass_nameKeyword_2_1; }

		//":class_name" " "* "=>"
		public Group getGroup_2_2() { return cGroup_2_2; }

		//":class_name"
		public Keyword getClass_nameKeyword_2_2_0() { return cClass_nameKeyword_2_2_0; }

		//" "*
		public Keyword getSpaceKeyword_2_2_1() { return cSpaceKeyword_2_2_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2_2_2() { return cEqualsSignGreaterThanSignKeyword_2_2_2; }

		//" "*
		public Keyword getSpaceKeyword_3() { return cSpaceKeyword_3; }

		//class_name=STRING
		public Assignment getClass_nameAssignment_4() { return cClass_nameAssignment_4; }

		//STRING
		public RuleCall getClass_nameSTRINGTerminalRuleCall_4_0() { return cClass_nameSTRINGTerminalRuleCall_4_0; }
	}

	public class DependentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Dependent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSpaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cDependentKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cDependentKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cAlternatives_2.eContents().get(2);
		private final Keyword cDependentKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Keyword cSpaceKeyword_2_2_1 = (Keyword)cGroup_2_2.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2_2_2 = (Keyword)cGroup_2_2.eContents().get(2);
		private final Keyword cSpaceKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDependentAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cDependentAlternatives_4_0 = (Alternatives)cDependentAssignment_4.eContents().get(0);
		private final RuleCall cDependentSYMBOLTerminalRuleCall_4_0_0 = (RuleCall)cDependentAlternatives_4_0.eContents().get(0);
		private final RuleCall cDependentSTRINGTerminalRuleCall_4_0_1 = (RuleCall)cDependentAlternatives_4_0.eContents().get(1);
		
		//Dependent returns EString:
		//	"," " "* ("dependent:" | ":dependent=>" | ":dependent" " "* "=>") " "* dependent=(SYMBOL | STRING);
		public ParserRule getRule() { return rule; }

		//"," " "* ("dependent:" | ":dependent=>" | ":dependent" " "* "=>") " "* dependent=(SYMBOL | STRING)
		public Group getGroup() { return cGroup; }

		//","
		public Keyword getCommaKeyword_0() { return cCommaKeyword_0; }

		//" "*
		public Keyword getSpaceKeyword_1() { return cSpaceKeyword_1; }

		//"dependent:" | ":dependent=>" | ":dependent" " "* "=>"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"dependent:"
		public Keyword getDependentKeyword_2_0() { return cDependentKeyword_2_0; }

		//":dependent=>"
		public Keyword getDependentKeyword_2_1() { return cDependentKeyword_2_1; }

		//":dependent" " "* "=>"
		public Group getGroup_2_2() { return cGroup_2_2; }

		//":dependent"
		public Keyword getDependentKeyword_2_2_0() { return cDependentKeyword_2_2_0; }

		//" "*
		public Keyword getSpaceKeyword_2_2_1() { return cSpaceKeyword_2_2_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2_2_2() { return cEqualsSignGreaterThanSignKeyword_2_2_2; }

		//" "*
		public Keyword getSpaceKeyword_3() { return cSpaceKeyword_3; }

		//dependent=(SYMBOL | STRING)
		public Assignment getDependentAssignment_4() { return cDependentAssignment_4; }

		//SYMBOL | STRING
		public Alternatives getDependentAlternatives_4_0() { return cDependentAlternatives_4_0; }

		//SYMBOL
		public RuleCall getDependentSYMBOLTerminalRuleCall_4_0_0() { return cDependentSYMBOLTerminalRuleCall_4_0_0; }

		//STRING
		public RuleCall getDependentSTRINGTerminalRuleCall_4_0_1() { return cDependentSTRINGTerminalRuleCall_4_0_1; }
	}

	public class HashKeyValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HashKeyValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cSpaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Assignment cKeyAssignment_2_0_0 = (Assignment)cGroup_2_0.eContents().get(0);
		private final RuleCall cKeyIDTerminalRuleCall_2_0_0_0 = (RuleCall)cKeyAssignment_2_0_0.eContents().get(0);
		private final Keyword cColonKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cKeyAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Alternatives cKeyAlternatives_2_1_0_0 = (Alternatives)cKeyAssignment_2_1_0.eContents().get(0);
		private final RuleCall cKeySYMBOLTerminalRuleCall_2_1_0_0_0 = (RuleCall)cKeyAlternatives_2_1_0_0.eContents().get(0);
		private final RuleCall cKeySTRINGTerminalRuleCall_2_1_0_0_1 = (RuleCall)cKeyAlternatives_2_1_0_0.eContents().get(1);
		private final Keyword cSpaceKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		private final Keyword cEqualsSignGreaterThanSignKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Keyword cSpaceKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cValueAlternatives_4_0 = (Alternatives)cValueAssignment_4.eContents().get(0);
		private final RuleCall cValueSYMBOLTerminalRuleCall_4_0_0 = (RuleCall)cValueAlternatives_4_0.eContents().get(0);
		private final RuleCall cValueSTRINGTerminalRuleCall_4_0_1 = (RuleCall)cValueAlternatives_4_0.eContents().get(1);
		
		//HashKeyValue:
		//	"," " "* (key=ID ":" | key=(SYMBOL | STRING) " "* "=>") " "* value=(SYMBOL | STRING);
		public ParserRule getRule() { return rule; }

		//"," " "* (key=ID ":" | key=(SYMBOL | STRING) " "* "=>") " "* value=(SYMBOL | STRING)
		public Group getGroup() { return cGroup; }

		//","
		public Keyword getCommaKeyword_0() { return cCommaKeyword_0; }

		//" "*
		public Keyword getSpaceKeyword_1() { return cSpaceKeyword_1; }

		//key=ID ":" | key=(SYMBOL | STRING) " "* "=>"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//key=ID ":"
		public Group getGroup_2_0() { return cGroup_2_0; }

		//key=ID
		public Assignment getKeyAssignment_2_0_0() { return cKeyAssignment_2_0_0; }

		//ID
		public RuleCall getKeyIDTerminalRuleCall_2_0_0_0() { return cKeyIDTerminalRuleCall_2_0_0_0; }

		//":"
		public Keyword getColonKeyword_2_0_1() { return cColonKeyword_2_0_1; }

		//key=(SYMBOL | STRING) " "* "=>"
		public Group getGroup_2_1() { return cGroup_2_1; }

		//key=(SYMBOL | STRING)
		public Assignment getKeyAssignment_2_1_0() { return cKeyAssignment_2_1_0; }

		//SYMBOL | STRING
		public Alternatives getKeyAlternatives_2_1_0_0() { return cKeyAlternatives_2_1_0_0; }

		//SYMBOL
		public RuleCall getKeySYMBOLTerminalRuleCall_2_1_0_0_0() { return cKeySYMBOLTerminalRuleCall_2_1_0_0_0; }

		//STRING
		public RuleCall getKeySTRINGTerminalRuleCall_2_1_0_0_1() { return cKeySTRINGTerminalRuleCall_2_1_0_0_1; }

		//" "*
		public Keyword getSpaceKeyword_2_1_1() { return cSpaceKeyword_2_1_1; }

		//"=>"
		public Keyword getEqualsSignGreaterThanSignKeyword_2_1_2() { return cEqualsSignGreaterThanSignKeyword_2_1_2; }

		//" "*
		public Keyword getSpaceKeyword_3() { return cSpaceKeyword_3; }

		//value=(SYMBOL | STRING)
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//SYMBOL | STRING
		public Alternatives getValueAlternatives_4_0() { return cValueAlternatives_4_0; }

		//SYMBOL
		public RuleCall getValueSYMBOLTerminalRuleCall_4_0_0() { return cValueSYMBOLTerminalRuleCall_4_0_0; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_4_0_1() { return cValueSTRINGTerminalRuleCall_4_0_1; }
	}

	public class BelongsToElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BelongsTo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBELONGS_TO_WORDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cSpaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cNameAlternatives_2_0 = (Alternatives)cNameAssignment_2.eContents().get(0);
		private final RuleCall cNameSYMBOLTerminalRuleCall_2_0_0 = (RuleCall)cNameAlternatives_2_0.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_2_0_1 = (RuleCall)cNameAlternatives_2_0.eContents().get(1);
		private final Keyword cSpaceKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOptionsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOptionsHashKeyValueParserRuleCall_4_0 = (RuleCall)cOptionsAssignment_4.eContents().get(0);
		
		////(','WS* ('class_name:'|':class_name'' '*'=>')' '*class_name=STRING   )? & 
		////(','WS* ('select:'|':select' '=>') STRING )? ('\r'? '\n')
		//BelongsTo:
		//	BELONGS_TO_WORD " "* name=(SYMBOL | STRING) " "* options+=HashKeyValue*;
		public ParserRule getRule() { return rule; }

		//BELONGS_TO_WORD " "* name=(SYMBOL | STRING) " "* options+=HashKeyValue*
		public Group getGroup() { return cGroup; }

		//BELONGS_TO_WORD
		public RuleCall getBELONGS_TO_WORDTerminalRuleCall_0() { return cBELONGS_TO_WORDTerminalRuleCall_0; }

		//" "*
		public Keyword getSpaceKeyword_1() { return cSpaceKeyword_1; }

		//name=(SYMBOL | STRING)
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//SYMBOL | STRING
		public Alternatives getNameAlternatives_2_0() { return cNameAlternatives_2_0; }

		//SYMBOL
		public RuleCall getNameSYMBOLTerminalRuleCall_2_0_0() { return cNameSYMBOLTerminalRuleCall_2_0_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_2_0_1() { return cNameSTRINGTerminalRuleCall_2_0_1; }

		//" "*
		public Keyword getSpaceKeyword_3() { return cSpaceKeyword_3; }

		//options+=HashKeyValue*
		public Assignment getOptionsAssignment_4() { return cOptionsAssignment_4; }

		//HashKeyValue
		public RuleCall getOptionsHashKeyValueParserRuleCall_4_0() { return cOptionsHashKeyValueParserRuleCall_4_0; }
	}

	public class MethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Method");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDEF_WORDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameMethodNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Method returns RubyMethod:
		//	DEF_WORD name=MethodName;
		public ParserRule getRule() { return rule; }

		//DEF_WORD name=MethodName
		public Group getGroup() { return cGroup; }

		//DEF_WORD
		public RuleCall getDEF_WORDTerminalRuleCall_0() { return cDEF_WORDTerminalRuleCall_0; }

		//name=MethodName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//MethodName
		public RuleCall getNameMethodNameParserRuleCall_1_0() { return cNameMethodNameParserRuleCall_1_0; }
	}

	public class MethodNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MethodName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cQuestionMarkKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//MethodName:
		//	ID ("?" | "=")?;
		public ParserRule getRule() { return rule; }

		//ID ("?" | "=")?
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("?" | "=")?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"?"
		public Keyword getQuestionMarkKeyword_1_0() { return cQuestionMarkKeyword_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
	}
	
	
	private final ClassElements pClass;
	private final NamespacedModuleNameElements pNamespacedModuleName;
	private final ClassElementElements pClassElement;
	private final RelationshipElements pRelationship;
	private final HasManyElements pHasMany;
	private final HasAndBelongsToManyElements pHasAndBelongsToMany;
	private final ClassNameElements pClassName;
	private final DependentElements pDependent;
	private final HashKeyValueElements pHashKeyValue;
	private final BelongsToElements pBelongsTo;
	private final MethodElements pMethod;
	private final MethodNameElements pMethodName;
	private final TerminalRule tBELONGS_TO_WORD;
	private final TerminalRule tHAS_MANY_WORD;
	private final TerminalRule tHAS_AND_BELONGS_TO_MANY_WORD;
	private final TerminalRule tCLASS_WORD;
	private final TerminalRule tMODULE_WORD;
	private final TerminalRule tDEF_WORD;
	private final TerminalRule tEND_WORD;
	private final TerminalRule tSYMBOL;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tINT;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public RailsGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pClass = new ClassElements();
		this.pNamespacedModuleName = new NamespacedModuleNameElements();
		this.pClassElement = new ClassElementElements();
		this.pRelationship = new RelationshipElements();
		this.pHasMany = new HasManyElements();
		this.pHasAndBelongsToMany = new HasAndBelongsToManyElements();
		this.pClassName = new ClassNameElements();
		this.pDependent = new DependentElements();
		this.pHashKeyValue = new HashKeyValueElements();
		this.pBelongsTo = new BelongsToElements();
		this.pMethod = new MethodElements();
		this.pMethodName = new MethodNameElements();
		this.tBELONGS_TO_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BELONGS_TO_WORD");
		this.tHAS_MANY_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HAS_MANY_WORD");
		this.tHAS_AND_BELONGS_TO_MANY_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HAS_AND_BELONGS_TO_MANY_WORD");
		this.tCLASS_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CLASS_WORD");
		this.tMODULE_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MODULE_WORD");
		this.tDEF_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DEF_WORD");
		this.tEND_WORD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "END_WORD");
		this.tSYMBOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SYMBOL");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("co.gruposaberes.model.Rails".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Class returns RubyClass:
	//	CLASS_WORD " "* name=NamespacedModuleName (" "* "<" " "* superType=NamespacedModuleName)? " "*
	//	classElements+=ClassElement* END_WORD;
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}

	//NamespacedModuleName:
	//	(ID "::")* ID;
	public NamespacedModuleNameElements getNamespacedModuleNameAccess() {
		return pNamespacedModuleName;
	}
	
	public ParserRule getNamespacedModuleNameRule() {
		return getNamespacedModuleNameAccess().getRule();
	}

	//ClassElement:
	//	Method | Relationship;
	public ClassElementElements getClassElementAccess() {
		return pClassElement;
	}
	
	public ParserRule getClassElementRule() {
		return getClassElementAccess().getRule();
	}

	//Relationship:
	//	HasMany | HasAndBelongsToMany | BelongsTo;
	public RelationshipElements getRelationshipAccess() {
		return pRelationship;
	}
	
	public ParserRule getRelationshipRule() {
		return getRelationshipAccess().getRule();
	}

	//HasMany:
	//	HAS_MANY_WORD name=STRING;
	public HasManyElements getHasManyAccess() {
		return pHasMany;
	}
	
	public ParserRule getHasManyRule() {
		return getHasManyAccess().getRule();
	}

	//HasAndBelongsToMany:
	//	HAS_AND_BELONGS_TO_MANY_WORD name=STRING;
	public HasAndBelongsToManyElements getHasAndBelongsToManyAccess() {
		return pHasAndBelongsToMany;
	}
	
	public ParserRule getHasAndBelongsToManyRule() {
		return getHasAndBelongsToManyAccess().getRule();
	}

	//ClassName returns EString:
	//	"," " "* ("class_name:" | ":class_name=>" | ":class_name" " "* "=>") " "* class_name=STRING;
	public ClassNameElements getClassNameAccess() {
		return pClassName;
	}
	
	public ParserRule getClassNameRule() {
		return getClassNameAccess().getRule();
	}

	//Dependent returns EString:
	//	"," " "* ("dependent:" | ":dependent=>" | ":dependent" " "* "=>") " "* dependent=(SYMBOL | STRING);
	public DependentElements getDependentAccess() {
		return pDependent;
	}
	
	public ParserRule getDependentRule() {
		return getDependentAccess().getRule();
	}

	//HashKeyValue:
	//	"," " "* (key=ID ":" | key=(SYMBOL | STRING) " "* "=>") " "* value=(SYMBOL | STRING);
	public HashKeyValueElements getHashKeyValueAccess() {
		return pHashKeyValue;
	}
	
	public ParserRule getHashKeyValueRule() {
		return getHashKeyValueAccess().getRule();
	}

	////(','WS* ('class_name:'|':class_name'' '*'=>')' '*class_name=STRING   )? & 
	////(','WS* ('select:'|':select' '=>') STRING )? ('\r'? '\n')
	//BelongsTo:
	//	BELONGS_TO_WORD " "* name=(SYMBOL | STRING) " "* options+=HashKeyValue*;
	public BelongsToElements getBelongsToAccess() {
		return pBelongsTo;
	}
	
	public ParserRule getBelongsToRule() {
		return getBelongsToAccess().getRule();
	}

	//Method returns RubyMethod:
	//	DEF_WORD name=MethodName;
	public MethodElements getMethodAccess() {
		return pMethod;
	}
	
	public ParserRule getMethodRule() {
		return getMethodAccess().getRule();
	}

	//MethodName:
	//	ID ("?" | "=")?;
	public MethodNameElements getMethodNameAccess() {
		return pMethodName;
	}
	
	public ParserRule getMethodNameRule() {
		return getMethodNameAccess().getRule();
	}

	//terminal BELONGS_TO_WORD:
	//	"belongs_to";
	public TerminalRule getBELONGS_TO_WORDRule() {
		return tBELONGS_TO_WORD;
	} 

	//terminal HAS_MANY_WORD:
	//	"has_many";
	public TerminalRule getHAS_MANY_WORDRule() {
		return tHAS_MANY_WORD;
	} 

	//terminal HAS_AND_BELONGS_TO_MANY_WORD:
	//	"has_and_belongs_to_many";
	public TerminalRule getHAS_AND_BELONGS_TO_MANY_WORDRule() {
		return tHAS_AND_BELONGS_TO_MANY_WORD;
	} 

	//terminal CLASS_WORD:
	//	"class";
	public TerminalRule getCLASS_WORDRule() {
		return tCLASS_WORD;
	} 

	//terminal MODULE_WORD:
	//	"module";
	public TerminalRule getMODULE_WORDRule() {
		return tMODULE_WORD;
	} 

	//terminal DEF_WORD:
	//	"def";
	public TerminalRule getDEF_WORDRule() {
		return tDEF_WORD;
	} 

	//terminal END_WORD:
	//	"end";
	public TerminalRule getEND_WORDRule() {
		return tEND_WORD;
	} 

	//terminal SYMBOL:
	//	":" ID;
	public TerminalRule getSYMBOLRule() {
		return tSYMBOL;
	} 

	//terminal ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal STRING:
	//	"\""->"\"" | "\'"->"\'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal ML_COMMENT:
	//	"=begin"->"=end";
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	} 

	//terminal SL_COMMENT:
	//	"#" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return tWS;
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return tINT;
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	} 
}
