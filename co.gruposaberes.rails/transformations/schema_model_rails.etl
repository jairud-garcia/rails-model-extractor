pre{
	var targetApp=rmodel!Application.all.first().transformApp();
}


operation rmodel!Application transformApp(): target!RailsApplication {
	var app=new target!RailsApplication;
	app.name = self.name;
	app.simpleRelationships=new Collection;
	app.basicElements=new Collection;
	var classes=rmodel!RubyClass.all.collect(r|r.getClass(app));
	var associations=rmodel!RubyClass.all.collect(r|r.getRelations(app));
	app.simpleRelationships.addAll(associations.flatten().select(e|e<>null));
	app.basicElements.addAll(target!RailsNamespace.all);
	return app;
}


operation rmodel!RubyClass getRelations(targetApp) : Collection{
	var originClass= target!RailsClass.all.selectOne(i|i.fullName == self.name);
	return self.classElements.select(e|e.isKindOf(rmodel!Relationship)).collect(d|d.getAssociation(originClass));
}

operation rmodel!Relationship getOrCreateAssociation(sourceClass,targetClass,foreignKey) : target!RailsAssociation{
	var association = target!RailsAssociation.all.selectOne(e|e.source==sourceClass and e.target==targetClass and e.foreignKey==foreignKey);
	if(association==null){
		association=new target!RailsAssociation();
		association.source=sourceClass;
		association.target=targetClass;
		association.foreignKey=foreignKey;
		("New associaction "+ sourceClass.name + " -> "+ targetClass.name + ' : ' +foreignKey).println();
	}
	return association;
}


operation rmodel!Relationship getAssociation(klass): target!RailsAssociation{
	var associationClass=self.getAssociationClass();
	if(associationClass==null){
		("Association Not found "+ klass.name+" "+self.name).println();
		return null;
	}
	var foreign_key=self.getForeignKey(klass);
	var relation = null;
	switch (self.relationType) {
		case 'belongs_to': 
			relation=self.getOrCreateAssociation(klass,associationClass,foreign_key);
		case 'has_many' :
			relation=self.getOrCreateAssociation(associationClass,klass,foreign_key);
			relation.associationType="O2M";
		case 'has_one' : 
			relation=self.getOrCreateAssociation(associationClass,klass,foreign_key);
			relation.associationType="O2O";
		case 'has_and_belongs_to_many' :
			relation= target!RailsAssociation.all.selectOne(e|e.associationType=="M2M" and (
				(e.source==klass and e.target==associationClass) or
				(e.source==associationClass and e.target==klass) 
			));
			if(relation==null){
				relation=new target!RailsAssociation;
				relation.source=klass;
				relation.target=associationClass;
				relation.associationType="M2M";
			}		
	}
	return relation;
}

operation rmodel!Relationship getForeignKey(klass): String{
	if(self.options<>null){
		var class_options=self.options.select(a| a.key==':foreign_key' or a.key='foreign_key' );
		if(class_options.size()>0){
			return class_options.last.value;
		}
	}
	switch (self.relationType) {
		case 'belongs_to': 
			return singularize(self.name)+'_id';
		case 'has_many' :
			return klass.name.toLowerCase().replace(':','')+'_id';
		case 'has_one' : 
			return klass.name.toLowerCase().replace(':','')+'_id';
		default :
			return null;
	}
}

operation singularize(text): String{
	if(text.endsWith('s')){
		text=text.substring(0,text.length()-1);
	}
	return text.toLowerCase().replace('_','').replace(':','');
}

operation rmodel!Relationship getAssociationClass(): target!RailsClass{
	var currentClass=self.getAssociationClassFromOptions();
	if(currentClass==null){
		var className=singularize(self.name);
		var StringTool : new Native("co.gruposaberes.rails.eclipse.StringTool");

		var currentScore=10;
		for(klass in target!RailsClass.all){
			var distance = StringTool.distance(className,klass.name);
			if(distance<currentScore){
				currentScore=distance;
				currentClass=klass;
			}
		}
	}
	if(currentClass==null){
		("AssociationClass Not found "+ self.name).println();
	}
	return currentClass;
}

operation rmodel!Relationship getAssociationClassFromOptions(): target!RailsClass{
	var currentClass=null;
	if(self.options<>null){
		var class_options=self.options.select(a| a.key==':class_name' or a.key='class_name' );
		if(class_options.size()>0){
			currentClass=target!RailsClass.all.selectOne(i|i.name = class_options.last.value);
		}
	}
	return currentClass;
}

operation rmodel!RubyClass getClass(targetApp) : target!RailsClass{
	var namespace=self.getNamespace(targetApp);
	var klass=new target!RailsClass;
	klass.name=self.name.split('::').last;
	klass.fullName=self.name;
	klass.superClass=self.superType;
	klass.description = klass.name+" < "+self.superType;
	klass.innerElements=new Collection;
	targetApp.basicElements.add(klass);
	if(namespace <> null){
		namespace.innerElements.add(klass);
	}
	klass.innerElements.addAll(self.getMethods(targetApp));
	if(klass.superClass=='ActiveRecord::Base'){
		var attributes =self.getAttributes(klass);
		if(attributes.size()>0){

			klass.innerElements.addAll(attributes);
		}
	}
	return klass;
}

operation rmodel!RubyClass getAttributes(klass): Collection{
	var table = self.getTable(klass);
	if(table<>null){
		return table.attributes.collect(e|e.getAttribute());
	}
	return new Collection;
}

operation rschema!TableAttributes getAttribute(): target!RailsAttribute{
	var attribute=new target!RailsAttribute();
	attribute.name = self.name;
	attribute.dataType = self.datatype;
	return attribute;
}

operation rmodel!RubyClass getTable(klass): rschema!Table{
	var currentTable=self.getConfigTable();
	if(currentTable==null){
		var StringTool : new Native("co.gruposaberes.rails.eclipse.StringTool");
		var currentScore=10;
		for(table in rschema!Table.all){
			var distance = StringTool.distance(StringTool.pluralize(klass.name.toLowerCase()),table.name.replace('_',''));
			if(distance<currentScore){
				currentScore=distance;
				currentTable=table;
			}
		}
	}
	if(currentTable<> null){
		("Found table "+currentTable.name+' for class '+klass.name).println();
	}
	return currentTable;
}

operation rmodel!RubyClass getConfigTable(): rschema!Table{
	var table_name=self.classElements.selectOne(e|e.isKindOf(rmodel!TableName));
	if(table_name<> null ){
		return rschema!Table.all.selectOne(e|e.name=='table_name');
	}
}
operation rmodel!RubyClass getMethods(targetApp): Collection{
	var methods = self.classElements.select(e|e.isKindOf(rmodel!RubyMethod) and e.name <> null and e.name <> "").collect(d|d.getMethod());
	targetApp.basicElements.addAll(methods);
	return methods;
}

operation rmodel!RubyMethod getMethod(): target!RailsMethod{
	var method=new target!RailsMethod;
	if(self.name.startsWith('self.')){
		method.methodType='class';
		method.name=self.name.substring(5);
	}else{
		method.methodType='instance';
		method.name=self.name;
	}
	return method ;
}

operation rmodel!RubyClass getNamespace(targetApp) : target!RailsNamespace{
	var tokens=self.name.split('::');
	var currentNamespace=null;
	var currentNamespaceName="";
	if(tokens.size()>1){
		for (i in Sequence{0..tokens.size()-2}) {
			currentNamespaceName=currentNamespaceName+'::'+tokens.at(i);
			var namespace=target!RailsNamespace.all.selectOne(i|i.description==currentNamespaceName);
			if(namespace==null){
				('Found namespace '+currentNamespaceName).println();
				namespace= new target!RailsNamespace();
				namespace.name =tokens.at(i);
				namespace.description=currentNamespaceName;
				namespace.innerElements=new Collection;
			}
			currentNamespace=namespace;
		}
	}
	return currentNamespace; 	
}

post{
	"Finished".println();
}