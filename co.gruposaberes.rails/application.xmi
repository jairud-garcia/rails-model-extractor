<?xml version="1.0" encoding="ASCII"?>
<rails:Application xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rails="http://www.gruposaberes.co/model/Rails" name="freemium">
  <rubyClasses name="Actividad" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":indicador" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":asignacion" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":tarea" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":evento" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="before_destroy :set_score_siblings, :unlink_score"/>
    <classElements xsi:type="rails:RubyMethod" name="set_score_siblings"/>
    <classElements xsi:type="rails:OperationsChain" name="self.calificacion.sibling_ids end validates_presence_of :texto"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :fecha_inicio"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :fecha_fin"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :indicador_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_fecha"/>
    <classElements xsi:type="rails:RubyMethod" name="unlink_score"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.calificacion self.calificacion.destroy_or_unlink_from_tree end end"/>
    <classElements xsi:type="rails:RubyMethod" name="clonar"/>
    <classElements xsi:type="rails:OperationsChain" name="clonada">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>!=</operators>
      <operators>=</operators>
      <operators>-</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operants>self.clone clonada.indicador</operants>
      <operants>indicador clonada.tarea</operants>
      <operants>nil clonada.asignacion</operants>
      <operants>nil clonada.save! if self.indicador.logro.periodo</operants>
      <operants>indicador.logro.periodo diff</operants>
      <operants>self.fecha_fin</operants>
      <operants>self.fecha_inicio clonada.fecha_inicio</operants>
      <operants>indicador.logro.periodo.fecha_inicio clonada.fecha_fin</operants>
      <operants>indicador.logro.periodo.fecha_inicio</operants>
      <operants>diff clonada.save! end if clonada.calificacion and self.calificacion clonada.calificacion.peso</operants>
      <operants>self.calificacion.peso clonada.calificacion.save! end clonada end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.fecha_fin">
      <operators>>=</operators>
      <operants>self.fecha_inicio self.errors.add(:fecha_fin,I18n.t(:fecha_inicio_fin)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.indicador.logro.programa.materia self.calificacion">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operants>Calificacion.create(:texto => self.texto,:peso => 0.00, 
        :materia=>self.indicador.logro.programa.materia, 
        :calificacion=>self.indicador.calificacion) self.send(:update_without_callbacks) if self.asignacion escala_numerica</operants>
      <operants>self.asignacion.materia.curso.periodo.escala_numerica for resultado in self.asignacion.resultados valor</operants>
      <operants>Valor.actualizar_valor(resultado.persona_id, self.calificacion.id, escala_numerica, resultado.calificacion) resultado.valor</operants>
      <operants>valor resultado.save self.calificacion.valores</operants>
      <operants>valor end end self.send(:update_without_callbacks) self.calificacion.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy self.evento.destroy if self.evento end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario if self.evento self.evento.update_attributes(:name => &quot;Actividad: #{self.texto}&quot;,
        :descripcion => self.texto,
        :start_at => self.fecha_inicio,
        :end_at => self.fecha_fin,
        :materia_id => self.indicador.logro.programa.materia_id,
        :all_day => false) end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Acudiente" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:Relationship" name=":estudiantes_as_padre" relationType="has_many">
      <options key=":foreign_key" value="padre_id"/>
      <options key=":class_name" value="Estudiante"/>
      <options key=":conditions" value="{:activo=>true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":estudiantes_as_madre" relationType="has_many">
      <options key=":foreign_key" value="madre_id"/>
      <options key=":class_name" value="Estudiante"/>
      <options key=":conditions" value="{:activo=>true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":estudiantes" relationType="has_many">
      <options key=":conditions" value="{:activo=>true}"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :colegio_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :persona_id, :if=>:persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :work_address, :with => named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :has_lock, lambda { |param| {&#xA;      :select=> &quot;DISTINCT acudientes.*&quot;,&#xA;      :conditions => [&quot;blocks.type_block = ?&quot;, param] ,&#xA;      :joins=> &quot;LEFT OUTER JOIN `personas` ON `personas`.id = `acudientes`.persona_id \&#xA;        LEFT OUTER JOIN `persona_blocks` ON (`personas`.`id` = `persona_blocks`.`persona_id`) \&#xA;        LEFT OUTER JOIN `blocks` ON (`blocks`.`id` = `persona_blocks`.`block_id`)&quot;&#xA;    } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :has_student_lock, lambda { |param| {&#xA;      :select=> &quot;DISTINCT acudientes.*&quot;,&#xA;      :conditions => [&quot;acudiente_blocks.type_block = ?&quot;, param] ,&#xA;      :joins=> &quot;LEFT OUTER JOIN `estudiantes` ON estudiantes.acudiente_id = acudientes.id \&#xA;          LEFT OUTER JOIN `personas` acudiente_personas ON `acudiente_personas`.id = `estudiantes`.persona_id \&#xA;          LEFT OUTER JOIN `persona_blocks` acudiente_persona_blocks ON (`acudiente_personas`.`id` = `acudiente_persona_blocks`.`persona_id`) \&#xA;          LEFT OUTER JOIN `blocks` acudiente_blocks ON (`acudiente_blocks`.`id` = `acudiente_persona_blocks`.`block_id`)&quot;&#xA;    } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :has_father_student_lock, lambda { |param| {&#xA;      :select=> &quot;DISTINCT acudientes.*&quot;,&#xA;      :conditions => [&quot;father_blocks.type_block = ?&quot;, param] ,&#xA;      :joins=> &quot;&#xA;          LEFT OUTER JOIN `estudiantes` father_estudiantes ON father_estudiantes.padre_id = acudientes.id \&#xA;          LEFT OUTER JOIN `personas` father_personas ON `father_personas`.id = `father_estudiantes`.persona_id \&#xA;          LEFT OUTER JOIN `persona_blocks` father_persona_blocks ON (`father_personas`.`id` = `father_persona_blocks`.`persona_id`) \&#xA;          LEFT OUTER JOIN `blocks` father_blocks ON (`father_blocks`.`id` = `father_persona_blocks`.`block_id`)&quot;&#xA;    } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :has_mother_student_lock, lambda { |param| {&#xA;      :select=> &quot;DISTINCT acudientes.*&quot;,&#xA;      :conditions => [&quot;mother_blocks.type_block = ?&quot;, param] ,&#xA;      :joins=> &quot;&#xA;          LEFT OUTER JOIN `estudiantes` mother_estudiantes ON mother_estudiantes.madre_id = acudientes.id \&#xA;          LEFT OUTER JOIN `personas` mother_personas ON `mother_personas`.id = `mother_estudiantes`.persona_id \&#xA;          LEFT OUTER JOIN `persona_blocks` mother_persona_blocks ON (`mother_personas`.`id` = `mother_persona_blocks`.`persona_id`) \&#xA;          LEFT OUTER JOIN `blocks` mother_blocks ON (`mother_blocks`.`id` = `mother_persona_blocks`.`block_id`)&quot;&#xA;    } }"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :set_profiles"/>
    <classElements xsi:type="rails:RubyMethod" name="set_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.define_profiles check_person end"/>
    <classElements xsi:type="rails:RubyMethod" name="check_person"/>
    <classElements xsi:type="rails:OperationsChain" name="raise 'Acudiente no tiene persona'"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.persona_id end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.nivel_educativo"/>
    <classElements xsi:type="rails:OperationsChain" name="[ ['Primaria'],&#xA;      ['Bachillerato'],&#xA;      ['T&#xe9;cnico'],&#xA;      ['Tecnol&#xf3;gico'],&#xA;      ['Profesional'],&#xA;      ['Otro']&#xA;    ] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.parentesco"/>
    <classElements xsi:type="rails:OperationsChain" name="[ ['Abuelo/a'],&#xA;      ['Madre'],&#xA;      ['Padre'],&#xA;      ['T&#xed;o/a'],&#xA;      ['Hermano/a'],&#xA;      ['Primo/a'],&#xA;      ['Otro']&#xA;    ] end"/>
    <classElements xsi:type="rails:RubyMethod" name="nombre_completo"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.persona self.persona.apellido">
      <operators>+</operators>
      <operators>+</operators>
      <operants>&quot; &quot;</operants>
      <operants>self.persona.nombre end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="active"/>
    <classElements xsi:type="rails:OperationsChain" name="self.activo end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="result">
      <operators>=</operators>
      <operators>||</operators>
      <operators>||</operators>
      <operants>false if self.persona.administrador</operants>
      <operants>self.persona.estudiante</operants>
      <operants>self.persona.docente self.errors.add(:base, 'Los datos personales se encuentran enlazados a otros perfiles') else Acudiente.transaction logger.warn &quot;Deleting Acudiente: #{self.id} ... &quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if self.persona.usuario self.persona.usuario.destroy logger.warn &quot;Deleting #{self.persona.usuario.inspect}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end self.persona.destroy logger.warn &quot;Deleting #{self.persona.inspect}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="result">
      <operators>=</operators>
      <operants>super()</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end logger.warn &quot;Deleted #{self.inspect}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="result end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_active_students"/>
    <classElements xsi:type="rails:OperationsChain" name="estudiantes">
      <operators>=</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operants>self.estudiantes.map {|e| e if e.estado == &quot;active&quot;}</operants>
      <operants>self.estudiantes_as_madre.map {|e| e if e.estado == &quot;active&quot;}</operants>
      <operants>self.estudiantes_as_padre.map {|e| e if e.estado == &quot;active&quot;}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="estudiantes.uniq.compact end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_all_students"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.estudiantes or self.estudiantes_as_madre or self.estudiantes_as_padre all_students">
      <operators>=</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operants>self.estudiantes</operants>
      <operants>self.estudiantes_as_madre</operants>
      <operants>self.estudiantes_as_padre end all_students end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="students"/>
    <classElements xsi:type="rails:OperationsChain" name="Estudiante.padre_id_or_madre_id_or_acudiente_id_equals(self.id) end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_blocks_to_guardians"/>
    <classElements xsi:type="rails:OperationsChain" name="students">
      <operators>=</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operants>self.get_all_students students_and_guardian</operants>
      <operants>students.map(&amp;:persona)</operants>
      <operants>self.persona.to_a block</operants>
      <operants>students_and_guardian.to_a.detect{|per| per.persona_blocks.any?}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if block.anny? bloqueo">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Block.new bloqueo.persona_id</operants>
      <operants>self.acudiente.persona_id bloqueo.block_id</operants>
      <operants>Block.all.first.id bloqueo.save else end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Administrador" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":cargo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":director_profiles" relationType="has_many">
      <options key=":foreign_key" value="director_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":headquarters" relationType="has_many">
      <options key=":foreign_key" value="administrator_id"/>
      <options key=":class_name" value="Headquarter"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:OperationsChain" name="NIVEL_ESTUDIO">
      <operators>=</operators>
      <operators>=</operators>
      <operants>[&quot;Primaria&quot;, &quot;Bachillerato&quot;, &quot;T&#xe9;cnico&quot;, &quot;Tecn&#xf3;logo&quot;, &quot;Profesional&quot;, &quot;Especialista&quot;, &quot;Maestro&quot;,&quot;PhD.&quot;] PROFILES</operants>
      <operants>{:transport => 7, :comunications => 8, :reporting => 10, :administration => 11,&#xD;
    :nursering => 9, :manager_area=>12, :billfold=>13, :human_resources=>14, :accountant => 16,&#xD;
    :billing_statement_agent => 17, :psychology => 18, :physical_resources => 19, :auditory => 20, :quality => 21, :manage_exalumn => 22,&#xD;
    :contents => 23, :manage_permissions => 24, :footprints => 25&#xD;
  }</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":user" relationType="has_one">
      <options key=":through" value=":persona"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :nit, :current_tab"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :colegio_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :persona_id, :if => :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :persona_id, :if => :id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_retirement_date_institution"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :observaciones, :maximum => 250, :if => :observaciones"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :set_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xD;&#xA;      :conditions => {:colegio_id => self.get_school()}, :order => 'id'} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :persona_by_full_name, lambda { |param|&#xD;&#xA;    param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xD;&#xA;    if param.count == 1&#xD;&#xA;      param =  param*3&#xD;&#xA;      sql = '(personas.full_name Like ?) OR (personas.identificacion Like ? ) OR (personas.e_mail like ? )'&#xD;&#xA;    else&#xD;&#xA;      sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xD;&#xA;    end&#xD;&#xA;    param.insert(0,sql)&#xD;&#xA;    {&#xD;&#xA;      :conditions => param ,&#xD;&#xA;      :joins=> {}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_cargo"/>
    <classElements xsi:type="rails:RubyMethod" name="set_cargo"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.cargo_id.blank? self.cargo_id">
      <operators>=</operators>
      <operants>4 end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.define_profiles end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="nombre_completo"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.persona &quot;#{self.persona.apellido} #{self.persona.nombre}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="validar_retirement_date_institution"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.retirement_date_institution and self.date_of_ingress unless self.retirement_date_institution">
      <operators>>=</operators>
      <operants>self.date_of_ingress self.errors.add(:retirement_date_institution,I18n.t(:must_be_greathen_or_equals_than_date_of_ingress)) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="active"/>
    <classElements xsi:type="rails:OperationsChain" name="self.activo end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_rh_person"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="new_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="@new_profiles">
      <operators>||=</operators>
      <operants>self.director_profiles.map(&amp;:profile) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="new_profiles="/>
    <classElements xsi:type="rails:OperationsChain" name="@new_profiles">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.to_s end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_admin_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="if @new_profiles and @new_profiles.is_a?(Array) Administrador.transaction() do self.director_profiles.each do |current_profile|"/>
    <classElements xsi:type="rails:OperationsChain" name="unless @new_profiles.include?(current_profile.profile) current_profile.destroy end end (@new_profiles-self.director_profiles.map(&amp;:profile))"/>
  </rubyClasses>
  <rubyClasses name="AllocationMaterias" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Appointment" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
      <options key=":foreign_key" value="person_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":place" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :person_id, :if => Proc.new(){|obj| obj.name.blank?}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :region"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :injury"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school, :set_name_person"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :select_responsible_people"/>
    <classElements xsi:type="rails:OperationsChain" name="serialize :dispatched_to"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.school_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end RESPONSIBLES</operants>
      <operants>[:nobody, :guardian, :father, :mother, :all_guardians,:group_director ] DISPACHED</operants>
      <operants>[:medical_consultation, :medical_institution, :ambulance]</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_data_hurts"/>
    <classElements xsi:type="rails:OperationsChain" name="t(&quot;region.#{self.region.to_s}.hurts.#{self.injury.to_s}&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_data_regions"/>
    <classElements xsi:type="rails:OperationsChain" name="t(&quot;region.#{self.region.to_s}&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_regions"/>
    <classElements xsi:type="rails:OperationsChain" name="t('region.'+self.region+'.t')"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_injuries"/>
    <classElements xsi:type="rails:OperationsChain" name="t('region.'+self.region+'.hurts.'+self.injury)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.persona.estudiante if self.persona.estudiante.current_course_student self.persona.estudiante.current_course_student.curso.materias.each do|materia|"/>
    <classElements xsi:type="rails:OperationsChain" name="materia.horarios.each do|horario|"/>
    <classElements xsi:type="rails:OperationsChain" name="materia.to_s dia">
      <operators>=</operators>
      <operators>%</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>>=</operators>
      <operators>&lt;=</operators>
      <operators>=</operators>
      <operants>(horario.dia + 1)</operants>
      <operants>7 day</operants>
      <operants>(self.date_and_hour_consult).wday hour</operants>
      <operants>self.date_and_hour_consult.strftime(&quot;%H:%M&quot;) if dia</operants>
      <operants>day if hour</operants>
      <operants>horario.hora_inicio.strftime(&quot;%H:%M&quot;) and hour</operants>
      <operants>horario.hora_fin.strftime(&quot;%H:%M&quot;) if self.control_subject.blank? self.control_subject</operants>
      <operants>materia.to_s end end end end end self.send(:update_without_callbacks) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.persona.estudiante if self.persona.estudiante.current_course_student self.persona.estudiante.current_course_student.curso.materias.each do|materia|"/>
    <classElements xsi:type="rails:OperationsChain" name="materia.horarios.each do|horario|"/>
    <classElements xsi:type="rails:OperationsChain" name="materia.to_s dia">
      <operators>=</operators>
      <operators>%</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>>=</operators>
      <operators>&lt;=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>(horario.dia + 1)</operants>
      <operants>7 day</operants>
      <operants>(self.date_and_hour_consult).wday hour</operants>
      <operants>self.date_and_hour_consult.strftime(&quot;%H:%M&quot;) if dia</operants>
      <operants>day if hour</operants>
      <operants>horario.hora_inicio.strftime(&quot;%H:%M&quot;) and hour</operants>
      <operants>horario.hora_fin.strftime(&quot;%H:%M&quot;) if self.control_subject.blank? self.control_subject</operants>
      <operants>materia.to_s end end end end end self.send(:update_without_callbacks) end end contact_mails</operants>
      <operants>[] school</operants>
      <operants>Colegio.find(self.school_id) if self.persona.estudiante unless self.select_responsible_people.blank? self.select_responsible_people self.select_responsible_people.each do |object|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if object">
      <operators>==</operators>
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>&quot;Padre&quot; unless self.persona.estudiante.padre.blank? contact_mails</operants>
      <operants>self.persona.estudiante.padre.persona.e_mail.to_s end end if object</operants>
      <operants>&quot;Madre&quot; unless self.persona.estudiante.madre.blank? contact_mails</operants>
      <operants>self.persona.estudiante.madre.persona.e_mail.to_s end end if object</operants>
      <operants>&quot;Acudiente&quot; unless self.persona.estudiante.acudiente.blank? contact_mails</operants>
      <operants>self.persona.estudiante.acudiente.persona.e_mail.to_s end end if object</operants>
      <operants>&quot;Director de grupo&quot; teacher</operants>
      <operants>Docente.find(self.persona.estudiante.current_course_student.curso.docente_id) contact_mails</operants>
      <operants>teacher.persona.e_mail.to_s end if object</operants>
      <operants>&quot;Director de secci&#xf3;n&quot;</operants>
      <operants>self.persona.estudiante.current_course_student</operants>
      <operants>self.persona.estudiante.current_course_student.curso.grade.section.admin_id director</operants>
      <operants>Administrador.find(self.persona.estudiante.current_course_student.curso.grade.section.admin_id) contact_mails</operants>
      <operants>director.persona.e_mail.to_s end end end end self.transaction do unless self.place_id.blank? unless self.in_charge.blank? mail</operants>
      <operants>Mail.new(:to => contact_mails.uniq.join(','),
            :subject=>I18n.t('nursing_report'),
            :body=> I18n.t('entered_nursing_student_alert',
              :student=>self.persona.to_s,
              :reason=>self.reason_for_visit, :date_and_hour=>self.date_and_hour_consult,
              :region=>I18n.t(&quot;region.#{self.region}.t&quot;), :injury=>I18n.t(&quot;region.#{self.region}.hurts.#{self.injury}&quot;),
              :in_charge=>I18n.t(&quot;#{self.in_charge}&quot;),
              :colegio=>school.nombre, :place=>self.place.name)

          ) else mail</operants>
      <operants>Mail.new(:to => contact_mails.uniq.join(','),
            :subject=>I18n.t('nursing_report'),
            :body=> I18n.t('entered_nursing_student_alert',
              :student=>self.persona.to_s,
              :reason=>self.reason_for_visit, :date_and_hour=>self.date_and_hour_consult,
              :region=>I18n.t(&quot;region.#{self.region}.t&quot;), :injury=>I18n.t(&quot;region.#{self.region}.hurts.#{self.injury}&quot;),
              :in_charge=>'',
              :colegio=>school.nombre, :place=>self.place.name)
          ) end else unless self.in_charge.blank? mail</operants>
      <operants>Mail.new(:to => contact_mails.uniq.join(','),
            :subject=>I18n.t('nursing_report'),
            :body=> I18n.t('entered_nursing_student_alert',
              :student=>self.persona.to_s,
              :reason=>self.reason_for_visit, :date_and_hour=>self.date_and_hour_consult,
              :region=>I18n.t(&quot;region.#{self.region}.t&quot;), :injury=>I18n.t(&quot;region.#{self.region}.hurts.#{self.injury}&quot;),
              :in_charge=>I18n.t(&quot;#{self.in_charge}&quot;),
              :colegio=>school.nombre, :place=>'')
          ) else mail</operants>
      <operants>Mail.new(:to => contact_mails.uniq.join(','),
            :subject=>I18n.t('nursing_report'),
            :body=> I18n.t('entered_nursing_student_alert',
              :student=>self.persona.to_s,
              :reason=>self.reason_for_visit, :date_and_hour=>self.date_and_hour_consult,
              :region=>I18n.t(&quot;region.#{self.region}.t&quot;), :injury=>I18n.t(&quot;region.#{self.region}.hurts.#{self.injury}&quot;),
              :in_charge=>'',
              :colegio=>school.nombre, :place=>self.place ? self.place.name : &quot; &quot;)
          ) end end mail.save!() end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.responsible_people"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>[I18n.t(&quot;father&quot;), I18n.t(&quot;mother&quot;), I18n.t(&quot;guardian&quot;), I18n.t(&quot;group_director&quot;), I18n.t(&quot;section_director&quot;)].freeze end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_responsable"/>
    <classElements xsi:type="rails:OperationsChain" name="t(self.in_charge)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_name_person"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.persona self.name">
      <operators>=</operators>
      <operants>self.persona.to_s end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_identification"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.person_id identificacion">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.persona.identificacion else identificacion</operants>
      <operants>self.identification end identificacion end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_date_and_hour_consult"/>
    <classElements xsi:type="rails:OperationsChain" name="I18n.l(self.date_and_hour_consult, :format=> :bta_time) if self.date_and_hour_consult end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_dispatched_to"/>
    <classElements xsi:type="rails:OperationsChain" name="self.dispatched_to.map{|a| I18n.t(a)}"/>
  </rubyClasses>
  <rubyClasses name="Area" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":docentes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":asignaturas" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.nombre end end"/>
  </rubyClasses>
  <rubyClasses name="Asignacion" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :nit"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :curso_nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :materia_nombre"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":evento" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":resultados" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":actividad" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :colegio_id, :message => I18n.t(&quot;Debe seleccionar un colegio por lo menos&quot;) validate :evaluacion_completa"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :fechas_validas"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :ending_date, :message => I18n.t(&quot;Debe seleccionar una fecha l&#xed;mite&quot;) validates_presence_of :fecha_publicacion"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation_on_create :set_school"/>
    <classElements xsi:type="rails:RubyMethod" name="evaluacion_completa"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:evaluacion, I18n.t(&quot;Debe seleccionar una evaluaci&#xf3;n&quot;)) unless self.evaluacion end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="clone_allocation"/>
    <classElements xsi:type="rails:OperationsChain" name="materia_destino">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Materia.id_equals(materia_id).first copia_asignacion</operants>
      <operants>self.clone copia_asignacion.materia_id</operants>
      <operants>materia_destino.id copia_asignacion.calificacion_id</operants>
      <operants>nil copia_asignacion.evento_id</operants>
      <operants>nil copia_asignacion.curso_id</operants>
      <operants>nil copia_asignacion.actividad_id</operants>
      <operants>nil copia_asignacion.save! end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="fechas_validas"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:ending_date, I18n.t(:fecha_inicio_fin)) unless self.ending_date">
      <operators>></operators>
      <operants>self.fecha_publicacion end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.nit self.colegio">
      <operators>||=</operators>
      <operants>Colegio.nit_equals(self.nit.split[0])[0]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end if self.curso_nombre self.curso">
      <operators>||=</operators>
      <operants>Curso.nombre_equals(self.curso_nombre.split('curso:')[1]).colegio_id_equals(self.colegio.id)[0]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end if self.materia_nombre self.materia">
      <operators>||=</operators>
      <operants>Materia.nombre_equals(self.materia_nombre).curso_id_equals(self.curso.id).colegio_id_equals(self.colegio.id)[0]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end return true end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.transaction do self.update_attributes({:activo => false}) for resultado in self.resultados resultado.update_attribute(:activo, false) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create event">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Evento.create(:name => &quot;Evaluaci&#xf3;n #{self.evaluacion.name}&quot;,
      :descripcion => &quot;Se debe presentar la evaluaci&#xf3;n&quot;,
      :start_at => self.fecha_publicacion,
      :end_at => self.ending_date,
      :materia_id => self.materia_id,
      :all_day => false) self.evento</operants>
      <operants>event self.save begin self.materia.updated_test_datetime</operants>
      <operants>DateTime.now self.materia.save! rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.evento event">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.evento event.update_attributes({:name => &quot;Evaluaci&#xf3;n #{self.evaluacion.name}&quot;,
          :descripcion => &quot;Se debe presentar la evaluaci&#xf3;n&quot;,
          :start_at => self.fecha_publicacion,
          :end_at => self.ending_date,
          :materia_id => self.materia.id}) else event</operants>
      <operants>Evento.create(:name => &quot;Evaluaci&#xf3;n #{self.evaluacion.name}&quot;,
        :descripcion => &quot;Se debe presentar la evaluaci&#xf3;n&quot;,
        :start_at => self.fecha_publicacion,
        :end_at => self.ending_date,
        :materia_id => self.materia.id,
        :all_day => false) self.evento</operants>
      <operants>event self.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="disponible"/>
    <classElements xsi:type="rails:OperationsChain" name="p">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.fecha_publicacion l</operants>
      <operants>self.ending_date t</operants>
      <operants>Time.now (p &lt;= t and t &lt;= l)</operants>
      <operants>true</operants>
      <operants>false end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Asignatura" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":area" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":programa" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":teacher_advises" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":super_asignatura_pesos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":super_asignaturas" relationType="has_many">
      <options key=":through" value=":super_asignatura_pesos"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :area_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :colegio_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :grade_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :grade_id, :only_integer => true , :if => :grade_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :intensidad_horaria"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :intensidad_horaria, :greater_than_or_equal_to => 0, :only_integer => true , :if => :intensidad_horaria"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_colegio end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.activo">
      <operators>==</operators>
      <operants>false self.super_asignatura_pesos.each do |peso|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="peso.delete end end for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create Programa.create(:texto => self.nombre,:asignatura_id => self.id) end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.activo">
      <operators>=</operators>
      <operants>false self.save(false) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 colegio</operants>
      <operants>Colegio.f(Persona.get_school) rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',
      &quot;#{self.to_s}.cursos_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename, :headers=>true) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin course">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Curso.code_course_equals(process_field(row['code_course'])).last areas_sistema</operants>
      <operants>Area.all area_found</operants>
      <operants>nil unless course.blank? areas_sistema.each do |a|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if (a.nombre.to_s.accents_downcase.remove_accents.capitalize.gsub('.','').gsub(',','').gsub('-','') == process_field(row['area']).accents_downcase.remove_accents.capitalize.gsub('.','').gsub(',',' ').gsub('-',''))"/>
    <classElements xsi:type="rails:OperationsChain" name="area_found">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>a break end end if area_found.blank? area_found</operants>
      <operants>Area.find(13) end asignatura</operants>
      <operants>Asignatura.nombre_like(process_field(row['nombre'])). colegio_id_equals(colegio.id).activo_equals(true).grade_id_equals(course.grade_id).last if asignatura.blank? asignatura</operants>
      <operants>self.create!(:nombre=>process_field(row['nombre']),
                :area_id=>area_found.id, :activo=>true,
                :intensidad_horaria=>1, :grade_id=>course.grade_id,
                :colegio_id=>colegio.id
              ) asignatura.save! end materia</operants>
      <operants>Materia.new materia.colegio_id</operants>
      <operants>colegio.id materia.curso_id</operants>
      <operants>course.id materia.activo</operants>
      <operants>true materia.asignatura_id</operants>
      <operants>asignatura.id materia.code_materia</operants>
      <operants>process_field(row['id'])</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="materia.save! end rescue_file.puts((row.to_a+['correct']).map{|a| &quot;\&quot;#{a.to_s.gsub(',','')}\&quot;&quot;}.join(',')) rescue ActiveRecord::Base.logger.error &quot;No se pudo procesar l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row.to_a+['fail',$!.message]).map{|a| &quot;\&quot;#{a.to_s.gsub(',','')}\&quot;&quot;}.join(',')) end counter">
      <operators>+=</operators>
      <operants>1 end end rescue_file_path end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.process_field"/>
    <classElements xsi:type="rails:OperationsChain" name="field.to_s.gsub(Persona::NAME_INVERSE_VALIDATOR,'').gsub(/ +/,' ').strip end end"/>
  </rubyClasses>
  <rubyClasses name="Asistencia" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":horario" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":attendances" relationType="has_many">
      <options key=":inverse_of" value=":asistencia"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :attendances"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :multiplier, :only_integer => true, :greater_than => 0, :lesser_than => 10"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :horario_id, :message => 'Debe seleccionar un horario'"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_date_within_a_period"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_date_day"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :set_caches"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_date_day"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.fecha">
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operators>!=</operators>
      <operants>self.horario</operants>
      <operants>((self.fecha.wday-1)%7)</operants>
      <operants>self.horario.dia self.errors.add(:fecha,t(:the_date_not_match_with_week_day)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.fecha">
      <operators>></operators>
      <operants>Date.current self.errors.add(:fecha, t(:date_ocurrence_after_now)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_date_within_a_period"/>
    <classElements xsi:type="rails:OperationsChain" name="unless get_period self.errors.add(:fecha, t(:date_must_be_in_valid_period)) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_caches"/>
    <classElements xsi:type="rails:OperationsChain" name="attendances_cache">
      <operators>=</operators>
      <operants>create_attendances_cache()</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="counter_cache">
      <operators>=</operators>
      <operants>create_counter_cache()</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.attendances.each do |a|"/>
    <classElements xsi:type="rails:OperationsChain" name="a.asistencia">
      <operators>=</operators>
      <operants>self</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="counters">
      <operators>=</operators>
      <operants>counter_cache[a.student_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="a.counter">
      <operators>=</operators>
      <operators>=</operators>
      <operants>counters.first if counters.present? a.brothers_by_period</operants>
      <operants>attendances_cache[a.student_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="a.update_counter end end"/>
    <classElements xsi:type="rails:RubyMethod" name="create_counter_cache"/>
    <classElements xsi:type="rails:OperationsChain" name="ContadorAsistencia.materia_id_eq(self.materia_id).periodo_id_eq(get_period.id).group_by(&amp;:estudiante_id) end"/>
    <classElements xsi:type="rails:RubyMethod" name="create_attendances_cache"/>
    <classElements xsi:type="rails:OperationsChain" name="asistencias_by_id">
      <operators>=</operators>
      <operants>Asistencia.materia_id_eq(self.materia_id).fecha_gte(get_period.fecha_inicio).fecha_lte(get_period.fecha_fin). all(:select=>'id, multiplier').group_by(&amp;:id) Attendance.asistencia_id_eq(asistencias_by_id.keys).each{|attendance| attendance.asistencia=asistencias_by_id[attendance.asistencia_id].first}</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="AssignmentPerson" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":quality_questionnaire" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":people" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
      <options key=":foreign_key" value="person_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{finished not_started started}"/>
    <classElements xsi:type="rails:OperationsChain" name="end validates_inclusion_of :state, :in => AssignmentPerson.states validates_uniqueness_of :person_id, :scope => :quality_questionnaire_id"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>=</operators>
      <operants>'not_started' end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="answer_sheet"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.answer_sheet_id @answer_sheet">
      <operators>||=</operators>
      <operators>!=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.quality_questionnaire.questionnaire.answer_sheet(self.answer_sheet_id) if @answer_sheet.status</operants>
      <operants>self.state self.finished_at</operants>
      <operants>@answer_sheet.last_finished_at self.state</operants>
      <operants>@answer_sheet.status self.save end @answer_sheet else begin @answer_sheet</operants>
      <operants>self.quality_questionnaire.questionnaire.create_answer_sheet(:user=> people.id) self.answer_sheet_id</operants>
      <operants>@answer_sheet.id self.save! @answer_sheet rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="e logger.error('Cant create AnswerSheet') logger.exc e end end end end"/>
  </rubyClasses>
  <rubyClasses name="AssignmentSubject" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":quality_teacher_questionnaire" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":teacher_questionnaire_answer_sheets" relationType="has_many">
      <options key=":dependent" value=":delete_all"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":subject" relationType="belongs_to">
      <options key=":class_name" value="Materia"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="AsyncTask" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":attachment" relationType="belongs_to">
      <options key=":foreign_key" value="attachment_id"/>
      <options key=":class_name" value="Binario"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":usuario" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to">
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":responses" relationType="has_many">
      <options key=":foreign_key" value="task_id"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{new ready processing ok fail}"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.kinds"/>
    <classElements xsi:type="rails:OperationsChain" name="@@kinds">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{generate_emails restore_passwords student_migration guardian_migration &#xA;      generate_score_report support_school_report footprint_report generate_student_snapshot_report &#xA;      sign_up_print honor_roll replicate_evaluation_plan generate_courses grades_migration &#xA;      quality_general_results quality_teacher_by_parents_results quality_teacher_by_students_results&#xA;      quality_generate_statistics quality_generate_teacher_statistics user_password_reset &#xA;      generate_dane_a_report generate_dane_b_report generate_5a_report generate_families_report &#xA;      generate_signup_polls_reports change_period_weigths copy_generic_subjects copy_academic_years &#xA;      copy_super_asignaturas copy_evaluation_plans copy_courses recalculate_notes quality_students_results &#xA;      quality_students_by_student_results generate_summary_score_report&#xA;    }"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.not_read_only_kinds"/>
    <classElements xsi:type="rails:OperationsChain" name="@@not_read_only_kinds">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{generate_emails restore_passwords student_migration guardian_migration}"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.read_only_kinds"/>
    <classElements xsi:type="rails:OperationsChain" name="@@read_only_kinds">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{generate_score_report support_school_report footprint_report&#xA;      generate_student_snapshot_report honor_roll replicate_evaluation_plan sign_up_print &#xA;      generate_courses grades_migration quality_general_results quality_teacher_by_parents_results &#xA;      quality_teacher_by_students_results quality_generate_statistics quality_generate_teacher_statistics &#xA;      user_password_reset generate_dane_a_report generate_dane_b_report generate_5a_report generate_families_report &#xA;      generate_signup_polls_reports change_period_weigths copy_generic_subjects copy_academic_years&#xA;      copy_super_asignaturas copy_evaluation_plans copy_courses recalculate_notes quality_students_results &#xA;      quality_students_by_student_results generate_summary_score_report&#xA;    }"/>
    <classElements xsi:type="rails:OperationsChain" name="end validates_inclusion_of :state, :in => AsyncTask.states validates_inclusion_of :kind, :in => AsyncTask.kinds validates_presence_of :usuario_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :set_metrics"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_vars"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="params="/>
    <classElements xsi:type="rails:OperationsChain" name="self.parameters">
      <operators>=</operators>
      <operants>value.to_json end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="params"/>
    <classElements xsi:type="rails:OperationsChain" name="JSON.parse(self.parameters) end private"/>
    <classElements xsi:type="rails:RubyMethod" name="set_metrics"/>
    <classElements xsi:type="rails:OperationsChain" name="self.onready">
      <operators>=</operators>
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operants>DateTime.current if self.state</operants>
      <operants>'ready' if self.onprocessing.nil?</operants>
      <operants>self.state</operants>
      <operants>'processing' self.onprocessing</operants>
      <operants>DateTime.current end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_vars"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.timeout">
      <operators>==</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>||=</operators>
      <operants>30 self.timeout</operants>
      <operants>300 if self.kind</operants>
      <operants>'generate_score_report' end self.school_id</operants>
      <operants>self.get_school self.usuario_id</operants>
      <operants>self.get_user self.tries</operants>
      <operants>0 end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Attendance" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":student" relationType="belongs_to">
      <options key=":foreign_key" value="student_id"/>
      <options key=":class_name" value="Estudiante"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":asistencia" relationType="belongs_to">
      <options key=":inverse_of" value=":attendances"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :brothers_by_period, :counter"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :student_id, :scope => [:asistencia_id], :on=>:create"/>
    <classElements xsi:type="rails:RubyMethod" name="get_counter"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operants>ContadorAsistencia.find(:first, :conditions => {:materia_id => self.asistencia.materia_id, :estudiante_id => self.student_id, :periodo_id => self.asistencia.get_period.id}) counter</operants>
      <operants>ContadorAsistencia.create(:materia_id => self.asistencia.materia_id, :estudiante_id => self.student_id, :periodo_id => self.asistencia.get_period.id, :total_fallas_no_justificadas => 0, :total_fallas_justificadas => 0, :total_clases_asistidas => 0) unless counter counter end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="update_counter"/>
    <classElements xsi:type="rails:OperationsChain" name="self.counter">
      <operators>||=</operators>
      <operants>self.get_counter self.counter.update_counts(brothers_by_period) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy self.update_counter end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.update_counter end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="AuthenticationConfig" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :school_id"/>
    <classElements xsi:type="rails:Relationship" name=":authentication_config_domains" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :authentication_config_domains, :allow_destroy => true end"/>
  </rubyClasses>
  <rubyClasses name="AuthenticationConfigDomain" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":authentication_config" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :authentication_config_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :domain, :with => /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}$/"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="Binario" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :state"/>
    <classElements xsi:type="rails:RubyMethod" name="Binario.attachment_options"/>
  </rubyClasses>
  <rubyClasses name="Block" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona_blocks" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many">
      <options key=":through" value=":persona_blocks"/>
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="TYPES">
      <operators>=</operators>
      <operants>['can_not_see_bulletins']</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Boletin" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":docente" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation_on_update :delete_duplicated"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :curso_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :persona_id, :scope => [:periodo_id], :if=>:persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :observaciones, :maximum => 16383, :allow_blank => true"/>
    <classElements xsi:type="rails:RubyMethod" name="delete_duplicated"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.periodo_id and self.persona_id and self.id Boletin.periodo_id_equals(self.periodo_id).persona_id_equals(self.persona_id). id_does_not_equal(self.id).delete_all end end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.obtener_boletin"/>
    <classElements xsi:type="rails:OperationsChain" name="persona">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Estudiante.find(estudiante_id).persona boletin</operants>
      <operants>Boletin.find(:first, :conditions => {:persona_id => persona.id ,:periodo_id => periodo_id}) boletin</operants>
      <operants>Boletin.crear_boletin(estudiante_id,periodo_id,curso_id) unless boletin return boletin end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.crear_boletin"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.error(&quot;DEPRECATED&quot;) estudiante">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Estudiante.find(estudiante_id) curso</operants>
      <operants>estudiante.cursos.find(curso_id) Boletin.create(:persona_id => estudiante.persona_id, :periodo_id => periodo_id,
      :curso_id => curso_id, :docente_id => curso.docente ? curso.docente.id : 0) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Book" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="STATES">
      <operators>=</operators>
      <operants>{5 =>  {:name => :book_draft, :icon => &quot;book_edit.png&quot;},
    6 =>  {:name => :book_released, :icon => &quot;book_revise.png&quot;},
    7 =>  {:name => :book_published_out, :icon => &quot;books.png&quot;},
    8 =>  {:name => :book_locked, :icon => &quot;book_deleted.png&quot;} }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="CONTENT_TYPES">
      <operators>=</operators>
      <operators>=</operators>
      <operants>['pdf', 'embedded_code', 'director'] SALES_PRICE</operants>
      <operants>['negotiate', 'free'] if AWS_S3_SECURE has_attached_file :image, :styles => {:default=> [&quot;150x150>&quot;,'jpg'],:thumb=>['50x50','jpg'] }, :storage => &quot;s3&quot;, :s3_credentials => {
      :access_key_id => AWS_S3_SECURE['access_key_id'] ,
      :secret_access_key => AWS_S3_SECURE['secret_access_key']
    },:s3_permissions => &quot;public-read&quot;, :bucket => AWS_S3_SECURE['bucket_name']</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :image, :content_type=>['image/jpg', 'image/jpeg','image/pjpeg',&#xA;      'image/tiff','image/png','image/gif'], :message => I18n.t(:image_format) validates_attachment_size :image, :less_than => 1.megabyte, :message => I18n.t(:image_size) end attr_protected :state"/>
    <classElements xsi:type="rails:Relationship" name=":books_requests" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":book_marks" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":sold_books" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":areas" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:Relationship" name=":binary" relationType="belongs_to">
      <options key=":class_name" value="Binario"/>
      <options key=":foreign_key" value=":binary_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :description"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :width, :allow_nil => true, :less_than_or_equal_to => 2500, :greater_than_or_equal_to => 200"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :height, :allow_nil => true, :less_than_or_equal_to => 2500, :greater_than_or_equal_to => 200"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_state"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :original_id, :if => :original_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :description, :maximum => 2048, :if => :description"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_ipaper_id, :on => :update, :unless => :ipaper_id"/>
    <classElements xsi:type="rails:Relationship" name=":copy" relationType="has_one">
      <options key=":foreign_key" value="original_id"/>
      <options key=":class_name" value="Book"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":original" relationType="belongs_to">
      <options key=":foreign_key" value="original_id"/>
      <options key=":class_name" value="Book"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_ipaper_id"/>
    <classElements xsi:type="rails:OperationsChain" name="self.update_to_crocodoc if(self.binary.state == Binario::ESTADO_ACTIVO &amp;&amp; self.crocodoc_uuid.blank?)"/>
    <classElements xsi:type="rails:OperationsChain" name="rescue logger.exc end"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_state"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.state">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>==</operators>
      <operators>==</operators>
      <operators>||</operators>
      <operators>==</operators>
      <operants>Book.states[:released]</operants>
      <operants>self.state_was</operants>
      <operants>Book.states[:draft]</operants>
      <operants>self.content_type</operants>
      <operants>'pdf' if (self.binary)</operants>
      <operants>self.binary.state</operants>
      <operants>Binario::ESTADO_ACTIVO convert_status</operants>
      <operants>CrocodocApi.status(self.crocodoc_uuid) if convert_status</operants>
      <operants>'DONE' elsif convert_status</operants>
      <operants>'ERROR' self.errors.add(:binary_id, I18n.t(:file_error)) elsif convert_status</operants>
      <operants>'PROCESSING'</operants>
      <operants>convert_status</operants>
      <operants>'QUEUED' self.errors.add(:binary_id, I18n.t(:file_no_procesado)) end else self.errors.add(:binary_id, I18n.t(:file_sin_documento)) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_convert_status"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.crocodoc_uuid CrocodocApi.status(self.crocodoc_uuid) else &quot;NOT_FILE&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="clone"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.copy">
      <operators>==</operators>
      <operators>=</operators>
      <operants>nil object_cloned</operants>
      <operants>super(:include => {:binary => nil, :book_marks=>{:evaluacion=>{:preguntas=>:opciones}, :tarea=>{}}})</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="object_cloned.original_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.id self.ipaper_id</operants>
      <operants>nil self.ipaper_access_key</operants>
      <operants>nil self.state</operants>
      <operants>Book.states[:published_out]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="begin Book.transaction do self.save! object_cloned.save! object_cloned.state">
      <operators>=</operators>
      <operants>Book.states[:published_out]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="object_cloned.save! end rescue"/>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end return object_cloned else begin Book.transaction do self.copy.attributes">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.attributes self.copy.state</operants>
      <operants>Book.states[:published_out]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.copy.save! self.copy.book_marks.destroy_all self.book_marks.each do |bookmark|"/>
    <classElements xsi:type="rails:OperationsChain" name="new_bm">
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>bookmark.clone(:include =>
                {:evaluacion=>{:preguntas=>:opciones}, :tarea=>{:binarios => nil}}) self.copy.book_marks</operants>
      <operants>new_bm new_bm.save! end self.ipaper_id</operants>
      <operants>nil self.ipaper_access_key</operants>
      <operants>nil self.state</operants>
      <operants>Book.states[:published_out]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.save! end end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>=</operators>
      <operants>Book.states[:draft]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.active</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active">
      <operators>=</operators>
      <operants>false self.save(false) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="update_to_crocodoc"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.content_type">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operants>'pdf' unless self.binary</operants>
      <operants>self.binary.state</operants>
      <operants>Binario::ESTADO_ACTIVO raise UserException, I18n.t(:upload_to_scribd_without_file) end if self.crocodoc_uuid CrocodocApi.delete(self.crocodoc_uuid) self.crocodoc_uuid</operants>
      <operants>nil self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end self.crocodoc_uuid">
      <operators>=</operators>
      <operants>CrocodocApi.upload(self.binary.get_url) self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="crocodoc_uuid"/>
    <classElements xsi:type="rails:OperationsChain" name="self.ipaper_access_key end"/>
    <classElements xsi:type="rails:RubyMethod" name="crocodoc_uuid="/>
    <classElements xsi:type="rails:OperationsChain" name="self.ipaper_access_key">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="load_thumbnail_image"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.content_type">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>'pdf' unless self.binary</operants>
      <operants>self.binary.state</operants>
      <operants>Binario::ESTADO_ACTIVO raise UserException, I18n.t(:upload_to_scribd_without_file) end if self.crocodoc_uuid filename</operants>
      <operants>CrocodocApi.get_thumbnail(self.crocodoc_uuid) self.image</operants>
      <operants>File.open(filename) self.save! end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="update_to_scribd"/>
    <classElements xsi:type="rails:OperationsChain" name="raise &quot;Scribd&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.content_type">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>'pdf' unless self.binary</operants>
      <operants>self.binary.state</operants>
      <operants>Binario::ESTADO_ACTIVO raise UserException, I18n.t(:upload_to_scribd_without_file) end if self.ipaper_id Scribd::Document.find(self.ipaper_id).destroy self.ipaper_id</operants>
      <operants>nil self.ipaper_access_key</operants>
      <operants>nil self.ipaper_version_at</operants>
      <operants>nil self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end logger.warn(self.binary.&#xA;          get_local_file) doc">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Scribd::Document.create(:file=>(self.binary.
            get_local_file), :access=> 'private', :secure=>1, :title => self.name,
        :download_and_drm=> &quot;view-only&quot;) Scribd::API.instance.send_request('docs.changeSettings',
        :doc_ids => doc.doc_id, :download_formats=>'',:disable_print=>1,
        :disable_select_text=> 1,  :disable_upload_link => 1) self.ipaper_id</operants>
      <operants>doc.doc_id self.ipaper_access_key</operants>
      <operants>doc.access_key self.ipaper_version_at</operants>
      <operants>self.binary.updated_at self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>{:draft=> 5, :released=> 6, :published_out => 7,
      :locked=> 8}</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="BookMark" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":book" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":tarea" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :page, :message => I18n.t(&quot;N&#xfa;mero de p&#xe0;gina debe ser diligenciado&quot;) validates_presence_of :name, :message => I18n.t(&quot;Nombre debe ser diligenciado&quot;) validates_numericality_of :page, :greater_than=> 0, :only_integer => true validates_length_of :name, :maximum => 100, :if => :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :url, :with => :message"/>
  </rubyClasses>
  <rubyClasses name="BooksRequest" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":book" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":docente" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :estado"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :book_id,:scope=>[:docente_id]"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.estado">
      <operators>=</operators>
      <operators>=</operators>
      <operants>BooksRequest::STATE_REQUESTED end STATE_REQUESTED</operants>
      <operants>1 end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="BusPath" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":service" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":monitor" relationType="belongs_to">
      <options key=":foreign_key" value="person_monitor_id"/>
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":driver" relationType="belongs_to">
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":service_schedules" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :route"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :capacity"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :capacity, :if => :capacity"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :route, :scope=>[:service_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :plate, :scope=>[:service_id]"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_save"/>
    <classElements xsi:type="rails:OperationsChain" name="BusPath.transaction do number_routes">
      <operators>=</operators>
      <operators>=</operators>
      <operants>BusPath.service_id_equals(self.service.id).count self.service.quantity_of_routes</operants>
      <operants>number_routes self.service.save! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 school</operants>
      <operants>Colegio.f(Persona.get_school) rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',
      &quot;#{self.to_s}.docentes_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin ActiveRecord::Base.transaction do ruta">
      <operators>=</operators>
      <operants>process_field(row[0])</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Calificacion" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":logro" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":indicador" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":actividad" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":programa" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":valores" relationType="has_many">
      <options key=":inverse_of" value=":calificacion"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :valores"/>
    <classElements xsi:type="rails:Relationship" name=":tarea" relationType="has_one">
      <options key=":conditions" value="{:activo=>true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="has_one">
      <options key=":conditions" value="{:active=>true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":score_statistics" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="belongs_to">
      <options key=":inverse_of" value=":calificaciones"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":calificaciones" relationType="has_many">
      <options key=":inverse_of" value=":calificacion"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :halt_dates_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv, :course_period"/>
    <classElements xsi:type="rails:OperationsChain" name="FILTER_DATA">
      <operators>=</operators>
      <operants>/[^A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;\-\.\/'#]*/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :peso, :greater_than_or_equal_to => 0.0, :less_than_or_equal_to => 100.0"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_dates, :unless => :halt_dates_validation"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="if period">
      <operators>=</operators>
      <operators>&amp;&amp;</operators>
      <operators>!=</operators>
      <operators>&amp;&amp;</operators>
      <operators>&lt;</operators>
      <operants>get_period self.errors.add(:peso, I18n.t(:cant_modify_weight)) if period.fecha_calificaciones</operants>
      <operants>self.peso</operants>
      <operants>self.peso_was</operants>
      <operants>period.fecha_calificaciones.to_date</operants>
      <operants>Date.current end end before_create :set_weight</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="after_save :set_parent"/>
    <classElements xsi:type="rails:OperationsChain" name="before_destroy :before_destroy_score"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :recalculate_in_destroy"/>
    <classElements xsi:type="rails:RubyMethod" name="before_destroy_score"/>
    <classElements xsi:type="rails:OperationsChain" name="sibling_ids end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_weight"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.programa.present? and self.periodo.present? self.peso">
      <operators>=</operators>
      <operants>(100.0/periodo.periodo.periodos.count.to_f).round_to(2) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="recalculate_in_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="unless sibling_ids.blank? score">
      <operators>=</operators>
      <operants>Calificacion.find(sibling_ids.first) score.valores.each do |valor|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="valor.calificacion">
      <operators>=</operators>
      <operants>score valor.after_update valor.save! end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update self.valores.each{ |v| v.save }"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.peso">
      <operators>==</operators>
      <operants>@old_weight end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_weight"/>
    <classElements xsi:type="rails:OperationsChain" name="academic_year">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>get_period.periodo</operants>
      <operants>get_period.periodo</operants>
      <operants>get_period if academic_year.escala_numerica return self.peso else return 100</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="letra_equivalente"/>
    <classElements xsi:type="rails:OperationsChain" name="letra">
      <operators>=</operators>
      <operants>if self.programa self.programa.materia.curso.periodo.escala.letras.detect { |n| n.texto == valor_alfanumerico }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="elsif self.logro and self.logro.periodo self.logro.programa.materia.curso.periodo.escala.letras.detect { |n| n.texto == valor_alfanumerico }"/>
    <classElements xsi:type="rails:OperationsChain" name="elsif self.indicador and self.indicador.logro self.indicador.logro.programa.materia.curso.periodo.escala.letras.detect { |n| n.texto == valor_alfanumerico }"/>
    <classElements xsi:type="rails:OperationsChain" name="elsif self.actividad and self.actividad.indicador self.actividad.indicador.logro.programa.materia.curso.periodo.escala.letras.detect { |n| n.texto == valor_alfanumerico }"/>
    <classElements xsi:type="rails:OperationsChain" name="else nil end letra end"/>
    <classElements xsi:type="rails:RubyMethod" name="letra_por_rango"/>
    <classElements xsi:type="rails:OperationsChain" name="@found_program">
      <operators>||=</operators>
      <operators>=</operators>
      <operants>if self and self.programa self.programa elsif self.logro and self.logro.periodo self.logro.programa elsif self.indicador and self.indicador.logro self.indicador.logro.programa elsif self.actividad and self.actividad.indicador self.actividad.indicador.logro.programa end if @found_program ordered</operants>
      <operants>@found_program.materia.curso.periodo.escala.letras.sort{|a,b| b.maximum &lt;=> a.maximum}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ordered.detect{ |n| n.minimum &lt;= valor_numerico and valor_numerico &lt;= n.maximum }"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="performance_person"/>
    <classElements xsi:type="rails:OperationsChain" name="valor">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.valores.persona_id_equals(persona_id).first unless excel valor</operants>
      <operants>(v = (valor.valor_real))</operants>
      <operants>(v= (escala_numerica ? 0.0 : &quot;&quot;)) else valor</operants>
      <operants>(v = (valor))</operants>
      <operants>(v= (&quot;&quot;)) end return v end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_value"/>
    <classElements xsi:type="rails:OperationsChain" name="valor">
      <operators>=</operators>
      <operants>self.valores.persona_id_equals(persona_id).first valor end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.materia">
      <operators>=</operators>
      <operants>self.programa.materia if self.programa end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="unless @_is_root_locked root">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>get_parents.first root.lock! if root @_is_root_locked</operants>
      <operants>true end @old_weight</operants>
      <operants>self.peso_was self.updated_by</operants>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="is_leaf"/>
    <classElements xsi:type="rails:OperationsChain" name="leaf">
      <operators>=</operators>
      <operators>!</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>if self.programa and</operants>
      <operants>self.periodo false elsif self.programa and self.periodo self.programa.logros.all(:include=>:periodo). detect{ |l| l.periodo == self.periodo }</operants>
      <operants>false</operants>
      <operants>true elsif self.logro and self.logro.periodo self.logro.indicadores.any?</operants>
      <operants>false</operants>
      <operants>true elsif self.indicador and self.indicador.logro self.indicador.actividades.any?</operants>
      <operants>false</operants>
      <operants>true elsif self.actividad and self.actividad.indicador true else false end return leaf end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_acomplishment_name"/>
    <classElements xsi:type="rails:OperationsChain" name="col_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>GestorUsuario.obtener_colegio colegio</operants>
      <operants>Colegio.find(col_id) colegio.accomplishment_name.blank?</operants>
      <operants>t(:accomplishment)</operants>
      <operants>colegio.accomplishment_name end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_acomplishment_indicator_name"/>
    <classElements xsi:type="rails:OperationsChain" name="col_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>GestorUsuario.obtener_colegio colegio</operants>
      <operants>Colegio.find(col_id) colegio.accomplishment_indicator_name.blank?</operants>
      <operants>t(:accomplishment_indicator)</operants>
      <operants>colegio.accomplishment_indicator_name end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="is_eliminable"/>
    <classElements xsi:type="rails:OperationsChain" name="return self.tarea.blank?">
      <operators>&amp;&amp;</operators>
      <operants>self.evaluacion.blank? end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.crear_calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="return if args">
      <operators>==</operators>
      <operants>{}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="calificacion">
      <operators>=</operators>
      <operants>if args[:programa_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="and args[:periodo_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="Calificacion.create(:programa_id => args[:programa_id], :periodo_id => args[:periodo_id], :texto => texto, :peso => 0.0, :adicional => false) elsif args[:programa_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="Calificacion.create(:programa_id => args[:programa_id], :texto => texto, :peso => 0.0, :adicional => false) elsif args[:logro_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="Calificacion.create(:logro_id => args[:logro_id], :texto => texto, :peso => 0.0, :adicional => false) elsif args[:indicador_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="Calificacion.create(:indicador_id => args[:indicador_id], :texto => texto, :peso => 0.0, :adicional => false) elsif args[:actividad_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="Calificacion.create(:actividad_id => args[:actividad_id], :texto => texto, :peso => 0.0, :adicional => false) else nil end calificacion end"/>
    <classElements xsi:type="rails:RubyMethod" name="adicional="/>
    <classElements xsi:type="rails:OperationsChain" name="logger.error 'METHOD WTF??? calificaicon.adicional'"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_descendants_and_current"/>
  </rubyClasses>
  <rubyClasses name="CardSetting" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="CARD_TYPES">
      <operators>=</operators>
      <operants>[&quot;none&quot;,&quot;vertical1&quot;, &quot;horizontal1&quot;,&quot;horizontal2&quot;, &quot;horizontal3&quot;]</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end if AWS_S3_SECURE has_attached_file :photo, :styles => {&#xA;      :default=>&quot;200x200>&quot;,&#xA;      :thumbnail=>'100x100',&#xA;      :card=>'300x300'&#xA;    }, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;    },:s3_permissions => :public_read, :storage => :s3, :s3_protocol=> :https, :bucket => AWS_S3_SECURE['bucket_name'], :path => &quot;schools/:id/school/:class/:attachment/:id/:style.:extension&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :photo, :content_type=>['image/jpg', 'image/jpeg','image/pjpeg',&#xA;      'image/tiff','image/png','image/gif'], :message => I18n.t(:format_no_valid) validates_attachment_size :photo, :less_than => 1.megabyte, :message => I18n.t(:size_no_valid) end end"/>
  </rubyClasses>
  <rubyClasses name="Cargo" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":administradores" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="CARGO_SECRETARIO">
      <operators>=</operators>
      <operants>7</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.nombre end end"/>
  </rubyClasses>
  <rubyClasses name="Categoria" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":rangos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":preguntas" relationType="has_many">
      <options key=":conditions" value="{:active => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":opcion_preguntas" relationType="has_many">
      <options key=":class_name" value="Pregunta"/>
      <options key=":conditions" value="{&#xA;    :question_type_id =>[QuestionType::OPCIONES, QuestionType::RANGO, QuestionType::VERDADEROFALSO], :active => true&#xA;  }"/>
      <options key=":order" value="orden"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":survey_permisions" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :name, :within =>">
      <operators>..</operators>
      <operants>50 after_save :set_admin_profiles, :desactivate_questions</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="new_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="@new_profiles">
      <operators>||=</operators>
      <operants>self.survey_permisions.map(&amp;:profile) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="new_profiles="/>
    <classElements xsi:type="rails:OperationsChain" name="@new_profiles">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="desactivate_questions"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.active.blank? or self.active">
      <operators>!=</operators>
      <operants>true unless self.preguntas.blank? self.preguntas.each do |preg_categoria|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="preg_categoria.active">
      <operators>=</operators>
      <operants>false preg_categoria.save! end end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.active</operants>
      <operants>true if self.active.nil? end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.school_id</operants>
      <operants>self.class.get_school() if self.class.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="transaction self.preguntas.update_all(:active => false) self.active">
      <operators>=</operators>
      <operants>false self.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_admin_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="if @new_profiles and @new_profiles.is_a?(Array) self.survey_permisions.each do |current_profile|"/>
    <classElements xsi:type="rails:OperationsChain" name="unless @new_profiles.include?(current_profile.profile) current_profile.destroy end end (@new_profiles-self.survey_permisions.map(&amp;:profile))"/>
  </rubyClasses>
  <rubyClasses name="Ciudad" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegios" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":comunas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":departamento" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":pais" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.departamento.nombre} - #{self.nombre}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="name_city"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.nombre}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="divipola"/>
    <classElements xsi:type="rails:OperationsChain" name="cadena">
      <operators>=</operators>
      <operants>self.attributes['divipola']</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Cobro" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":conceptos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":facturas" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :fecha_inicio, :message => I18n.t(&quot;debe definir una fecha de inicio&quot;) validates_presence_of :fecha_final, :message => I18n.t(&quot;debe definir una fecha final&quot;) validates_presence_of :nombre, :message => I18n.t(&quot;debe ser diligenciado&quot;) validate :validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_anho_academico"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.fecha_inicio">
      <operators>==</operators>
      <operators>-</operators>
      <operators>==</operators>
      <operators>-</operators>
      <operators>==</operators>
      <operators>-</operators>
      <operators>></operators>
      <operators>-</operators>
      <operators>></operators>
      <operators>-</operators>
      <operators>></operators>
      <operators>-</operators>
      <operators>></operators>
      <operants>self.fecha_final self.errors.add(:fecha_inicio, I18n.t(&quot;fechas iguales&quot;))</operants>
      <operants>self.errors.add(:fecha_final, I18n.t(&quot;fechas iguales&quot;)) elsif self.fecha_inicio</operants>
      <operants>self.fecha_corte self.errors.add(:fecha_inicio, I18n.t(&quot;fechas iguales&quot;))</operants>
      <operants>self.errors.add(:fecha_corte, I18n.t(&quot;fechas iguales&quot;)) elsif self.fecha_inicio</operants>
      <operants>self.fecha_limite_pago self.errors.add(:fecha_inicio, I18n.t(&quot;fechas iguales&quot;))</operants>
      <operants>self.errors.add(:fecha_limite_pago, I18n.t(&quot;fechas iguales&quot;)) elsif self.fecha_inicio</operants>
      <operants>self.fecha_final self.errors.add(:fecha_inicio, I18n.t(&quot;no debe ser mayor&quot;))</operants>
      <operants>self.errors.add(:fecha_final, I18n.t(&quot;no debe ser menor&quot;)) elsif self.fecha_inicio</operants>
      <operants>self.fecha_corte self.errors.add(:fecha_inicio, I18n.t(&quot;no debe ser mayor&quot;))</operants>
      <operants>self.errors.add(:fecha_corte, I18n.t(&quot;no debe ser menor&quot;)) elsif self.fecha_inicio</operants>
      <operants>self.fecha_limite_pago self.errors.add(:fecha_inicio, I18n.t(&quot;no debe ser mayor&quot;))</operants>
      <operants>self.errors.add(:fecha_limite_pago, I18n.t(&quot;no debe ser menor&quot;)) elsif self.fecha_final</operants>
      <operants>self.fecha_corte end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validar_anho_academico"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.periodo_id padre">
      <operators>=</operators>
      <operators>&lt;</operators>
      <operators>></operators>
      <operators>&lt;</operators>
      <operators>></operators>
      <operants>self.periodo if self.fecha_inicio</operants>
      <operants>padre.fecha_inicio self.errors.add(:fecha_inicio, I18n.t(&quot;rango academico&quot;)) elsif self.fecha_final</operants>
      <operants>padre.fecha_fin self.errors.add(:fecha_final, I18n.t(&quot;rango academico&quot;)) elsif self.fecha_limite_pago</operants>
      <operants>padre.fecha_inicio self.errors.add(:fecha_limite_pago, I18n.t(&quot;rango academico&quot;)) elsif self.fecha_corte</operants>
      <operants>padre.fecha_fin self.errors.add(:fecha_corte, I18n.t(&quot;rango academico&quot;)) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.facturas.each do |f|"/>
    <classElements xsi:type="rails:OperationsChain" name="f.update_attribute(:active, false) end self.active">
      <operators>=</operators>
      <operants>false self.save end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Colegio" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="ENABLE_EDITION_FOR_STUDENT_NEVER">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 ENABLE_EDITION_FOR_STUDENT_ON_BLANK</operants>
      <operants>2 ENABLE_EDITION_FOR_STUDENT_ALWAYS</operants>
      <operants>3 INTERFACES</operants>
      <operants>[ ['Verde', 'verde'],['Azul', 'azul'],['Rojo Oscuro', 'rojo_oscuro']] PLANS</operants>
      <operants>['insurance', 'direct'] PERIODICITIES</operants>
      <operants>['free', 'semester', 'year'] PPRICES</operants>
      <operants>{'direct' => '464.000', 'insurance'=>''}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="PAYMENTS">
      <operators>=</operators>
      <operants>{  'insurance' => '',
    'direct' => 'http://www.saberes.com/products/sistema-saberes-paquete-completo'}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="INSCRIPTION_URL">
      <operators>=</operators>
      <operants>&quot;https://app.sistemasaberes.com/public_contents/colegios/&quot; attr_accessor :admin_name</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :sign_up_template"/>
    <classElements xsi:type="rails:OperationsChain" name="acts_as_configurable :class_name => 'Configuration'"/>
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":estudiantes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":acudientes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":docentes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":administradores" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":logo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":ciudad" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":pais" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":departamento" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":communication_configuration" relationType="has_one">
      <options key=":foreign_key" value=":school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":logins" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":facturas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":informes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":plantillas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":asignaturas" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":sign_ups" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":headquarters" relationType="has_many">
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":sign_up_test" relationType="has_one">
      <options key=":conditions" value="{:active => true, :test_type=>'student'}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":card_setting" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":school_config" relationType="has_one">
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":sign_up_tests" relationType="has_many">
      <options key=":conditions" value="{:active => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":grades" relationType="has_many">
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":smtp_servers" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":parent_on_behalf_student_permissions" relationType="has_many">
      <options key=":foreign_key" value=":school_id"/>
      <options key=":class_name" value="ParentOnbehalfStudentPermission"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":parent_on_behalf_students_grades" relationType="has_many">
      <options key=":through" value=":parent_on_behalf_student_permissions"/>
      <options key=":source" value=":grade"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":authentication_config" relationType="has_one">
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :school_config"/>
    <classElements xsi:type="rails:OperationsChain" name="has_attached_file :logo_image, :styles => {&#xA;    :default=>&quot;200x200>&quot;,&#xA;    :thumbnail=>'100x100',&#xA;    :card=>'300x300'&#xA;  }, :s3_credentials => {&#xA;    :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;    :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;  },:s3_permissions => :public_read, :storage => :s3, :s3_protocol=> :https, :bucket => AWS_S3_SECURE['bucket_name'], :path => &quot;schools/:id/school/:class/:attachment/:id/:style.:extension&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :logo_image, :content_type=>['image/jpg', 'image/jpeg','image/pjpeg',&#xA;    'image/tiff','image/png','image/gif'], :message => I18n.t(:format_no_valid) validates_attachment_size :logo_image, :less_than => 1.megabyte, :message => I18n.t(:size_no_valid) CARD_TYPES">
      <operators>=</operators>
      <operators>=</operators>
      <operants>[&quot;none&quot;,&quot;vertical1&quot;, &quot;horizontal1&quot;,&quot;horizontal2&quot;, &quot;horizontal3&quot;] CARD_TYPES_PRESENTACION</operants>
      <operants>[&quot;none&quot;,&quot;la_presentacion&quot;] serialize :advises_types</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre, :message => I18n.t(&quot;Ingrese el nombre&quot;) validates_presence_of :nit, :message => I18n.t(&quot;Ingrese el NIT&quot;) validates_presence_of :telefono, :message => I18n.t(&quot;Ingrese un telefono&quot;) validates_presence_of :direccion, :message => I18n.t(&quot;Ingrese la direccion&quot;) validates_presence_of :url_matricula"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :numero_de_usuarios, :greater_than=> 0,:only_integer => true , :if => :numero_de_usuarios"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :nombre, :maximum=>250, :if => :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :telefono, :maximum=>20, :if => :telefono"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :direccion, :maximum=>250, :if => :direccion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :pagina_web, :maximum=>250, :if => :pagina_web"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :e_mail, :maximum=>250, :if => :e_mail"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :enfasis, :maximum=>250, :if => :enfasis"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :nit, :message=>I18n.t(&quot;Este nit ya se encuentra registrado&quot;), :unless=>Proc.new { |colegio| colegio.nit.blank? || colegio.nit==0}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :e_mail, :message=>I18n.t(&quot;este correo electronico ya esta&quot;), :if => :e_mail"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :url_matricula"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :url_matricula, :with => /^[a-z0-9_\-]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :resolucion, :only_integer => true , :if => :resolucion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :resolucion_date, :if => :resolucion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :dane, :only_integer => true , :if => :dane"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :terms_accepted"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :plan"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :admin_name, :on => :create"/>
    <classElements xsi:type="rails:OperationsChain" name="MOBILE_PHONE_VALIDATOR">
      <operators>=</operators>
      <operants>/^3([01][0-9]|2[0-4]|50)[0-9]{7}\z/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :telefono_movil, :with => MOBILE_PHONE_VALIDATOR , :if=>Proc.new{|o| o.telefono_movil.present? &amp;&amp; o.telefono_movil != o.telefono_movil_was}, :message => 'Formato no v&#xe1;lido. Se esperaba (3XXXXXXXXX)'"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :nombre, :enfasis, :with => /^[A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xfa;&#xfc;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xf1;&#xd1; _]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :direccion, :with => /^[A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc; _#-]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :e_mail, :with => /^[A-Z a-z 0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}$/i"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :nit, :with => before_validation_on_create :generate_random_url"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_e_mail"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_e_mail"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.inscrito if Usuario.nombre_equals(self.e_mail).count">
      <operators>></operators>
      <operants>0 self.errors.add(:e_mail, I18n.t(&quot;este correo electronico ya esta&quot;)) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create create_grades setup_configurations Plantilla.create(:nombre => 'Est&#xe1;ndar Saberes',:archivo  => 'estandar_saberes', :colegio_id => self.id) Plantilla.create(:nombre => 'Est&#xe1;ndar Saberes Logros',:archivo  => 'estandar_saberes_logros', :colegio_id => self.id) unless self.inscrito persona">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Persona.create!(:nombre => self.admin_name,
        :apellido =>  self.admin_name,
        :tipo_documento_id => 7,
        :identificacion =>  self.nit.split(&quot;-&quot;).at(0),
        :fecha_nacimiento =>  Time.now-1.year,
        :e_mail =>  self.e_mail,
        :telefono =>  self.telefono,
        :sexo => true,
        :celular =>  self.telefono_movil,
        :direccion =>  self.direccion,
        :colegio_id => self.id,
        :ciudad_id =>  10093) administrator</operants>
      <operants>Administrador.create!(:colegio_id => self.id,
        :persona => persona) user</operants>
      <operants>Usuario.create!(:colegio_id => self.id,
        :nombre => self.e_mail,
        :password => self.nit,
        :password_confirmation => self.nit,
        :persona => persona,
        :activo => true) user.perfil_ids</operants>
      <operants>[4] user.save! mail</operants>
      <operants>Mail.new() mail.cco</operants>
      <operants>&quot;soporte@sistemasaberes.com, info@sistemasaberes.com&quot; mail.subject</operants>
      <operants>I18n.t(:sign_up_new_school_uncomplete) payment_data</operants>
      <operants>(self.plan != 'insurance')</operants>
      <operants>I18n.t(:sign_up_new_school_uncomplete_payment,
        :url_pago => Colegio::PAYMENTS[self.plan], :plan => I18n.t(self.plan),
        :periodicity => I18n.t(self.periodicity), :value => Colegio::PPRICES[self.plan] )</operants>
      <operants>&quot;&quot; mail.body</operants>
      <operants>I18n.t(:sign_up_new_school_uncomplete_body, :colegio => self.nombre,
        :url => &quot;#{Colegio::INSCRIPTION_URL}#{self.id}&quot;,
        :user => self.e_mail, :password => self.nit, :pago => payment_data) mail.to</operants>
      <operants>self.e_mail mail.save! DirectorProfile.create!(:director => administrator, :profile => &quot;administration&quot;) DirectorProfile.create!(:director => administrator, :profile => &quot;manage_permissions&quot;) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="create_grades"/>
    <classElements xsi:type="rails:OperationsChain" name="Colegio.grados.each_with_index do |grado,index|"/>
    <classElements xsi:type="rails:OperationsChain" name="school_grade">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Grade.new school_grade.name</operants>
      <operants>grado[0]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="school_grade.level">
      <operators>=</operators>
      <operants>grado[1]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="school_grade.translation">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Translation.create(:spanish => grado[0], :english => Colegio.english_grades[index][0], :colegio_id => self.id) school_grade.school_id</operants>
      <operants>self.id school_grade.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="initialize"/>
    <classElements xsi:type="rails:OperationsChain" name="super(params)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.idioma">
      <operators>=</operators>
      <operants>&quot;es&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.enable_edition_for_student_options"/>
    <classElements xsi:type="rails:OperationsChain" name="@@enable_edition_for_student_options">
      <operators>||=</operators>
      <operants>[ENABLE_EDITION_FOR_STUDENT_NEVER, ENABLE_EDITION_FOR_STUDENT_ON_BLANK, ENABLE_EDITION_FOR_STUDENT_ALWAYS] end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_enable_edition_for_student_option_name"/>
    <classElements xsi:type="rails:OperationsChain" name="option @@enable_edition_for_student_options_hash">
      <operators>||=</operators>
      <operants>{
      ENABLE_EDITION_FOR_STUDENT_NEVER => &quot;enable_edition_for_student_never&quot;,
      ENABLE_EDITION_FOR_STUDENT_ON_BLANK => &quot;enable_edition_for_student_on_blank&quot;,
      ENABLE_EDITION_FOR_STUDENT_ALWAYS => &quot;enable_edition_for_student_always&quot;

    }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="@@enable_edition_for_student_options_hash[option]"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="periodo_actual"/>
    <classElements xsi:type="rails:OperationsChain" name="self.periodos.find(:first,&#xA;      :conditions =>[ &quot;colegio_id = :colegio_id AND activo = :activo &quot; +&#xA;          &quot;AND periodo_id IS NULL AND :fecha BETWEEN fecha_inicio AND fecha_fin&quot;,&#xA;        {:activo => true,&#xA;          :periodo_id => nil,:colegio_id => self,&#xA;          :fecha=>(DateTime.now)}]) end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.grados"/>
    <classElements xsi:type="rails:OperationsChain" name="@@degrees">
      <operators>=</operators>
      <operants>[
      ['Transici&#xf3;n', 0],
      ['Primero', 1],
      ['Segundo', 2],
      ['Tercero', 3],
      ['Cuarto', 4],
      ['Quinto', 5],
      ['Sexto', 6],
      ['S&#xe9;ptimo', 7],
      ['Octavo', 8],
      ['Noveno', 9],
      ['D&#xe9;cimo', 10],
      ['Und&#xe9;cimo', 11],
      ['Otro', 12]] end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.english_grades"/>
    <classElements xsi:type="rails:OperationsChain" name="@@english_degrees">
      <operators>=</operators>
      <operants>[
      ['kindergarten', 0],
      ['First', 1],
      ['Second', 2],
      ['Third', 3],
      ['Fourth', 4],
      ['Fifth', 5],
      ['Sixth', 6],
      ['Seventh', 7],
      ['Eighth', 8],
      ['Ninth', 9],
      ['Tenth', 10],
      ['Eleventh', 11],
      ['Other', 12]] end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.jornadas"/>
    <classElements xsi:type="rails:OperationsChain" name="@@jornadas">
      <operators>=</operators>
      <operants>[['Ma&#xf1;ana',1],['Tarde',2], ['&#xda;nica',3]] end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.nit} #{self.nombre}&quot;.titleize end"/>
    <classElements xsi:type="rails:RubyMethod" name="ubicacion"/>
    <classElements xsi:type="rails:OperationsChain" name="@ubicacion">
      <operators>||</operators>
      <operants>&quot;#{self.ciudad.to_s}&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="ubicacion="/>
    <classElements xsi:type="rails:OperationsChain" name="@ubicacion">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="report_count_by_time_and_profile"/>
    <classElements xsi:type="rails:OperationsChain" name="end_date">
      <operators>=</operators>
      <operants>args[:end]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="date">
      <operators>=</operators>
      <operants>args[:start]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="report">
      <operators>=</operators>
      <operants>{}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="user_ids">
      <operators>=</operators>
      <operants>self.logins.created_at_gt(date).created_at_lt(end_date). all(:select =>'usuario_id').map(&amp;:usuario_id).uniq.sort Perfil.id_gt(1).each do |perfil|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="report[perfil.id]">
      <operators>=</operators>
      <operants>perfil.usuarios.id_equals(user_ids).count end report end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="generate_random_url"/>
    <classElements xsi:type="rails:OperationsChain" name="self.url_matricula">
      <operators>=</operators>
      <operants>&quot;#{Colegio.maximum(:id).to_i+1}-#{I18n.transliterate(self.nombre.to_s).downcase.gsub(/[^a-z0-9]/,'-')}&quot; self.build_school_config end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="erase_in_chain"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.sign_up_tests.blank? self.sign_up_tests.each{|sut| sut.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.smtp_servers.blank? self.smtp_servers.each{|smtp| smtp.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.headquarters.blank? self.headquarters.each{|head| head.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.plantillas.blank? self.plantillas.each{|plant| plant.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.facturas.blank? self.facturas.each{|fac| fac.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.periodos.blank? self.periodos.each do |period|"/>
    <classElements xsi:type="rails:OperationsChain" name="if period.periodos.any? period.periodos.each{|per| per.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="else period.delete end end end unless self.administradores.blank? self.administradores.each{|admin| admin.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.docentes.blank? self.docentes.each{|doc| doc.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.estudiantes.blank? self.estudiantes.each{|est| est.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.personas.blank? self.personas.each do |person|"/>
    <classElements xsi:type="rails:OperationsChain" name="unless person.valores.blank? person.valores.each{|val| val.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end end end unless self.sign_ups.blank? self.sign_ups.each{|sign| sign.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.grades.blank? self.grades.each{|grade| grade.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end unless self.logins.blank? self.logins.each{|login| login.delete}"/>
    <classElements xsi:type="rails:OperationsChain" name="end users">
      <operators>=</operators>
      <operants>Usuario.colegio_id_equals(self.id).delete_all self.delete end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="setup_configurations"/>
    <classElements xsi:type="rails:OperationsChain" name="self.configure.billfold_module">
      <operators>=</operators>
      <operants>false self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="SchoolConfig.create!(:school_id => self.id) end end"/>
  </rubyClasses>
  <rubyClasses name="Comentario" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":binario" relationType="belongs_to">
      <options key=":conditions" value="{:state => Binario::ESTADO_ACTIVO}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":user" relationType="belongs_to">
      <options key=":foreign_key" value=":created_by"/>
      <options key=":class_name" value="Usuario"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":pending_notification" relationType="has_one">
      <options key=":dependent" value=":destroy"/>
      <options key=":foreign_key" value="post_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":topic" relationType="belongs_to">
      <options key=":class_name" value="Comentario"/>
      <options key=":foreign_key" value="topic_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":topic_posts" relationType="has_many">
      <options key=":class_name" value="Comentario"/>
      <options key=":foreign_key" value="topic_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":parent" relationType="belongs_to">
      <options key=":class_name" value="Comentario"/>
      <options key=":foreign_key" value="comentario_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":comentarios" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre,:message =>I18n.t(&quot;Ingrese el nombre&quot;), :unless => :comentario_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :comentario, :message =>I18n.t(&quot;El comentario en blanco&quot;) validates_length_of :comentario, :within =>">
      <operators>..</operators>
      <operants>2024</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>Thread.current['usuario']</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.user_name">
      <operators>=</operators>
      <operants>Thread.current[:usuario_nombre]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.topic_id">
      <operators>=</operators>
      <operators>||</operators>
      <operators>||=</operators>
      <operants>self.parent.topic_id</operants>
      <operants>self.parent.id if self.parent self.materia_id</operants>
      <operants>self.parent.materia_id end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create self.create_pending_notification(:kind=>'forum', :topic=>self.materia) unless self.topic begin if self.comentario_id self.materia.attributes">
      <operators>=</operators>
      <operants>{:didnt_see_updates_forums_counter => self.materia.didnt_see_homeworks_counter+1,
          :did_updates_forums_datetime => DateTime.now}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="else self.materia.attributes">
      <operators>=</operators>
      <operants>{:updated_forums_datetime => DateTime.now}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end self.materia.save! rescue"/>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy self.binario.destroy if self.binario end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.nombre end end"/>
  </rubyClasses>
  <rubyClasses name="CommunicationConfiguration" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to">
      <options key=":foreign_key" value=":school_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="AUTOR">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>&quot;autor_email&quot; GENERIC</operants>
      <operants>&quot;generic_email&quot; MAILERS</operants>
      <operants>[AUTOR, GENERIC] validate :stmp_servers</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="stmp_servers"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.email_copy">
      <operators>&amp;&amp;</operators>
      <operators>&lt;</operators>
      <operants>self.colegio.smtp_servers.count</operants>
      <operants>1 self.errors.add('email_copy', t('smtp_server_validation')) end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Comuna" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":ciudad" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.codigo.to_s} #{self.nombre}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="Concepto" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":cobro" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":items" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":facturas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":concepto_personas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :descripcion, :message => I18n.t(&quot;debe ser diligenciado&quot;) validates_presence_of :valor, :message => I18n.t(&quot;debe ser diligenciado&quot;) validate :states_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :payment_validation"/>
    <classElements xsi:type="rails:RubyMethod" name="payment_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:state, I18n.t(&quot;there_are_payments&quot;)) if self.items. factura_estado_equals(Factura::PAGADA).count">
      <operators>></operators>
      <operants>0 end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="states_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:state, I18n.t(&quot;state_change_no_valid&quot;)) if self. state_was">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operants>self.class.states[:approved]</operants>
      <operants>self.state</operants>
      <operants>self.class.states[:created]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>{:created => 1, :approved=> 2}</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Configuration" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":configurable" relationType="belongs_to">
      <options key=":polymorphic" value="true"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="ContadorAsistencia" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":estudiante" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :estudiante_id, :scope => [:materia_id, :periodo_id], :on => :create"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="update_counts"/>
    <classElements xsi:type="rails:OperationsChain" name="brothers">
      <operators>||=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Attendance.student_id_equals(self.estudiante_id).asistencia_materia_id_equals(self.materia_id).asistencia_fecha_gte(self.periodo.fecha_inicio).asistencia_fecha_lte(self.periodo.fecha_fin).find(:all, :include=> :asistencia) self.total_clases_asistidas</operants>
      <operants>0 self.total_fallas_justificadas</operants>
      <operants>0 self.total_fallas_no_justificadas</operants>
      <operants>0 brothers.each do |bro|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if bro.fail_justified">
      <operators>==</operators>
      <operators>+=</operators>
      <operators>==</operators>
      <operators>+=</operators>
      <operators>+=</operators>
      <operants>nil self.total_clases_asistidas</operants>
      <operants>bro.asistencia.multiplier else if bro.fail_justified</operants>
      <operants>true self.total_fallas_justificadas</operants>
      <operants>bro.asistencia.multiplier else self.total_fallas_no_justificadas</operants>
      <operants>bro.asistencia.multiplier end end end self.save! end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_nonattendances"/>
    <classElements xsi:type="rails:OperationsChain" name="contador">
      <operators>=</operators>
      <operants>ContadorAsistencia.estudiante_id_equals(estudiante_id).materia_id_equals(materia_id).periodo_id_equals(periodo_id).first unless contador return 0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="else if tipo">
      <operators>==</operators>
      <operators>==</operators>
      <operators>+</operators>
      <operants>&quot;injustificada&quot; return contador.total_fallas_no_justificadas elsif tipo</operants>
      <operants>&quot;justificada&quot; return contador.total_fallas_justificadas else return contador.total_fallas_no_justificadas.to_i</operants>
      <operants>contador.total_fallas_justificadas.to_i end end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Contenido" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":binario" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy if self.binario self.binario.destroy end end"/>
    <classElements xsi:type="rails:RubyMethod" name="anular"/>
    <classElements xsi:type="rails:OperationsChain" name="self.activo">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.activo self.save end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.id} #{self.nombre}&quot; end protected"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_file_selected"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:binario_id, I18n.t(:file_no_selected)) unless self.binario.state">
      <operators>==</operators>
      <operants>2 end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="CourseStudent" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to">
      <options key=":class_name" value="Curso"/>
      <options key=":foreign_key" value="course_id"/>
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":estudiante" relationType="belongs_to">
      <options key=":class_name" value="Estudiante"/>
      <options key=":foreign_key" value="student_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :course_id, :scope => [:student_id, :state], :if => :state"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :course_id, :student_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_uniqueness_course, :if => :course_id"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation_on_create :set_defaults"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :update_course"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :set_uniq_current_sign_up"/>
    <classElements xsi:type="rails:OperationsChain" name="STATES">
      <operators>=</operators>
      <operants>['active','deleted'] attr_protected :sign_up_number</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :estudiante"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create logger.info(&quot;CourseStudent created #{self.inspect}&quot;) end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.curso.electivo">
      <operators>==</operators>
      <operants>false CourseStudent.state_equals(&quot;active&quot;).curso_electivo_equals(true).student_id_equals(self.student_id).curso_periodo_id_equals(self.curso.periodo_id).each do |course_elective|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="course_elective.approved">
      <operators>=</operators>
      <operants>self.approved course_elective.send(:update_without_callbacks) end end logger.info(&quot;CourseStudent updated #{self.inspect}&quot;) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="active"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>==</operators>
      <operants>'active' end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="update_course"/>
    <classElements xsi:type="rails:OperationsChain" name="self.curso.save! end"/>
    <classElements xsi:type="rails:RubyMethod" name="approved="/>
    <classElements xsi:type="rails:OperationsChain" name="value super value ''"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>=</operators>
      <operants>'deleted' self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="update_course if self.curso logger.info(&quot;CourseStudent destroyed #{self.inspect}&quot;) for_destroy self end"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_uniqueness_course"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.curso course_ids">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>(Curso.electivo_equals(false).activo_equals(true).periodo_id_equals(self.curso.periodo.id)).map(&amp;:id) else curso</operants>
      <operants>Curso.find(self.course_id) period</operants>
      <operants>Periodo.find(curso.periodo_id).last course_ids</operants>
      <operants>(Curso.electivo_equals(false).activo_equals(true).periodo_id_equals(period.id)).map(&amp;:id) course</operants>
      <operants>Curso.find(self.course_id) end other_course</operants>
      <operants>CourseStudent.student_id_equals(self.student_id).course_id_equals(course_ids). course_id_does_not_equal(self.course_id).state_equals('active').first no_electivo</operants>
      <operants>0 electivo</operants>
      <operants>1 other_course unless self.curso.electivo if other_course self.errors.add(:course_id, I18n.
                        t('student_already_are_in_other_course_of_this_period',
                          :name => self.estudiante.persona.to_s,
                          :course => other_course.curso.to_s)) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_approbation"/>
    <classElements xsi:type="rails:OperationsChain" name="case self.approved when true return I18n.t(:approved) when false return I18n.t(:dont_approved) else return I18n.t(:undefined) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_repeated"/>
    <classElements xsi:type="rails:OperationsChain" name="self.repeated">
      <operators>?</operators>
      <operators>: </operators>
      <operants>I18n.t(&quot;afirmation&quot;)</operants>
      <operants>I18n.t(&quot;negation&quot;) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_pay_enrollment"/>
    <classElements xsi:type="rails:OperationsChain" name="self.pay_enrollment">
      <operators>?</operators>
      <operators>: </operators>
      <operants>I18n.t(&quot;yes_pay&quot;)</operants>
      <operants>I18n.t(&quot;doesnt_pay&quot;) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_defaults"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>=</operators>
      <operators>=</operators>
      <operators>||=</operators>
      <operators>+</operators>
      <operators>||=</operators>
      <operators>+</operators>
      <operants>'active' begin current_sign_up_number</operants>
      <operants>CourseStudent.curso_periodo_colegio_id_equals(self.curso.colegio_id).curso_electivo_equals(false). curso_periodo_fecha_inicio_gte(Date.new(self.curso.periodo.fecha_inicio.year,1,1)). curso_periodo_fecha_inicio_lte(Date.new(self.curso.periodo.fecha_inicio.year,12,31)). maximum(:sign_up_number) current_sign_up_number</operants>
      <operants>self.curso.periodo.fecha_inicio.year.to_s</operants>
      <operants>'00000' self.sign_up_number</operants>
      <operants>current_sign_up_number.to_i</operants>
      <operants>1 rescue logger.exc end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_uniq_current_sign_up"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.current_sign_up">
      <operators>==</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>!=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>true self.current_sign_up</operants>
      <operants>false if self.curso.electivo</operants>
      <operants>true if self.current_sign_up and self.current_sign_up</operants>
      <operants>self.current_sign_up_was self.estudiante.course_students.update_all(:current_sign_up => false) end if self.current_sign_up self.estudiante.grade_id</operants>
      <operants>self.curso.grade_id self.estudiante.send(:update_without_callbacks) sign_up</operants>
      <operants>self.estudiante.sign_up self.estudiante.sign_up.year</operants>
      <operants>self.curso.periodo.fecha_inicio.year sign_up.send(:update_without_callbacks) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="migrate_course"/>
    <classElements xsi:type="rails:OperationsChain" name="old_topics">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.curso.materias.all(:include => {:programa => :calificaciones}) new_topics</operants>
      <operants>new_course.materias.all(:include => {:programa => :calificaciones}).group_by(&amp;:asignatura_id) old_attendances_counter</operants>
      <operants>ContadorAsistencia.estudiante_id_equals(self.estudiante.id).materia_id_equals(old_topics.map(&amp;:id)).group_by(&amp;:materia_id) transaction do self.course_id</operants>
      <operants>new_course.id self.updated_by</operants>
      <operants>GestorUsuario.obtener_usuario self.send(:update_without_callbacks) self.curso.save! new_course.save! old_topics.each do |old_topic|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="new_topic">
      <operators>=</operators>
      <operants>new_topics[old_topic.asignatura_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="unless new_topic.blank? self.migrate_topic(old_topic,new_topic.first,old_attendances_counter) end end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="migrate_topic"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.info(&quot;Migrating topic #{old_topic.id} to #{new_topic.id}&quot;) new_topic.programa.setup_scores old_topic.programa.setup_scores self.curso.periodo.periodos.each do |periodo|"/>
    <classElements xsi:type="rails:OperationsChain" name="origin_period_value">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>old_topic.get_object_complete_value(self.estudiante.id, periodo.id) destiny_period_value</operants>
      <operants>new_topic.get_object_complete_value(self.estudiante.id, periodo.id) origin_period_value.copy_to(destiny_period_value).save! scores</operants>
      <operants>destiny_period_value.calificacion.get_descendants_and_current.reverse logger.info(&quot;Scores: #{scores.map(&amp;:id).join(',')}&quot;) scores.each do |score|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="value">
      <operators>=</operators>
      <operants>score.get_or_generate_value_by_person_id(self.estudiante.persona_id) origin_period_value.copy_to(value) if score.calificaciones.empty? value.save! else value.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end duplicate_attendances_counter">
      <operators>=</operators>
      <operants>ContadorAsistencia.estudiante_id_equals(self.estudiante.id).materia_id_equals(new_topic.id).periodo_id_equals(periodo.id).first unless old_attendances_counter.blank? or old_attendances_counter[old_topic.id]</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="CrocodocApi">
    <classElements xsi:type="rails:RubyMethod" name="self.get_thumbnail"/>
    <classElements xsi:type="rails:OperationsChain" name="file_png">
      <operators>=</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operants>File.join(RAILS_ROOT, 'tmp', &quot;book_thumb_#{Thread.current.object_id}.png&quot;) command</operants>
      <operants>&quot;curl 'https://crocodoc.com/api/v2/download/thumbnail?token=#{get_api_token}&amp;uuid=#{uuid}&amp;size=#{size}' > #{file_png}&quot; execute_command(command)</operants>
      <operants>true file_png end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.delete"/>
    <classElements xsi:type="rails:OperationsChain" name="command">
      <operators>=</operators>
      <operators>==</operators>
      <operants>&quot;curl 'https://crocodoc.com/api/v2/document/delete' --data 'token=#{get_api_token}&amp;uuid=#{uuid}'&quot; execute_command(command)</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.status"/>
    <classElements xsi:type="rails:OperationsChain" name="command">
      <operators>=</operators>
      <operants>&quot;curl 'https://crocodoc.com/api/v2/document/status?token=#{get_api_token}&amp;uuids=#{uuid}'&quot; execute_command(command)</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Curso" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="INTENSIDAD_HORARIA_AUTOMATICA">
      <operators>=</operators>
      <operators>=</operators>
      <operants>4 SHIFTS</operants>
      <operants>[ ['Unica', 'Unica'],['Ma&#xf1;ana', 'Ma&#xf1;ana'],['Tarde', 'Tarde'],]</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":docente" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":allocation_director" relationType="belongs_to">
      <options key=":foreign_key" value="allocation_director_id"/>
      <options key=":class_name" value="VariableAssignment"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":allocation_institution" relationType="belongs_to">
      <options key=":foreign_key" value="allocation_institution_id"/>
      <options key=":class_name" value="VariableAssignment"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":variable_assignments" relationType="has_many">
      <options key=":foreign_key" value="course_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":super_materias" relationType="has_many">
      <options key=":order" value="super_materias.priority ASC"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":boletines" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":sold_books" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:Relationship" name=":headquarter" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":score_statistic" relationType="has_one">
      <options key=":foreign_key" value="course_id"/>
      <options key=":conditions" value="{:calificacion_id=>nil, :homologacion_id=>nil}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":score_statistics" relationType="has_many">
      <options key=":foreign_key" value="course_id"/>
      <options key=":conditions" value="{:calificacion_id=>nil}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":topic_score_statistics" relationType="has_many">
      <options key=":foreign_key" value="course_id"/>
      <options key=":class_name" value="ScoreStatistic.name"/>
      <options key=":conditions" value="['score_statistics.calificacion_id IS NOT NULL']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":course_students" relationType="has_many">
      <options key=":foreign_key" value="course_id"/>
      <options key=":conditions" value="['course_students.state = ? ','active']"/>
      <options key=":class_name" value="CourseStudent"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":estudiantes" relationType="has_many">
      <options key=":through" value=":course_students"/>
      <options key=":class_name" value="Estudiante"/>
      <options key=":conditions" value="['(estudiantes.estado = ? or course_students.approved IS NOT NULL )and estudiantes.activo = ?' ,'active', true]"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":historico_estudiantes" relationType="has_many">
      <options key=":through" value=":course_students"/>
      <options key=":class_name" value="Estudiante"/>
      <options key=":source" value="estudiante"/>
      <options key=":conditions" value="['estudiantes.activo = ?', true]"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":approved_course_students" relationType="has_many">
      <options key=":foreign_key" value="course_id"/>
      <options key=":conditions" value="{:approved=>true, :state=>'active'}"/>
      <options key=":before_add" value=":set_approved"/>
      <options key=":class_name" value="CourseStudent"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":reproved_course_students" relationType="has_many">
      <options key=":foreign_key" value="course_id"/>
      <options key=":conditions" value="{:approved=>false, :state=>'active'}"/>
      <options key=":before_add" value=":set_reproved"/>
      <options key=":class_name" value="CourseStudent"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="before_validation_on_create :set_course_type"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :asignatura_id, :render_template_id, :render_academic_years_id, :render_academic_period_id, :generate_topics,:add_evaluation_plans,:add_report_card_fields"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :promotion_course_id, :if => :promotion_period_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :grade_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :grade_id, :only_integer => true , :if => :grade_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :maximo_estudiantes, :only_integer => true, :greater_than=>">
      <operators>-</operators>
      <operants>1</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Departamento" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegios" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":ciudades" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":pais" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="DirectorProfile" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":director" relationType="belongs_to">
      <options key=":class_name" value="Administrador"/>
      <options key=":foreign_key" value="director_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":categorias" relationType="has_many">
      <options key=":through" value=":survey_permisions"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Docente" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":area" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":contenidos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":boletines" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":teacher_advises" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":performancetests" relationType="has_many">
      <options key=":foreign_key" value="supervisor_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":teacher_performancetests" relationType="has_many">
      <options key=":foreign_key" value="teacher_id"/>
      <options key=":class_name" value="Performancetest"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":subjects" relationType="has_and_belongs_to_many">
      <options key=":join_table" value="supervisors_subjects"/>
      <options key=":class_name" value="Materia"/>
      <options key=":foreign_key" value="subject_id"/>
      <options key=":association_foreign_key" value="supervisor_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :performancetests"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :teacher_performancetests"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_retirement_date_institution"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :persona_id, :if=>:persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :perfil, :maximum => 1024, :if => :perfil"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :retirement_date_institution, :unless => :activo"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school, :set_area"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv, :current_tab, :render_template_id, :render_academic_years_id, :render_academic_period_id, :allocation_director_id"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :with_subject_counter, { :select=>'docentes.*, count(materias.id) as subject_counter',&#xA;    :group=>'docentes.id'}"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_area"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.area_id">
      <operators>==</operators>
      <operators>=</operators>
      <operants>nil self.area_id</operants>
      <operants>13 end end after_save :set_profiles</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.define_profiles end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="true_criteria">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>['VERDADERO', 1, '1', 'TRUE','SI','V','M', 'MASCULINO','T','S'] false_criteria</operants>
      <operants>['FALSO', 0, '0', 'FALSE','NO','F', 'FEMENINO','N'] counter</operants>
      <operants>1 school</operants>
      <operants>Colegio.f(Persona.get_school) default_city</operants>
      <operants>Ciudad.f(10093) school_domain</operants>
      <operants>school.e_mail.split('@').last rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',
      &quot;#{self.to_s}.docentes_csv_#{Time.now.to_i.to_s}.csv&quot;) separator</operants>
      <operants>get_separator(filename)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="File.open(rescue_file_path,'w+') do |rescue_file|"/>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename, :col_sep => separator, :skip_blanks => true, :headers=>true) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin ActiveRecord::Base.transaction do identificacion">
      <operators>=</operators>
      <operants>process_field(row['identificacion'])</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="docente">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Docente.by_current_school.code_equals(process_field(row['codigo'])).first unless docente person</operants>
      <operants>Persona.by_current_school.identificacion_equals(identificacion.gsub(' ','')).last person</operants>
      <operants>docente.person if docente end person</operants>
      <operants>Persona.new() unless person person.attributes</operants>
      <operants>{:identificacion => identificacion,
              :nombre =>process_field(row['nombre1']), :second_nombre => process_field(row['nombre2']),
              :apellido => process_field(row['apellido1']),
              :second_apellido => process_field(row['apellido2']),
              :tipo_documento_id => 1,
              :sexo => true_criteria.include?(process_field(row['sexo']))}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="person.direccion">
      <operators>||=</operators>
      <operants>row['direccion']</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="DocxBuilder" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:RubyMethod" name="initialize"/>
    <classElements xsi:type="rails:OperationsChain" name="@template_filename">
      <operators>=</operators>
      <operators>=</operators>
      <operants>template_filename @template_dirname</operants>
      <operants>template_dirname end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="build"/>
    <classElements xsi:type="rails:OperationsChain" name="template">
      <operators>=</operators>
      <operants>SliceTemplate.new(@template_filename)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="yield template build_docx(template.render)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end private"/>
    <classElements xsi:type="rails:RubyMethod" name="build_docx"/>
    <classElements xsi:type="rails:OperationsChain" name="docx_content">
      <operators>=</operators>
      <operants>nil in_temp_dir do |temp_dir|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="system(&quot;cp -r #{@template_dirname} #{temp_dir}/plan_report&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="open(&quot;#{temp_dir}/plan_report/word/document.xml&quot;, &quot;w&quot;) do |file|"/>
    <classElements xsi:type="rails:OperationsChain" name="file.write(content) end system(&quot;cd #{temp_dir}/plan_report; zip -r ../plan_report.docx *&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="docx_content">
      <operators>=</operators>
      <operants>File.read(&quot;#{temp_dir}/plan_report.docx&quot;) end docx_content end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="in_temp_dir"/>
    <classElements xsi:type="rails:OperationsChain" name="temp_dir">
      <operators>=</operators>
      <operants>&quot;/tmp/docx_#{Time.now.to_f.to_s}&quot; Dir.mkdir(temp_dir) yield(temp_dir)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="system(&quot;rm -Rf #{temp_dir}&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
  </rubyClasses>
  <rubyClasses name="Escala" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":letras" relationType="has_many">
      <options key=":order" value="maximum desc"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":numeros" relationType="has_many">
      <options key=":order" value="homologacion_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :numeros"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :letras"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_numbers_minimums, :on => :update"/>
    <classElements xsi:type="rails:RubyMethod" name="get_homologacion"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.periodo.escala_numerica real_value">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>||=</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operants>valor.is_a?(Valor)</operants>
      <operants>valor.numerical_value</operants>
      <operants>valor @number</operants>
      <operants>self.numeros.descend_by_maximo if digits</operants>
      <operants>1 number</operants>
      <operants>@number.detect{|number|  number.maximo.round(1) >= real_value.to_f.round(1) and number.minimo.round(1) &lt;= real_value.to_f.round(1) }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="return number">
      <operators>?</operators>
      <operators>: </operators>
      <operators>=</operators>
      <operants>number.homologacion</operants>
      <operants>nil else number</operants>
      <operants>@number.detect{|number|  number.maximo >= real_value.to_f and number.minimo &lt;= real_value.to_f }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="return number">
      <operators>?</operators>
      <operators>: </operators>
      <operants>number.homologacion</operants>
      <operants>nil end else if(valor.is_a?(Valor))</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="value">
      <operators>=</operators>
      <operators>||=</operators>
      <operants>valor.numerical_value @letras_ordered</operants>
      <operants>self.letras.all(:include=>:homologacion ).sort{|a,b| b.maximum &lt;=> a.maximum}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if digits">
      <operators>==</operators>
      <operators>=</operators>
      <operants>1 letra</operants>
      <operants>@letras_ordered.detect { |n| n.minimum.round(1) &lt;= value.round(1) and value.round(1) &lt;= n.maximum.round(1) }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="else letra">
      <operators>=</operators>
      <operants>@letras_ordered.detect { |n| n.minimum &lt;= value and value &lt;= n.maximum }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end else real_value">
      <operators>=</operators>
      <operators>=</operators>
      <operants>valor letra</operants>
      <operants>letra_equivalente(real_value)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end return letra">
      <operators>?</operators>
      <operators>: </operators>
      <operants>letra.homologacion</operants>
      <operants>nil end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_numbers_minimums"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.numeros.empty? ordenado">
      <operators>=</operators>
      <operants>self.numeros.sort{|a, b| a.maximo&lt;=>b.maximo}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ordenado[0]"/>
  </rubyClasses>
  <rubyClasses name="Estudiante" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="include Reports::Estudiante attr_accessor :course_temp"/>
    <classElements xsi:type="rails:OperationsChain" name="serialize :situacion_social"/>
    <classElements xsi:type="rails:OperationsChain" name="serialize :academic_history"/>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":service_students" relationType="has_many">
      <options key=":foreign_key" value="student_id"/>
      <options key=":class_name" value="ServiceStudent"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :service_students"/>
    <classElements xsi:type="rails:Relationship" name=":padre" relationType="belongs_to">
      <options key=":class_name" value="Acudiente"/>
      <options key=":foreign_key" value="padre_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :padre, :reject_if => proc { |attrs| attrs.deep_empty? }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :persona_id, :if=>:persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :code, :less_than_or_equal_to => 999999999"/>
    <classElements xsi:type="rails:Relationship" name=":madre" relationType="belongs_to">
      <options key=":class_name" value="Acudiente"/>
      <options key=":foreign_key" value="madre_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :madre, :reject_if => proc { |attrs| attrs.deep_empty? }"/>
    <classElements xsi:type="rails:Relationship" name=":acudiente" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :acudiente, :reject_if => proc { |attrs| attrs.deep_empty? }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :name_string, lambda { |param| param = &quot;%#{param}%&quot; ; {&#xA;      :conditions => [&quot;personas.nombre like ? or personas.apellido like ?\&#xA;      or personas.identificacion like ? or estudiantes.code like ?&quot;, param,param,param, param] ,&#xA;      :joins=> {:persona=>{}}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_course_allocation, lambda { |allocation_id, periodo_id| ; {&#xA;      :select=>&quot;estudiantes.*, courses.id AS course_id,&#xA;        (SELECT resultados.id FROM `resultados`&#xA;          WHERE `resultados`.persona_id = personas.id&#xA;          AND `variable_assignments`.evaluacion_id = `resultados`.evaluacion_id&#xA;          AND  resultados.periodo_id = #{periodo_id} LIMIT 1) as result_id ,&#xA;        (SELECT resultados.finalizado FROM `resultados`&#xA;          WHERE `resultados`.persona_id = personas.id AND `variable_assignments`.evaluacion_id = `resultados`.evaluacion_id AND&#xA;            resultados.periodo_id = #{periodo_id}  LIMIT 1) as state_result &quot;,&#xA;      :joins=> &quot;INNER JOIN `course_students` as curso_estudiantes ON curso_estudiantes.student_id = estudiantes.id \&#xA;      AND curso_estudiantes.`state` = 'active'&#xA;      INNER JOIN `cursos` as courses ON `courses`.id = `curso_estudiantes`.course_id AND courses.`activo` = 1 AND courses.allocation_director_id = #{allocation_id} \&#xA;      INNER JOIN `personas` ON `estudiantes`.persona_id = `personas`.id \&#xA;      INNER JOIN `variable_assignments` ON `variable_assignments`.id = courses.allocation_director_id &quot;&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_course_institution_allocation, lambda { |allocation_id, periodo_id| ; {&#xA;      :select=>&quot;estudiantes.*, courses.id AS course_id,&#xA;        (SELECT resultados.id FROM `resultados`&#xA;          WHERE `resultados`.persona_id = personas.id&#xA;          AND `variable_assignments`.evaluacion_id = `resultados`.evaluacion_id&#xA;          AND resultados.periodo_id = #{periodo_id} LIMIT 1) as result_id,&#xA;        (SELECT resultados.finalizado FROM `resultados` WHERE `resultados`.persona_id = personas.id AND `variable_assignments`.evaluacion_id = `resultados`.evaluacion_id AND resultados.periodo_id = #{periodo_id}  LIMIT 1) as state_result &quot;,&#xA;      :joins=> &quot;INNER JOIN `course_students` ON course_students.student_id = estudiantes.id \&#xA;      AND course_students.`state` = 'active'&#xA;      INNER JOIN `cursos` as courses ON `courses`.id = `course_students`.course_id AND courses.`activo` = 1 AND courses.allocation_institution_id = #{allocation_id} \&#xA;      INNER JOIN `personas` ON `estudiantes`.persona_id = `personas`.id \&#xA;      INNER JOIN `variable_assignments` ON `variable_assignments`.id = courses.allocation_institution_id &quot;&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_course_allocation_grade, lambda { |grade_id| ; {&#xA;      :conditions=>[&quot;courses.grade_id = ?&quot;, grade_id],&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_periodo_resultado, lambda{ |periodo_id| ; {&#xA;#      :conditions=>[&quot;resultados.periodo_id = ?&quot;, periodo_id],&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_period_course, lambda{|period_id| ; {&#xA;      :conditions=>[&quot;courses.periodo_id = ?&quot;, period_id],&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_student_person_parameters, lambda { |param|&#xA;    param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xA;    if param.count == 1&#xA;      param =  param*3&#xA;      sql = '(personas.full_name Like ?) OR (personas.identificacion Like ? ) OR (estudiantes.code Like ? )'&#xA;    else&#xA;      sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xA;    end&#xA;    param.insert(0,sql)&#xA;    {&#xA;      :conditions => param ,&#xA;      :joins=> {}} }"/>
    <classElements xsi:type="rails:Relationship" name=":asistencias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":facturas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":contador_asistencias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":student_logs" relationType="has_many">
      <options key=":through" value=":persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":sign_up" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":course_students" relationType="has_many">
      <options key=":foreign_key" value="student_id"/>
      <options key=":conditions" value="['course_students.state = ?','active']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_many">
      <options key=":through" value=":course_students"/>
      <options key=":class_name" value="Curso"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":active_courses" relationType="has_many">
      <options key=":through" value=":course_students"/>
      <options key=":class_name" value="Curso"/>
      <options key=":source" value="curso"/>
      <options key=":conditions" value="['(estudiantes.estado = ? or course_students.approved IS NOT NULL ) and estudiantes.activo = ?' ,'active', true]"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":current_course_student" relationType="has_one">
      <options key=":foreign_key" value="student_id"/>
      <options key=":class_name" value="CourseStudent"/>
      <options key=":conditions" value="{:state=>'active',&#xA;    :current_sign_up=>true}"/>
      <options key=":validate" value="true"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":attendances" relationType="has_many">
      <options key=":foreign_key" value="student_id"/>
      <options key=":class_name" value="Attendance"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :code, :message => I18n.t(&quot;type_code_student&quot;) validates_presence_of :grade_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :code, :message => I18n.t(&quot;code_already_exists&quot;), :scope => [:colegio_id, :activo], :if => :activo"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :code, :only_integer=> true, :if => :code"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation_on_create :set_student_code"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_parents, lambda { |param| {&#xA;      :conditions => [&quot;estudiantes.acudiente_id = ? or estudiantes.madre_id = ?\&#xA;      or estudiantes.padre_id = ?&quot;, param,param,param] } }"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_empty_fields"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :create_graduate"/>
    <classElements xsi:type="rails:RubyMethod" name="score_report_serial_number"/>
    <classElements xsi:type="rails:OperationsChain" name="course">
      <operators>=</operators>
      <operators>||</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operants>self.course_temp</operants>
      <operants>self.get_course_by_period(academic_year_id) if course serial</operants>
      <operants>course.score_reports_serial_number</operants>
      <operants>course.estudiantes.index(self)</operants>
      <operants>1 else serial</operants>
      <operants>&quot;&quot; end serial end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="nombre_completo"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.persona self.persona.nombre_completo end end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_student_code"/>
    <classElements xsi:type="rails:OperationsChain" name="grado">
      <operators>=</operators>
      <operators>||=</operators>
      <operants>Grade.by_current_school.last self.grade_id</operants>
      <operants>grado.id end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="create_graduate"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.define_profiles if self.estado">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operants>'graduate'</operants>
      <operants>self.persona.graduate.nil? self.persona.create_graduate(:person_id=>self.persona_id, :graduate=>true,
        :degree_year => Date.current.year) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.hallar"/>
    <classElements xsi:type="rails:OperationsChain" name="grado">
      <operators>=</operators>
      <operants>Grade.school_id_equals(colegio_id).level_equals(grado_actual).first raise &quot;No se encontro grado actual #{grado_actual}para colegio actual #{colegio_id}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="condiciones">
      <operators>=</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operators>+=</operators>
      <operators>!=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>&quot;estudiantes.colegio_id=#{colegio_id} &quot;</operants>
      <operants>&quot; AND estudiantes.activo = 1 AND personas.activo = 1 &quot;</operants>
      <operants>&quot; AND estudiantes.grade_id=#{grado.id}&quot; condiciones</operants>
      <operants>curso_id</operants>
      <operants>nil</operants>
      <operants>&quot; OR cursos.id = #{curso_id}&quot;</operants>
      <operants>&quot;&quot; Estudiante.find(:all, :include => [:persona, :cursos],
      :conditions => condiciones,
      :order => &quot;personas.nombre asc&quot;) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="curso_actual"/>
    <classElements xsi:type="rails:OperationsChain" name="self.current_course_student.curso if self.current_course_student end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_director_curso_actual"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.current_course_student self.current_course_student.curso.docente.persona.to_s end end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.estratos"/>
    <classElements xsi:type="rails:OperationsChain" name="[['1', 1], ['2', 2], ['3', 3], ['4', 4], ['5', 5], ['6', 6]] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.tipo_rh"/>
    <classElements xsi:type="rails:OperationsChain" name="[['A negativo', 3],&#xA;      ['A positivo', 4],&#xA;      ['AB negativo', 7],&#xA;      ['AB positivo', 8],&#xA;      ['B negativo', 5],&#xA;      ['B positivo', 6],&#xA;      ['O negativo', 1],&#xA;      ['O positivo', 2]] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.estado_civil"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Seleccione una opci&#xf3;n', nil],&#xA;      ['Soltero/a'],&#xA;      ['Casado/a'],&#xA;      ['Divorciado/a'],&#xA;      ['Viudo/a'],&#xA;      ['Uni&#xf3;n libre']] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.grupo_etnico"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Ind&#xed;gena'],&#xA;      ['Negritudes'],&#xA;      ['Gitanos']] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>[&quot;suscribed&quot;, &quot;active&quot;, &quot;graduate&quot;, &quot;dropout&quot;, &quot;retired&quot;, &quot;suspended&quot;, &quot;deserted&quot;, &quot;unadmitted&quot;].freeze end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.situacion_social"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Desplazado'],&#xA;      ['Hijo de desmovilizado']] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.discapacidad"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Auditiva'],&#xA;      ['Visual'],&#xA;      ['Motora'],&#xA;      ['Cognitiva'],&#xA;      ['Autismo'],&#xA;      ['Multiple'],&#xA;      ['Otra']] end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.exceptional_ability"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Superdotado', 1],&#xA;      ['Con talento cient&#xed;fico', 2],&#xA;      ['Con talento tecnol&#xf3;gico', 3],&#xA;      ['Con talento subjectivo', 4],&#xA;      ['No aplica', 9]] end"/>
    <classElements xsi:type="rails:RubyMethod" name="rh"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.rh end"/>
    <classElements xsi:type="rails:RubyMethod" name="fecha_retiro"/>
    <classElements xsi:type="rails:OperationsChain" name="StudentLog.persona_id_equals(self.persona_id).state_equals(&quot;retired&quot;).last end"/>
    <classElements xsi:type="rails:RubyMethod" name="situacion_social"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.social_situation end"/>
    <classElements xsi:type="rails:RubyMethod" name="ips"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.ips end"/>
    <classElements xsi:type="rails:RubyMethod" name="puntaje_sisben"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.puntaje_sisben end"/>
    <classElements xsi:type="rails:RubyMethod" name="carnet_sisben"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.carnet_sisben end"/>
    <classElements xsi:type="rails:RubyMethod" name="subscription_date_sisben_card"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.subscription_date_sisben_card end"/>
    <classElements xsi:type="rails:RubyMethod" name="rh="/>
    <classElements xsi:type="rails:OperationsChain" name="value self.build_persona unless self.persona self.persona.rh">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="situacion_social="/>
    <classElements xsi:type="rails:OperationsChain" name="value self.build_persona unless self.persona self.persona.social_situation">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="ips="/>
    <classElements xsi:type="rails:OperationsChain" name="value self.build_persona unless self.persona self.persona.ips">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="puntaje_sisben="/>
    <classElements xsi:type="rails:OperationsChain" name="value self.build_persona unless self.persona self.persona.puntaje_sisben">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="carnet_sisben="/>
    <classElements xsi:type="rails:OperationsChain" name="value self.build_persona unless self.persona self.persona.carnet_sisben">
      <operators>=</operators>
      <operants>value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="performance_subject"/>
    <classElements xsi:type="rails:OperationsChain" name="calificacion">
      <operators>=</operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>Calificacion.find(:first, :conditions => {:periodo_id => periodo_id, :programa_id => programa_id}) unless excel tem_calificacion</operants>
      <operants>calificacion.performance_person(self.persona, escala_numerica) if calificacion calificacion</operants>
      <operants>(tem_calificacion ? tem_calificacion : (escala_numerica ? 0.0 : &quot;&quot;))</operants>
      <operants>(escala_numerica ? 0.0 : &quot;&quot;) else tem_calificacion</operants>
      <operants>calificacion.performance_person(self.persona, escala_numerica, excel) if calificacion calificacion</operants>
      <operants>(tem_calificacion ? tem_calificacion : (escala_numerica ? 0.0 : &quot;&quot;))</operants>
      <operants>(escala_numerica ? 0.0 : &quot;&quot;) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_date_change_state"/>
    <classElements xsi:type="rails:OperationsChain" name="estado">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.student_logs.sugestions_begins_with(&quot;El estado del estudiante cambi&#xf3; de&quot;).state_equals(self.estado).last estado</operants>
      <operants>I18n.l(estado.date_occurrence, :format=>:bta_fecha) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_value_from_calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="calificacion">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Calificacion.find(:first, :conditions => {:periodo_id => periodo_id, :programa_id=> programa_id}) if calificacion cali_temporal</operants>
      <operants>calificacion.get_or_generate_value_by_person_id(self.persona.id) if cali_temporal return cali_temporal else nil end else nil end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.grade_id">
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.grade_id_was and self.current_course_student and self.current_course_student.curso self.grade_id</operants>
      <operants>self.current_course_student.curso.grade_id end self.updated_by</operants>
      <operants>GestorUsuario.obtener_usuario @state_changed</operants>
      <operants>true if self.changes['activo']</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="or self.changes['estado']"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.persona.usuario usuario">
      <operators>=</operators>
      <operators>==</operators>
      <operants>self.persona.usuario unless usuario.nombre</operants>
      <operants>self.persona.e_mail usuario.update_attributes({:nombre => self.persona.e_mail,
            :password =>self.persona.identificacion,
            :password_confirmation=> self.persona.identificacion}) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_save"/>
    <classElements xsi:type="rails:OperationsChain" name="if @state_changed Curso.by_current_school.id_equals(self.cursos.periodo_fecha_inicio_lte(DateTime.now).&#xA;          periodo_fecha_fin_gte(DateTime.now).all(:select=>'cursos.id').map(&amp;:id)).each do |course|"/>
    <classElements xsi:type="rails:OperationsChain" name="course.save(false) rescue logger.exc end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.activo">
      <operators>=</operators>
      <operants>false self.save! end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_subject_auditory"/>
    <classElements xsi:type="rails:OperationsChain" name="self.create_topics_auditory_hash(materias) end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_exceptional_ability"/>
    <classElements xsi:type="rails:OperationsChain" name="ability">
      <operators>=</operators>
      <operants>Estudiante::exceptional_ability.detect {|e| e[1] == self.exceptional_ability}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ability">
      <operators>?</operators>
      <operators>: </operators>
      <operants>ability[0]</operants>
      <operants>Estudiante::exceptional_ability.last[0]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_courses"/>
    <classElements xsi:type="rails:OperationsChain" name="(self.curso_ids &amp; course_ids).map{|id| Curso.find(id)}"/>
  </rubyClasses>
  <rubyClasses name="Evaluacion" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="GENERO_MIXTO">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 GENERO_FEMENINO</operants>
      <operants>2 GENERO_MASCULINO</operants>
      <operants>3 PSICOLOGY_EVALUATION</operants>
      <operants>&quot;questionnaire&quot; self.partial_updates</operants>
      <operants>false</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":preguntas" relationType="has_many">
      <options key=":order" value=":orden"/>
      <options key=":conditions" value="{:active => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":rangos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":categorias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":allocations" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":resultados" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":presentados" relationType="has_many">
      <options key=":through" value=":resultados"/>
      <options key=":source" value=":persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":asignaciones" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_many">
      <options key=":through" value=":asignaciones"/>
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":pending_notification" relationType="has_one">
      <options key=":dependent" value=":destroy"/>
      <options key=":foreign_key" value="test_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":evaluation_event" relationType="has_one">
      <options key=":foreign_key" value="evaluation_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":event" relationType="has_one">
      <options key=":through" value=":evaluation_event"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":book_marks" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":sign_up_tests" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":resultado" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":original" relationType="belongs_to">
      <options key=":foreign_key" value="original_id"/>
      <options key=":class_name" value="Evaluacion"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":copies" relationType="has_many">
      <options key=":foreign_key" value="original_id"/>
      <options key=":class_name" value="Evaluacion"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :asignaciones"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :fechas_validas"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :fechas_periodos"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name, :message => I18n.t(&quot;El nombre no debe estar en blanco&quot;) validates_length_of :name, :within =>">
      <operators>..</operators>
      <operants>300 validate :validate_assigment</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_assigment"/>
    <classElements xsi:type="rails:OperationsChain" name="if (!self.calificacion.blank?)"/>
    <classElements xsi:type="rails:OperationsChain" name="if (!self.calificacion.tarea.blank? )"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:calificacion_id, I18n.t(:validate_score_assignment)) end if(self.calificacion.evaluacion and self.calificacion.evaluacion!= self)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:calificacion_id, I18n.t(:overwrited_evaluation)) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_interpretacion"/>
    <classElements xsi:type="rails:OperationsChain" name="rango">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>(self.rangos.select{|r| (r.categoria_id == categoria_id) and
          ((r.inicio &lt; value)or ((r.inicio == value) and (r.inicio == 0))) and
          (value &lt;= r.fin) }).at(0) rango</operants>
      <operants>rango.interpretacion</operants>
      <operants>&quot;&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="Resultados"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Evaluacion.get_school() self.created_by</operants>
      <operants>GestorUsuario.obtener_usuario self.active</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="corresponde_genero"/>
    <classElements xsi:type="rails:OperationsChain" name="((self.genero == GENERO_MIXTO) or&#xA;        ((self.genero == GENERO_FEMENINO) and genero) or&#xA;        ((self.genero == GENERO_MASCULINO) and !genero)) end"/>
    <classElements xsi:type="rails:RubyMethod" name="fechas_validas"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.ending_date.blank? and self.fecha_publicacion.blank? self.errors.add(:ending_date, I18n.t(:fecha_inicio_fin)) unless self.ending_date">
      <operators>></operators>
      <operants>self.fecha_publicacion end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.materia begin evaluation_event">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>EvaluationEvent.new(:evaluation => self) event</operants>
      <operants>Evento.create!(:name => self.name,
          :descripcion => self.objetives,
          :start_at => self.fecha_publicacion,
          :end_at => self.ending_date,
          :materia_id => self.materia.id,
          :all_day => false, :evaluation_event => evaluation_event) evaluation_event.event</operants>
      <operants>event evaluation_event.save! rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.calificacion.destroy if self.calificacion for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.materia">
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.active</operants>
      <operants>true begin unless self.event evaluation_event</operants>
      <operants>EvaluationEvent.new(:evaluation => self) event</operants>
      <operants>Evento.create!(:name => self.name,
            :descripcion => self.objetives,
            :start_at => self.fecha_publicacion,
            :end_at => self.ending_date,
            :materia_id => self.materia.id,
            :all_day => false, :evaluation_event => evaluation_event) evaluation_event.event</operants>
      <operants>event evaluation_event.save! else event</operants>
      <operants>self.event event.update_attributes({:name => self.name,
              :descripcion => self.objetives,
              :start_at => self.fecha_publicacion,
              :end_at => self.ending_date,
              :materia_id => self.materia.id,
              :all_day => false}) end rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="fechas_periodos"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.calificacion.nil? periodo">
      <operators>=</operators>
      <operants>self.calificacion.get_period unless periodo.nil? if (self.fecha_publicacion>=periodo.fecha_inicio)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if (self.ending_date&lt;periodo.fecha_fin)"/>
    <classElements xsi:type="rails:OperationsChain" name="else self.errors.add(:ending_date, I18n.t(:evaluation_end_date)) end else self.errors.add(:fecha_publicacion, I18n.t(:evaluation_start_date)) end end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="transaction do Resultado.evaluacion_id_eq(self.id).update_all(:activo=> false) self.categorias.each(&amp;:destroy) self.preguntas.each(&amp;:destroy) self.active">
      <operators>=</operators>
      <operants>false self.evaluation_event.destroy if self.evaluation_event return self.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="presentada"/>
    <classElements xsi:type="rails:OperationsChain" name="resultados">
      <operators>=</operators>
      <operants>self.resultados.select {|r| r.persona_id == persona_id and r.activo == true }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="return resultados.at(0) end"/>
    <classElements xsi:type="rails:RubyMethod" name="disponible"/>
    <classElements xsi:type="rails:OperationsChain" name="p">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.fecha_publicacion l</operants>
      <operants>self.ending_date t</operants>
      <operants>Time.now (p &lt;= t and t &lt;= l)</operants>
      <operants>true</operants>
      <operants>false end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="deep_clone"/>
    <classElements xsi:type="rails:OperationsChain" name="clone">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.clone clone.preguntas</operants>
      <operants>self.preguntas.map(&amp;:deep_clone) clone end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="deep_clone_test_teacher"/>
    <classElements xsi:type="rails:OperationsChain" name="clone">
      <operators>=</operators>
      <operants>self.clone clone end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.name end end"/>
  </rubyClasses>
  <rubyClasses name="EvaluationEvent" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":evaluation" relationType="belongs_to">
      <options key=":class_name" value="Evaluacion"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":event" relationType="belongs_to">
      <options key=":class_name" value="Evento"/>
      <options key=":dependent" value=":destroy"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="EvaluationPlan" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":nodes" relationType="has_many">
      <options key=":dependent" value=":destroy"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":area" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":super_asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :grade_id, :scope => [:area_id, :super_asignatura_id, :asignatura_id, :school_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :area_id, :scope => [:grade_id, :super_asignatura_id, :asignatura_id, :school_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :super_asignatura_id, :scope => [:area_id, :grade_id, :asignatura_id, :school_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :asignatura_id, :scope => [:area_id, :super_asignatura_id, :grade_id, :school_id]"/>
    <classElements xsi:type="rails:RubyMethod" name="apply_to"/>
    <classElements xsi:type="rails:OperationsChain" name="apply">
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>!</operators>
      <operants>[] apply</operants>
      <operants>Grade.f(self.grade_id).name if</operants>
      <operants>self.grade_id.blank? and</operants>
      <operants>Grade.id_equals(self.grade_id).blank? apply</operants>
      <operants>Area.f(self.area_id).nombre if</operants>
      <operants>self.area_id.blank? and</operants>
      <operants>Area.id_equals(self.area_id).blank? apply</operants>
      <operants>SuperAsignatura.f(self.super_asignatura_id).nombre if</operants>
      <operants>self.super_asignatura_id.blank? and</operants>
      <operants>SuperAsignatura.id_equals(self.super_asignatura_id).blank? apply</operants>
      <operants>Asignatura.f(self.asignatura_id).nombre if</operants>
      <operants>self.asignatura_id.blank? and</operants>
      <operants>Asignatura.id_equals(self.asignatura_id).blank? apply.to_sentence(:words_connector => ', ',:last_word_connector => ' y ') end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.available_evaluation_plans_for"/>
    <classElements xsi:type="rails:OperationsChain" name="evaluation_plans">
      <operators>=</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operants>[] school_eps</operants>
      <operants>EvaluationPlan.school_id_equals(materia.colegio_id) evaluation_plans</operants>
      <operants>school_eps.asignatura_id_equals(materia.asignatura_id) if</operants>
      <operants>school_eps.asignatura_id_equals(materia.asignatura_id).blank? evaluation_plans</operants>
      <operants>(school_eps.super_asignatura_id_equals(SuperAsignatura.asignaturas_id_in([materia.asignatura_id]).last.id).asignatura_id_null.area_id_null.grade_id_null - evaluation_plans) if</operants>
      <operants>SuperAsignatura.asignaturas_id_in([materia.asignatura_id]).blank? and</operants>
      <operants>school_eps.super_asignatura_id_equals(SuperAsignatura.asignaturas_id_in([materia.asignatura_id])).blank? evaluation_plans</operants>
      <operants>(school_eps.grade_id_equals(materia.curso.grade_id).area_id_equals(materia.asignatura.area_id).asignatura_id_null.super_asignatura_id_null - evaluation_plans) if (!school_eps.grade_id_equals(materia.curso.grade_id).blank? and !school_eps.area_id_equals(materia.asignatura.area_id).blank?)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="evaluation_plans">
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operators>!</operators>
      <operators>&lt;&lt;</operators>
      <operants>(school_eps.grade_id_equals(materia.curso.grade_id).asignatura_id_null.super_asignatura_id_null.area_id_null - evaluation_plans) if</operants>
      <operants>school_eps.grade_id_equals(materia.curso.grade_id).blank? evaluation_plans</operants>
      <operants>(school_eps.area_id_equals(materia.asignatura.area_id).asignatura_id_null.super_asignatura_id_null.grade_id_null - evaluation_plans) if</operants>
      <operants>school_eps.area_id_equals(materia.asignatura.area_id).blank? evaluation_plans</operants>
      <operants>(school_eps.asignatura_id_equals(nil).super_asignatura_id_equals(nil).grade_id_equals(nil).area_id_equals(nil) - evaluation_plans) evaluation_plans.flatten end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Evento" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="has_event_calendar"/>
    <classElements xsi:type="rails:Relationship" name=":asignacion" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":tarea" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":evaluation_event" relationType="has_one">
      <options key=":foreign_key" value="event_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":pending_notification" relationType="has_one">
      <options key=":dependent" value=":destroy"/>
      <options key=":foreign_key" value="event_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :materia_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :descripcion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :descripcion, :minimum => 4, :allow_blank => false validate :validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :scheduled_between, lambda { |star_date, end_date|&#xA;    {&#xA;      :conditions => [&quot;(start_at &lt;= ? and start_at >=  ? ) or (end_at &lt;= ? and end_at >= ?)&quot;,&#xA;        end_date, star_date, end_date, star_date]&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if(self.tarea)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.create_pending_notification(:kind=>'homework', :homework=>self.tarea, :topic=>self.materia) elsif(self.evaluation_event)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.create_pending_notification(:kind=>'test', :topic=>self.materia) else self.create_pending_notification(:kind=>'event', :topic=>self.materia) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.end_at">
      <operators>>=</operators>
      <operants>self.start_at self.errors.add(:end_at,I18n.t(&quot;bta la fecha inicial no se puede ser mayor que la fecha final&quot;)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_colegio end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_enunciados"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.tarea self.tarea.enunciado elsif self.asignacion self.asignacion.evaluacion.objetives else ''"/>
    <classElements xsi:type="rails:OperationsChain" name="end end end"/>
  </rubyClasses>
  <rubyClasses name="Factura" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":cobro" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":estudiante" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="ESTADOS">
      <operators>=</operators>
      <operants>{0 => {:imagen =>  &quot;page_white_star.png&quot;, :label => I18n.t(:invoice_new), :text => I18n.t(:invoice_new_explanation) },
    1 => {:imagen =>  &quot;page_white_error.png&quot;, :label => I18n.t(:invoice_expired), :text => I18n.t(:invoice_expired_explanation) },
    2 => {:imagen =>  &quot;page_error.png&quot;, :label => I18n.t(:invoice_cut), :text => I18n.t(:invoice_cut_explanation) },
    3 => {:imagen =>  &quot;correct.png&quot;, :label => I18n.t(:invoice_paid), :text => I18n.t(:invoice_paid_explanation) },
    4 => {:imagen =>  &quot;anular.gif&quot;, :label => I18n.t(:invoice_void), :text => I18n.t(:invoice_void_explanation) },
    5=>{:imagen =>  &quot;accept.png&quot;, :label => I18n.t(:pay_accepted), :text => I18n.t(:pay_accepted_description) }
  }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="GENERADA">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>0 VENCIDA</operants>
      <operants>1 CORTADA</operants>
      <operants>2 PAGADA</operants>
      <operants>3 ANULADA</operants>
      <operants>4 CONFIRMADA</operants>
      <operants>5</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.estados"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Generada', 0],&#xA;      ['Vencida', 1],&#xA;      ['Cortada', 2],&#xA;      ['Pagada', 3],&#xA;      ['Anulada', 4],&#xA;      ['Confirmada', 5]&#xA;    ] end"/>
    <classElements xsi:type="rails:Relationship" name=":items" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :valor_total"/>
    <classElements xsi:type="rails:RubyMethod" name="calcular_total"/>
    <classElements xsi:type="rails:OperationsChain" name="self.valor_total">
      <operators>=</operators>
      <operants>self.cobro.conceptos.grado_equals(self.grado). inject(0){|suma, concepto| suma+=concepto.valor; suma}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.estado</operants>
      <operants>Factura::GENERADA self.colegio_id</operants>
      <operants>Thread.current[:colegio_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="calcular_total end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create conceptos">
      <operators>=</operators>
      <operants>self.cobro.conceptos.active_equals(true).grado_equals(self.grado).all(:select=>'id, valor'). inject([]){|array,concepto| array&lt;&lt;{:concepto=>concepto}; array}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.items.create(conceptos) self.calcular_total end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.calcular_total end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active">
      <operators>=</operators>
      <operants>false self.save end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="periodo_cobro"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.cobro.fecha_inicio.strftime(&quot;%d-%b-%Y&quot;)} al  #{self.cobro.fecha_final.strftime(&quot;%d-%b-%Y&quot;)}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="GestorUsuario">
    <classElements xsi:type="rails:RubyMethod" name="self.obtener_usuario"/>
    <classElements xsi:type="rails:OperationsChain" name="Thread.current['usuario']"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_user_id"/>
    <classElements xsi:type="rails:OperationsChain" name="Thread.current['usuario']"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="self.obtener_colegio end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.obtener_colegio"/>
    <classElements xsi:type="rails:OperationsChain" name="Thread.current[:colegio]"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_person_id"/>
    <classElements xsi:type="rails:OperationsChain" name="Thread.current[:person_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.obtener_offset"/>
    <classElements xsi:type="rails:OperationsChain" name="0 end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.disponible"/>
    <classElements xsi:type="rails:OperationsChain" name="t">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>Time.now (fecha_publicacion &lt;= t and t &lt;= ending_date)</operants>
      <operants>true</operants>
      <operants>false end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Grade" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":section" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":estudiantes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":conceptos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":informes" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":asignaturas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":allocations" relationType="has_many">
      <options key=":class_name" value="VariableAssigment"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":translation" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":super_asignaturas" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()}, :order => 'level'} }"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.name end end"/>
  </rubyClasses>
  <rubyClasses name="Graduate" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":person" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :person"/>
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":resultado" relationType="belongs_to">
      <options key=":foreign_key" value="answer_id"/>
      <options key=":class_name" value="Resultado"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":binaries" relationType="has_and_belongs_to_many">
      <options key=":class_name" value="Binario"/>
      <options key=":join_table" value="binaries_graduates"/>
      <options key=":association_foreign_key" value="binary_id"/>
      <options key=":conditions" value="{:state => Binario::ESTADO_ACTIVO}"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :code, :if=> :code, :scope => :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :state"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school, :on => :create"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :set_survey"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :person_id, :scope => :active, :if => :active"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :person_id, :if=>:id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate_max_length :more_information, :maximum => 1024"/>
    <classElements xsi:type="rails:OperationsChain" name="validate_max_length [:physical_info_code, :education_level,&#xA;    :degrees, :postgraduate_courses, :ocupation, :office, :company, :company_address,&#xA;    :mail_address, :more_information], :maximum => 256"/>
    <classElements xsi:type="rails:OperationsChain" name="NAME_INVERSE_VALIDATOR">
      <operators>=</operators>
      <operants>/[^A-Z a-z 0-9 @ &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;\-\.\/']*/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="E_MAIL_VALIDATOR">
      <operators>=</operators>
      <operants>/^[A-Z0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}$/i</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="persona"/>
    <classElements xsi:type="rails:OperationsChain" name="self.person end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end named_scope :by_full_name, lambda { |param|&#xA;    param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xA;    if param.count == 1&#xA;      param =  param*5&#xA;      sql = '(personas.full_name Like ?) OR (personas.identificacion Like ? ) OR (personas.e_mail Like ? ) OR (graduates.code Like ? ) OR (graduates.nickname like ? )'&#xA;    else&#xA;      sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xA;    end&#xA;    param.insert(0,sql)&#xA;    {&#xA;      :conditions => param ,&#xA;      :joins=> {}} }"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_survey"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.answer_id if self.school.sign_up_tests.find_by_test_type('graduate') result">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Resultado.new result.colegio_id</operants>
      <operants>self.get_school result.evaluacion_id</operants>
      <operants>self.school.sign_up_tests. find_by_test_type('graduate').evaluacion_id result.persona_id</operants>
      <operants>self.person_id result.save self.answer_id</operants>
      <operants>result.id end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_answer"/>
    <classElements xsi:type="rails:OperationsChain" name="answer">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.resultado.respuestas.pregunta_id_equals(pregunta_id).first answer</operants>
      <operants>answer.get_text.to_s</operants>
      <operants>&quot;&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.mail_address_options"/>
    <classElements xsi:type="rails:OperationsChain" name="@@mail_address_options">
      <operators>||=</operators>
      <operants>['home', 'work'] end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="mail_address"/>
    <classElements xsi:type="rails:OperationsChain" name="self.attributes['mail_address']">
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.attributes['mail_address']</operants>
      <operants>'home' end named_scope :by_current_school, lambda { {
      :conditions => {:school_id => self.get_school(), :active=> true}} }</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_donor"/>
    <classElements xsi:type="rails:OperationsChain" name="self.donor">
      <operators>?</operators>
      <operators>: </operators>
      <operants>t(:afirmation)</operants>
      <operants>t(:negation)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_education_level"/>
    <classElements xsi:type="rails:OperationsChain" name="t(&quot;education_levels&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="[self.education_level] end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_mail_address"/>
    <classElements xsi:type="rails:OperationsChain" name="Graduate.mail_address_options.include?(self.mail_address)">
      <operators>?</operators>
      <operators>: </operators>
      <operants>t(self.mail_address)</operants>
      <operants>self.mail_address end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active">
      <operators>=</operators>
      <operants>false self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 old_person</operants>
      <operants>nil default_city</operants>
      <operants>Ciudad.f(10093) school</operants>
      <operants>Colegio.f(Persona.get_school) school_domain</operants>
      <operants>school.e_mail.split('@').last true_criteria</operants>
      <operants>['VERDADERO', 1, '1', 'TRUE','SI','V','M', 'MASCULINO','T','S', 'S&#xcd;', 'S&#xed;', 'si','Si','s&#xed;'] false_criteria</operants>
      <operants>['FALSO', 0, '0', 'FALSE','NO','F', 'FEMENINO','N'] rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',&quot;#{self.to_s}.graduates_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin ActiveRecord::Base.transaction do identificacion">
      <operators>=</operators>
      <operants>process_field(row[6])</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Headquarter" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :address"/>
    <classElements xsi:type="rails:OperationsChain" name="PHONE_VALIDATOR">
      <operators>=</operators>
      <operants>/^[0-9\- \/ext EXT fax FAX:()\.\+]*\z/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :phone, :mobile_phone, :with => PHONE_VALIDATOR validates_format_of :address, :with => /^[A-Z a-z 0-9 \/&#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;&#xb0; #\-\.(),]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="E_MAIL_VALIDATOR">
      <operators>=</operators>
      <operants>/^[A-Z0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}$/i</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to">
      <options key=":foreign_key" value="school_id"/>
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":administrador" relationType="belongs_to">
      <options key=":class_name" value="Administrador"/>
      <options key=":foreign_key" value="administrator_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :administrador"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="name end end"/>
  </rubyClasses>
  <rubyClasses name="HealthHistory" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to">
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":sick_illness" relationType="belongs_to">
      <options key=":foreign_key" value="sick_illness_id"/>
      <options key=":class_name" value="SickIllness"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :person_id, :if=>:id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :sick_illness_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :sick_illness_id, :scope => :person_id"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Homologacion" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":letras" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":numero" relationType="has_one"/>
    <classElements xsi:type="rails:OperationsChain" name="SUPERIOR">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 ALTO</operants>
      <operants>2 BASICO</operants>
      <operants>3 BAJO</operants>
      <operants>4</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="return self.texto end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Horario" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":asistencias" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :hora_inicio"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :hora_fin"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :dia"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :orden_cronologico"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_self_time_overlapping"/>
    <classElements xsi:type="rails:OperationsChain" name="self_final">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Time.parse(&quot;#{self.hora_fin.hour}:#{self.hora_fin.min}&quot;) self_inicio</operants>
      <operants>Time.parse(&quot;#{self.hora_inicio.hour}:#{self.hora_inicio.min}&quot;) horario_final</operants>
      <operants>Time.parse(&quot;#{horario.hora_fin.hour}:#{horario.hora_fin.min}&quot;) horario_inicio</operants>
      <operants>Time.parse(&quot;#{horario.hora_inicio.hour}:#{horario.hora_inicio.min}&quot;) if ((self_final &lt;= horario_inicio) or (self_inicio >= horario_final))</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="or horario.dia">
      <operators>!=</operators>
      <operants>self.dia return true else return false end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.hallar_por_curso"/>
    <classElements xsi:type="rails:OperationsChain" name="self.find(:all, :include=>[:materia],&#xA;      :conditions => &quot; materias.curso_id = #{curso_id}&quot; +&#xA;        &quot; AND materias.colegio_id = #{GestorUsuario.obtener_colegio}&quot;,&#xA;      :order => &quot;horarios.hora_inicio&quot;) end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.dias"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Lunes', 0],&#xA;      ['Martes', 1],&#xA;      ['Miercoles', 2],&#xA;      ['Jueves', 3],&#xA;      ['Viernes', 4],&#xA;      ['Sabado', 5],&#xA;      ['Domingo', 6]] end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{Horario.dias[self.dia][0]} #{I18n.l(self.hora_inicio, :format=>:bta_hora)} - #{I18n.l(self.hora_fin, :format=>:bta_hora)} &quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="horas"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{I18n.l(self.hora_inicio, :format=>:bta_hora)} - #{I18n.l(self.hora_fin, :format=>:bta_hora)} &quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="duracion_pixeles"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="inicio_pixeles"/>
    <classElements xsi:type="rails:OperationsChain" name="inicio">
      <operators>=</operators>
      <operators>+</operators>
      <operators>-</operators>
      <operants>self.hora_inicio.beginning_of_day (((self.hora_inicio - inicio)/3600.0) * 50.0).to_i</operants>
      <operants>30</operants>
      <operants>(offset * 50) end protected</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="orden_cronologico"/>
    <classElements xsi:type="rails:OperationsChain" name="errors.add(:hora_fin, I18n.t(&quot;bta hora final no debe ser antes de la de hora inicial&quot;)) if (hora_fin &lt;= hora_inicio)"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
  </rubyClasses>
  <rubyClasses name="Indicador" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":logro" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":actividades" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="has_one"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :texto"/>
    <classElements xsi:type="rails:OperationsChain" name="before_destroy :set_score_siblings, :unlink_score"/>
    <classElements xsi:type="rails:RubyMethod" name="set_score_siblings"/>
    <classElements xsi:type="rails:OperationsChain" name="self.calificacion.sibling_ids end"/>
    <classElements xsi:type="rails:RubyMethod" name="unlink_score"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.calificacion self.calificacion.destroy_or_unlink_from_tree end end"/>
    <classElements xsi:type="rails:RubyMethod" name="clonar"/>
    <classElements xsi:type="rails:OperationsChain" name="clonada">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.clone clonada.logro</operants>
      <operants>logro clonada.save! if clonada.calificacion and self.calificacion clonada.calificacion.peso</operants>
      <operants>self.calificacion.peso clonada.calificacion.save! end if logro.programa and logro.programa.materia self.actividades.collect {|i| i.clonar(clonada)}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end clonada end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.logro">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operants>self.logro.programa.materia self.calificacion</operants>
      <operants>Calificacion.create(:texto => self.texto,:peso => 0.00, 
        :materia=> self.logro.programa.materia, :calificacion=>self.logro.calificacion) self.send(:update_without_callbacks) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy self.actividades.each{|a| a.destroy}"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="count_activities"/>
    <classElements xsi:type="rails:OperationsChain" name="@count_activities">
      <operators>||=</operators>
      <operants>self.actividades.all.size end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.texto end end"/>
  </rubyClasses>
  <rubyClasses name="Informe" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="PLANTILLAS">
      <operators>=</operators>
      <operants>{'estandar_saberes' => 'Est&#xe1;ndar Saberes','estandar_saberes' => 'Est&#xe1;ndar Saberes'}</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":plantilla" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :titulo"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.buscar_informe_a_usar"/>
    <classElements xsi:type="rails:OperationsChain" name="grade">
      <operators>=</operators>
      <operants>Grade.school_id_equals(colegio_id).level_equals(grado).first unless grade raise &quot;No se encontro grado #{grado} para el colegio #{colegio_id}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end informe">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Informe.colegio_id_equals(colegio_id).periodo_id_equals(periodo_id).grade_id_equals(grade.id).first informe</operants>
      <operants>Informe.colegio_id_equals(colegio_id).periodo_id_equals(periodo_id).grade_id_null.first unless informe informe</operants>
      <operants>Informe.colegio_id_equals(colegio_id).periodo_id_null.grade_id_equals(grade.id).first unless informe informe</operants>
      <operants>Informe.colegio_id_equals(colegio_id).periodo_id_null.grade_id_null.first unless informe return informe end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>=</operators>
      <operators>=</operators>
      <operants>get_school self.created_by</operants>
      <operants>get_user end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>get_user end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="InspectionPoint" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":student_log" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :student_log_id, :description"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="InstitutionalDocument" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":area" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":binario" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="self.kinds"/>
    <classElements xsi:type="rails:OperationsChain" name="@@kinds">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{private signup_only}"/>
    <classElements xsi:type="rails:OperationsChain" name="end validates_presence_of :binario_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_inclusion_of :kind, :in => self.kinds validates_length_of :name, :within =>">
      <operators>..</operators>
      <operants>255 validate :check_binario</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>=</operators>
      <operants>GestorUsuario.get_school_id end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="check_binario"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.binario and self.binario.state">
      <operators>==</operators>
      <operants>Binario::ESTADO_ACTIVO self.errors.add :binario_id, I18n.t(:no_file_attached) end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Item" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":concepto" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":factura" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :descuento, :greater_than_or_equal => 0, :less_than_or_equal_to => 100 , :if => :descuento"/>
    <classElements xsi:type="rails:RubyMethod" name="before_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.descuento">
      <operators>||=</operators>
      <operants>0.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update self.calcular_valor_total() end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active">
      <operators>=</operators>
      <operants>false self.save end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy self.calcular_valor_total() end"/>
    <classElements xsi:type="rails:RubyMethod" name="calcular_valor_total"/>
    <classElements xsi:type="rails:OperationsChain" name="valor_total_calculado">
      <operators>=</operators>
      <operants>0.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="conceptos">
      <operators>=</operators>
      <operants>self.factura.items.select { |i| i.active==true }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="conceptos.each do |item|"/>
    <classElements xsi:type="rails:OperationsChain" name="if item.concepto if item.descuento neto">
      <operators>=</operators>
      <operators>=</operators>
      <operators>-</operators>
      <operators>+=</operators>
      <operators>+=</operators>
      <operators>=</operators>
      <operants>item.concepto.valor neto</operants>
      <operants>neto</operants>
      <operants>((neto * item.descuento)/100) valor_total_calculado</operants>
      <operants>neto else valor_total_calculado</operants>
      <operants>item.concepto.valor end end end self.factura.valor_total</operants>
      <operants>valor_total_calculado.to_d self.factura.send(:update_without_callbacks) end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Letra" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":escala" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":homologacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":teacher_advises" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :texto"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :texto, :scope => [:escala_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :texto, :maximum=> 16"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :value"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :minimum"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :maximum"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :homologacion_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :value, :greater_than_or_equal_to => 0.0"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :minimum, :greater_than_or_equal_to => 0.0"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :maximum, :greater_than_or_equal_to => 0.0"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :maximum_higher_than_minimum"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :check_overlapping"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :scale_numbers"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.texto}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="maximum_higher_than_minimum"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:texto, I18n.t('activerecord.errors.messages.blank')) unless self.texto self.errors.add(:value, I18n.t('activerecord.errors.messages.blank')) unless self.value self.errors.add(:maximum, I18n.t('activerecord.errors.messages.blank')) unless self.maximum self.errors.add(:minimum, I18n.t('activerecord.errors.messages.blank')) unless self.minimum return if">
      <operators>!</operators>
      <operators>&lt;=</operators>
      <operators>=</operators>
      <operants>(self.texto and self.value and self.maximum and self.minimum) if self.maximum</operants>
      <operants>self.minimum self.errors.add(:maximum, I18n.t('activerecord.errors.messages.maximum_must_be_higher_or_the_same_than_minimum')) else letra_maxima</operants>
      <operants>self.escala.letras.max { |a, b| a[:maximum] &lt;=> b[:maximum] }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="unless self.minimum">
      <operators>&lt;=</operators>
      <operants>self.value and ((self==letra_maxima &amp;&amp; self.value &lt;= self.maximum ) || self.value &lt; self.maximum)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:value, I18n.t('activerecord.errors.messages.values_rank_must_be_less_or_the_same_than_value')) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="check_overlapping"/>
    <classElements xsi:type="rails:OperationsChain" name="self end"/>
    <classElements xsi:type="rails:RubyMethod" name="scale_numbers"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.value">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operants>self.value.is_a?(BigDecimal) self.value</operants>
      <operants>self.value.round(1) end if self.maximum</operants>
      <operants>self.maximum.is_a?(BigDecimal) self.maximum</operants>
      <operants>self.maximum.round(1) end if self.minimum</operants>
      <operants>self.minimum.is_a?(BigDecimal) self.minimum</operants>
      <operants>self.minimum.round(1) end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Log" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="LogAnalizer">
    <classElements xsi:type="rails:OperationsChain" name="TASK_SCHEDULER_LOGGER">
      <operators>=</operators>
      <operants>ActiveSupport::BufferedLogger.new(&quot;#{RAILS_ROOT}/log/task_scheduler_#{ENV['RAILS_ENV']}.log&quot;)</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="initialize"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.generate_log"/>
    <classElements xsi:type="rails:OperationsChain" name="command">
      <operators>=</operators>
      <operants>&quot;ruby #{RAILS_ROOT}/vendor/gems/request-log-analyzer-1.10.1/bin/request-log-analyzer #{RAILS_ROOT}/log/#{ENV['RAILS_ENV']}.log* --output html --file #{RAILS_ROOT}/tmp/perfomance_analysis/#{ENV['RAILS_ENV']}-#{DateTime.now.to_s}.html&quot; TASK_SCHEDULER_LOGGER.info(&quot;Excecuting #{command}&quot;) system(command)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="TASK_SCHEDULER_LOGGER.info(&quot;Compressing old logs&quot;) system(&quot;gzip #{RAILS_ROOT}/log/#{ENV['RAILS_ENV']}.log.*&quot;)"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
  </rubyClasses>
  <rubyClasses name="Login" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":usuario" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":session" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="before_create :initialize_create"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :initialize_token"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="finish_login"/>
    <classElements xsi:type="rails:OperationsChain" name="self.update_attributes(:finish_datetime => DateTime.now, :active => false) end"/>
    <classElements xsi:type="rails:RubyMethod" name="generate_token"/>
    <classElements xsi:type="rails:OperationsChain" name="Digest::SHA256.hexdigest(&quot;#{self.id} #{self.usuario_id} #{self.session_id} #{self.colegio_id} #{self.ip} #{self.host} #{self.created_at} #{@@users_secrets_token}&quot;) end protected"/>
    <classElements xsi:type="rails:RubyMethod" name="initialize_token"/>
    <classElements xsi:type="rails:OperationsChain" name="self.sso_token">
      <operators>=</operators>
      <operants>self.generate_token self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="initialize_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.start_datetime">
      <operators>=</operators>
      <operators>=</operators>
      <operants>DateTime.now() self.active</operants>
      <operants>true end named_scope :user_name, lambda { |param| param = &quot;%#{param}%&quot; ; {
      :conditions => [&quot;usuarios.nombre like ? or logins.id like ?\
        &quot;, param,param] ,
      :joins=> {:usuario=>{}}} }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="Logo" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="public_filename"/>
    <classElements xsi:type="rails:OperationsChain" name="super(attrs)"/>
  </rubyClasses>
  <rubyClasses name="Logro" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":programa" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":indicadores" relationType="has_many">
      <options key=":order" value="indicadores.id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":actividades" relationType="has_many">
      <options key=":through" value=":indicadores"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="has_one"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :texto"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_periodo"/>
    <classElements xsi:type="rails:OperationsChain" name="before_destroy :set_score_siblings, :unlink_score"/>
    <classElements xsi:type="rails:RubyMethod" name="set_score_siblings"/>
    <classElements xsi:type="rails:OperationsChain" name="self.calificacion.sibling_ids end"/>
    <classElements xsi:type="rails:RubyMethod" name="unlink_score"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.calificacion self.calificacion.destroy_or_unlink_from_tree end end"/>
    <classElements xsi:type="rails:RubyMethod" name="validar_periodo"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.programa and self.programa.asignatura self.errors.add_on_blank(:periodo_planeado, I18n.t(&quot;Seleccione un periodo academico de este logro&quot;)) else self.errors.add_on_blank(:periodo_id, I18n.t(&quot;Seleccione un periodo academico de este logro&quot;)) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="maximo_lineas"/>
    <classElements xsi:type="rails:OperationsChain" name="a">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.actividades.count t</operants>
      <operants>self.indicadores.select { |t| t.actividades.empty?  }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="a">
      <operators>+</operators>
      <operants>t.length end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="maximo_lineas_calificaciones"/>
    <classElements xsi:type="rails:OperationsChain" name="a">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.actividades.count t</operants>
      <operants>self.indicadores.select { |t| t.actividades.empty?  }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="i">
      <operators>=</operators>
      <operators>-</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operants>self.indicadores.count</operants>
      <operants>t.length a</operants>
      <operants>i</operants>
      <operants>t.length</operants>
      <operants>1 end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="maximo_lineas_estudiante"/>
    <classElements xsi:type="rails:OperationsChain" name="a">
      <operators>=</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operants>(self.actividades.select { |v| v.calificacion.peso > 0 }).length t</operants>
      <operants>(self.indicadores.select { |x| x.calificacion.peso > 0 }).length a</operants>
      <operants>t</operants>
      <operants>1 end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.programa">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operants>self.programa.materia self.calificacion</operants>
      <operants>Calificacion.create(:texto => self.texto,:peso => 0.00, :materia=> self.programa.materia) self.send(:update_without_callbacks) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="definir_periodos"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.periodo periodos">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>||</operators>
      <operants>self.programa.materia.curso.periodo.periodos.ascend_by_fecha_inicio unless self.periodo_planeado self.periodo</operants>
      <operants>periodos.first else self.periodo</operants>
      <operants>periodos[self.periodo_planeado-1]</operants>
      <operants>periodos.last end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clonar"/>
    <classElements xsi:type="rails:OperationsChain" name="clonada">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.clone clonada.programa</operants>
      <operants>programa if self.periodo and programa.materia if programa.materia.curso.periodo.periodos.include?(self.periodo) clonada.periodo</operants>
      <operants>self.periodo else position</operants>
      <operants>self.periodo.periodo.periodos.ascend_by_fecha_inicio.index(self.periodo) clonada.periodo</operants>
      <operants>programa.materia.curso.periodo.periodos[position]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end else clonada.definir_periodos end clonada.save! if clonada.calificacion and self.calificacion clonada.calificacion.peso">
      <operators>=</operators>
      <operants>self.calificacion.peso clonada.calificacion.save! end self.indicadores.collect {|i| i.clonar(clonada)}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clonada end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy self.indicadores.each{|i| i.destroy}"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.texto end"/>
    <classElements xsi:type="rails:RubyMethod" name="count_activities"/>
    <classElements xsi:type="rails:OperationsChain" name="@count_activities">
      <operators>||=</operators>
      <operants>self.indicadores.inject(0){|sum, indicator| sum+=indicator.count_activities+1; sum}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
  </rubyClasses>
  <rubyClasses name="Mail" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":notificacion" relationType="belongs_to">
      <options key=":foreign_key" value="notification_id"/>
      <options key=":class_name" value="Notificacion"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :estudiante"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :body, :message=>I18n.t(&quot;El mensaje esta vacio&quot;) validates_presence_of :subject, :message=>I18n.t(&quot;No debe estar vacio&quot;) MANY_EMAILS_VALIDATOR">
      <operators>=</operators>
      <operants>/^(([A-Z0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4})([ ]*,[ ]*))*(([A-Z0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4})([ ,]*))$/i</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :to, :with =>MANY_EMAILS_VALIDATOR, :if => Proc.new{|model| !model.to.blank?}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :cc, :with => MANY_EMAILS_VALIDATOR, :if => Proc.new{|model| !model.cc.blank?}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :cco, :with => MANY_EMAILS_VALIDATOR, :if => Proc.new{|model| !model.cco.blank?}"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school, :on => :create"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.send_time">
      <operators>=</operators>
      <operants>Time.now end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="Mail.send_pending_mails"/>
    <classElements xsi:type="rails:OperationsChain" name="mails">
      <operators>=</operators>
      <operants>Mail.find_all_by_sent_and_active(false, true) mails.each do |mail|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="begin MailGestor.deliver_mail(mail) mail.sent">
      <operators>=</operators>
      <operants>true mail.save!() rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="Mail.generate_mail_body"/>
    <classElements xsi:type="rails:OperationsChain" name="ActionView::Base.new(Rails::Configuration.new.view_path). render(:file=>File.join(&quot;mail_gestor&quot;,&quot;#{mail}.erb&quot;),:locals => locals&#xA;    ) end end"/>
  </rubyClasses>
  <rubyClasses name="MailGestor" superType="ActionMailer::Base">
    <classElements xsi:type="rails:RubyMethod" name="mail"/>
    <classElements xsi:type="rails:OperationsChain" name="recipients mail.to cc mail.cc bcc mail.cco sent_on mail.send_time subject mail.subject body :mail => mail content_type &quot;text/html&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Materia" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia_supermaterias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":super_materia_pesos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":super_materias" relationType="has_many">
      <options key=":through" value=":materia_supermaterias"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":evaluaciones" relationType="has_many">
      <options key=":conditions" value="{:active =>true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":calificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":performancetests" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":main_forum" relationType="belongs_to">
      <options key=":class_name" value="Comentario"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :performancetests"/>
    <classElements xsi:type="rails:Relationship" name=":docente" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to">
      <options key=":foreign_key" value="period_id"/>
      <options key=":class_name" value="Periodo"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":allocation" relationType="belongs_to">
      <options key=":foreign_key" value="allocation_id"/>
      <options key=":class_name" value="VariableAssignment"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":tareas" relationType="has_many">
      <options key=":conditions" value="{:activo =>true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":horarios" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":contenidos" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:Relationship" name=":supervisors" relationType="has_and_belongs_to_many">
      <options key=":join_table" value="supervisors_subjects"/>
      <options key=":class_name" value="Docente"/>
      <options key=":foreign_key" value="supervisor_id"/>
      <options key=":association_foreign_key" value="subject_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":asignaciones" relationType="has_many">
      <options key=":conditions" value="['asignaciones.activo = :activo', {:activo => true}]"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":programa" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":evento" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":comentarios" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":forums" relationType="has_many">
      <options key=":class_name" value="Comentario"/>
      <options key=":conditions" value="{:comentario_id=>nil}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":student_subject_revisions" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":asistencias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":teacher_advises" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :pass_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :schedule_overlapping_error"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :asignatura_id, :message => I18n.t(&quot;subject_is_already_uploaded&quot;), :scope => [:docente_id, :curso_id, :activo], :unless => :validate_asignatura_with_period_closed"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :asignatura_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :schedule_overlapping, :unless => :halt_schedule_overlapping_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_numero_materias"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :available, lambda { |*args|&#xA;    {&#xA;      :conditions => [&quot;periodos.fecha_inicio &lt;= ? and ? &lt;= periodos.fecha_fin\&#xA;        and cursos.activo = ? and materias.activo = ?&quot;,&#xA;        Date.current, Date.current, true, true], :include=> {:curso => :periodo}&#xA;      }&#xA;    }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :available_materia_activa, lambda { |*args|&#xA;      {&#xA;        :conditions => [&quot;periodos.fecha_fin > ? and materias.activo = ?&quot;, Date.current, true], :include=> {:curso => :periodo}&#xA;      }&#xA;    }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_docente_persona_parameters, lambda { |param|&#xA;      param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xA;      if param.count == 1&#xA;        param =  param*2&#xA;        sql = '(personas.full_name Like ?) OR (personas.identificacion Like ? )'&#xA;      else&#xA;        sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xA;      end&#xA;      #left joins added by sab-1750, maybe aren't needed&#xA;      param.insert(0,sql)&#xA;      {&#xA;        :conditions => param ,&#xA;        :joins=> &quot;LEFT OUTER JOIN docentes ON docentes.id = materias.docente_id \&#xA;        LEFT OUTER JOIN personas ON docentes.persona_id = personas.id&quot;} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;          :conditions => {:colegio_id => self.get_school()}, :order => 'materias.id'} }"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :setup_forum"/>
    <classElements xsi:type="rails:RubyMethod" name="setup_forum"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.main_forum_id.nil?">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operants>self.docente_id new_forum</operants>
      <operants>Comentario.new(:materia_id => self.id, :nombre => I18n.t(&quot;main_forum_name&quot;), 
                                         :comentario=> I18n.t('main_forum_comment'), :user_name=> self.docente.persona.to_s,
                                         :created_by =>((self.docente.persona &amp;&amp; self.docente.persona.usuario) ? self.docente.persona.usuario.id : GestorUsuario.obtener_usuario)) new_forum.send :create_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.main_forum_id">
      <operators>=</operators>
      <operants>new_forum.id self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_asignatura_with_period_closed"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.activo and self.curso.periodo.period_closed value">
      <operators>=</operators>
      <operators>=</operators>
      <operants>true else value</operants>
      <operants>false end return value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_period_closed"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.curso.periodo.period_closed value">
      <operators>=</operators>
      <operators>=</operators>
      <operants>true else value</operants>
      <operants>false end return value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="has_evaluation_plan"/>
    <classElements xsi:type="rails:OperationsChain" name="self.programa.logros.periodo_id_equals(subperiodo).blank? end"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.activo">
      <operators>=</operators>
      <operants>false self.send(:update_without_callbacks) self.super_materias.each do |sm|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="sm.destroy end end"/>
    <classElements xsi:type="rails:RubyMethod" name="schedule_overlapping"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.changes['docente_id']"/>
    <classElements xsi:type="rails:OperationsChain" name="overlaping_times">
      <operators>=</operators>
      <operants>self.horarios.inject([]) do |array, horario|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="array">
      <operators>&lt;&lt;</operators>
      <operants>self.docente.validate_teacher_overlapping(horario)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="array"/>
    <classElements xsi:type="rails:OperationsChain" name="end.flatten if overlaping_times.any? self.errors.add(:docente_id, I18n.t(:timetable_conflict_teacher, :schedules =>&#xA;                                            overlaping_times.flatten.map(){|h| h.materia.to_s&lt;&lt;&quot; &quot;&lt;&lt;h.to_s }.join(', '))) self.schedule_overlapping_error">
      <operators>=</operators>
      <operants>true end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_numero_materias"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.curso if self.curso.electivo total">
      <operators>=</operators>
      <operators>+</operators>
      <operators>></operators>
      <operants>(self.id ? self.curso.materias.id_does_not_equal(self.id).count:  self.curso.materias.count)</operants>
      <operants>1 logger.debug(&quot;#{total} #{self.curso.maximo_materias.to_s}&quot;) if total.to_i</operants>
      <operants>self.curso.maximo_materias.to_i self.errors.add(:curso_id, I18n.t(:maximum_number_permitted_subjects)) end end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.colegio_id</operants>
      <operants>GestorUsuario.obtener_colegio self.activo</operants>
      <operants>true self.didnt_see_homeworks_counter</operants>
      <operants>0 self.did_homeworks_datetime</operants>
      <operants>DateTime.now self.didnt_see_test_counter</operants>
      <operants>0 self.did_test_datetime</operants>
      <operants>DateTime.now self.didnt_see_updates_forums_counter</operants>
      <operants>0 self.did_updates_forums_datetime</operants>
      <operants>DateTime.now self.updated_homeworks_datetime</operants>
      <operants>DateTime.now self.updated_test_datetime</operants>
      <operants>DateTime.now self.updated_forums_datetime</operants>
      <operants>DateTime.now end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create self.asignatura.programa.clonar(self.id) end"/>
    <classElements xsi:type="rails:RubyMethod" name="nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="self.curso">
      <operators>&amp;&amp;</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.curso.electivo</operants>
      <operants>self.curso.nombre</operants>
      <operants>self.asignatura.nombre end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="area"/>
    <classElements xsi:type="rails:OperationsChain" name="self.asignatura.area end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_descriptores"/>
    <classElements xsi:type="rails:OperationsChain" name="student_id"/>
  </rubyClasses>
  <rubyClasses name="MateriaSupermateria" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":super_materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :super_materia_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :materia_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :super_materia_id, :scope =>[:materia_id]"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>||=</operators>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="MedicalBackground" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="serialize :disability"/>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to">
      <options key=":foreign_key" value="person_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":binarios" relationType="has_and_belongs_to_many">
      <options key=":conditions" value="{:state => Binario::ESTADO_ACTIVO}"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :person_id, :if=>:id"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :photo"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :state"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_file_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 rescue_file</operants>
      <operants>Tempfile.new('csv') FasterCSV.foreach(file) do |row|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="begin medical">
      <operators>=</operators>
      <operators>=</operators>
      <operants>MedicalBackground.new student</operants>
      <operants>Estudiante.find_by_code(row[2].to_i) if student.nil? ActiveRecord::Base.logger.error &quot;No se pudo procesar la l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row+[&quot;No se encontro estudiante con el codigo #{row[2]}&quot;,$!.message]).map{|a| &quot;\&quot;#{a}\&quot;&quot;}.join(',')) end person">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Persona.find_by_id(student.persona_id) medical.person_id</operants>
      <operants>person.id medical.hearing_test</operants>
      <operants>row[3]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="medical.hearing_conduct">
      <operators>=</operators>
      <operants>row[4]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="medical.visual_test">
      <operators>=</operators>
      <operants>row[5]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="medical.visual_conduct">
      <operators>=</operators>
      <operants>row [6]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="medical.save! apellido">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>&quot;#{row[0]}}&quot; nombre</operants>
      <operants>&quot;#{row[1]}&quot; codigo</operants>
      <operants>row[2]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="resultado_auditivo">
      <operators>=</operators>
      <operants>row[3]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="conducta_auditiva">
      <operators>=</operators>
      <operants>row[4]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="resultado_visual">
      <operators>=</operators>
      <operants>row[5]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="conducta_visual">
      <operators>=</operators>
      <operants>row[6]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="rescue_file.puts((row+['correct']).map{|a| &quot;\&quot;#{a}\&quot;&quot;}.join(',')) rescue ActiveRecord::Base.logger.error &quot;No se pudo procesar l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row+['fail',$!.message]).map{|a| &quot;\&quot;#{a}\&quot;&quot;}.join(',')) end counter">
      <operators>+=</operators>
      <operants>1 end rescue_file.rewind rescue_file end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_file_of_pharmacological_medications_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 rescue_file</operants>
      <operants>Tempfile.new('csv') FasterCSV.foreach(file) do |row|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="begin student">
      <operators>=</operators>
      <operants>Estudiante.find_by_code(row[4].to_i) if student.nil? ActiveRecord::Base.logger.error &quot;No se pudo procesar la l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row+[&quot;No se encontro estudiante con el codigo #{row[2]}&quot;,$!.message]).map{|a| &quot;\&quot;#{a}\&quot;&quot;}.join(',')) end logger.error student.persona.to_s if student.persona.medical_background.blank? medical">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>MedicalBackground.new else medical</operants>
      <operants>student.persona.medical_background end student.persona.medical_background.preferred_clinical</operants>
      <operants>row[5]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.doctor">
      <operators>=</operators>
      <operants>row[6]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.phone_doctor">
      <operators>=</operators>
      <operants>row[7]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.allergies">
      <operators>=</operators>
      <operants>row[8]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.illnesses">
      <operators>=</operators>
      <operants>row[9]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.disability">
      <operators>=</operators>
      <operants>row[10]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.dislocation_and_fractures">
      <operators>=</operators>
      <operants>row[11]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.current_medications">
      <operators>=</operators>
      <operants>row[12]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.temporal_medications">
      <operators>=</operators>
      <operants>row[13]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.permanent_medications">
      <operators>=</operators>
      <operants>row[14]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.drugs_should_not_receive">
      <operators>=</operators>
      <operants>row[15]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.hypertension">
      <operators>=</operators>
      <operants>row[16]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.epilsepsia">
      <operators>=</operators>
      <operants>row[17]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.tuberculosis">
      <operators>=</operators>
      <operants>row[18]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.heart_disease">
      <operators>=</operators>
      <operants>row[19]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.cancer">
      <operators>=</operators>
      <operants>row[20]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.diabetes">
      <operators>=</operators>
      <operants>row[21]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.mental_illness">
      <operators>=</operators>
      <operants>row[22]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.asthma">
      <operators>=</operators>
      <operants>row[23]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.rheumatism">
      <operators>=</operators>
      <operants>row[24]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.family_allergies">
      <operators>=</operators>
      <operants>row[25]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.other_cases">
      <operators>=</operators>
      <operants>row[26]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="student.persona.medical_background.save! rescue_file.puts((row+['correct']).map{|a| &quot;\&quot;#{a}\&quot;&quot;}.join(',')) rescue ActiveRecord::Base.logger.error &quot;No se pudo procesar l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row+['fail',$!.message]).map{|a| &quot;\&quot;#{a}\&quot;&quot;}.join(',')) end counter">
      <operators>+=</operators>
      <operants>1 end rescue_file.rewind rescue_file.path end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="filter_text"/>
    <classElements xsi:type="rails:OperationsChain" name="text">
      <operators>=</operators>
      <operants>text.to_s.gsub(&quot;'&quot;,&quot;&quot;) text.gsub!(&quot;.&quot;,&quot;&quot;) text.gsub!('&quot;',&quot;&quot;) text.gsub!(&quot;,&quot;,&quot;&quot;) text.gsub!(&quot; &quot;,&quot;&quot;) text.gsub!(&quot;_&quot;,&quot;&quot;) text.gsub!(&quot;-&quot;,&quot;&quot;) text.strip! text end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>[&quot;nursing&quot;, &quot;nutrition&quot;, &quot;end&quot;].freeze end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="MedicalTest" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
      <options key=":foreign_key" value="person_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :person_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :size"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :weight"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :age"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :test, :csv"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="curso"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.estudiante.curso_actual end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.name</operants>
      <operants>self.persona.to_s if self.persona.estudiante self.code</operants>
      <operants>self.persona.estudiante.code end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.name</operants>
      <operants>self.persona.to_s if self.persona.estudiante self.code</operants>
      <operants>self.persona.estudiante.code end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="edad"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.blank? unless self.person_id.blank? unless self.persona.fecha_nacimiento.blank? age">
      <operators>=</operators>
      <operators>-</operators>
      <operators>-=</operators>
      <operators>&lt;</operators>
      <operators>=</operators>
      <operants>fecha.year</operants>
      <operants>self.persona.fecha_nacimiento.year age</operants>
      <operants>1 if fecha.to_date</operants>
      <operants>(self.persona.fecha_nacimiento.year + age) self.age</operants>
      <operants>age else self.errors.add(:person_id, I18n.t('must_be_add_a_person')) end else self.errors.add(:person_id, I18n.t('must_be_add_a_person')) end else self.errors.add(:person_id, I18n.t('must_be_add_a_person')) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="edad_by_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="age">
      <operators>=</operators>
      <operators>-</operators>
      <operators>-=</operators>
      <operators>&lt;</operators>
      <operants>fecha.to_date.year</operants>
      <operants>self.persona.fecha_nacimiento.year age</operants>
      <operants>1 if fecha.to_date</operants>
      <operants>(self.persona.fecha_nacimiento.year + age) return age end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv_for_medical_tests"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',&quot;#{self.to_s}.medical_test_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin ActiveRecord::Base.transaction do e">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Estudiante.code_equals(row[1].to_i).last p</operants>
      <operants>Persona.id_equals(e.persona_id).last row[1]</operants>
      <operants>row[1]</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Node" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":evaluation_plan" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":children" relationType="has_many">
      <options key=":foreign_key" value="parent_node_id"/>
      <options key=":class_name" value="Node"/>
      <options key=":dependent" value=":destroy"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":parent" relationType="belongs_to">
      <options key=":foreign_key" value="parent_node_id"/>
      <options key=":class_name" value="Node"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="Notificacion" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="CREATED">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 PUBLISHED</operants>
      <operants>2 SENT</operants>
      <operants>3 named_scope :visible, :conditions => {:state => [Notificacion::PUBLISHED,
                                                   Notificacion::SENT]}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :for_student, :conditions => [&quot;notificaciones.perfil_id IS NULL OR notificaciones.perfil_id = #{Perfil::ESTUDIANTE}&quot;]"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :for_teacher, :conditions => [&quot;notificaciones.perfil_id IS NULL OR notificaciones.perfil_id = #{Perfil::DOCENTE}&quot;]"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :for_guardian, :conditions => [&quot;notificaciones.perfil_id IS NULL OR notificaciones.perfil_id = #{Perfil::ACUDIENTE}&quot;]"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :for_administrator, :conditions => [&quot;notificaciones.perfil_id IS NULL OR notificaciones.perfil_id = #{Perfil::ADMINISTRATIVO}&quot;]"/>
    <classElements xsi:type="rails:OperationsChain" name="STATES_DEFINITION">
      <operators>=</operators>
      <operants>{1 => &quot;created&quot;, 2 => &quot;published&quot;, 3 => &quot;sent&quot;, 4=>'inactive'}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="IMAGES_STATE">
      <operators>=</operators>
      <operants>{1 => &quot;mail--pencil.png&quot;, 2 => &quot;mail--exclamation.png&quot;, 3 => &quot;mail--arrow.png&quot;, 4=> 'fail.gif'}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :estudiante, :materia, :persona_form"/>
    <classElements xsi:type="rails:Relationship" name=":mails" relationType="has_many">
      <options key=":foreign_key" value="notification_id"/>
      <options key=":class_name" value="Mail"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":perfil" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":sender" relationType="belongs_to">
      <options key=":foreign_key" value="created_by"/>
      <options key=":class_name" value="Usuario"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :asunto"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :mensaje"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :asunto, :maximum => 250, :message => &quot;debe tener maximo 30 caracteres&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :grado_curso"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :persona_perfil"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :allow_all"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.colegio_id</operants>
      <operants>GestorUsuario.obtener_colegio self.state</operants>
      <operants>Notificacion.states[:created]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario if GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="grado_curso"/>
    <classElements xsi:type="rails:OperationsChain" name="errors.add(&quot;Curso&quot;,&quot;El curso no coincide con el grado seleccionado&quot;) if (!self.curso.blank? and !self.grade_id.blank? and self.curso.grade_id != self.grade_id)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="persona_perfil"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="persona_nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="@persona_nombre">
      <operators>||=</operators>
      <operants>self.persona.nombre_completo if self.persona_id @persona_nombre end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="persona_nombre="/>
    <classElements xsi:type="rails:OperationsChain" name="@persona_nombre">
      <operators>=</operators>
      <operants>val end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="curso_nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="@curso_nombre">
      <operators>=</operators>
      <operants>self.curso.nombre if self.curso_id @curso_nombre end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="curso_nombre="/>
    <classElements xsi:type="rails:OperationsChain" name="@curso_nombre">
      <operators>=</operators>
      <operants>val end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
  </rubyClasses>
  <rubyClasses name="Numero" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":escala" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":homologacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":teacher_advises" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :minimo , :message => I18n.t(&quot;El valor minimo debe ser numerico&quot;),:if =>:minimo"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :maximo, :message => I18n.t(&quot;El valor maximo debe ser numerico&quot;), :if =>:maximo"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :minimo, :message => I18n.t(&quot;Ningun valor minimo  debe  estar en blanco&quot;) validates_presence_of :maximo, :message => I18n.t(&quot;Ningun valor maximo  debe  estar en blanco&quot;) validate :validar_minimo_maximo"/>
    <classElements xsi:type="rails:RubyMethod" name="validar_minimo_maximo"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.maximo">
      <operators>&amp;&amp;</operators>
      <operators>>=</operators>
      <operants>self.minimo unless self.maximo</operants>
      <operants>self.minimo self.errors.add(:maximo, (I18n.t(&quot;un valor minimo no puede ser mayor que un valor maximo&quot;))) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="maximo="/>
    <classElements xsi:type="rails:OperationsChain" name="super value end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.escala_id">
      <operators>||=</operators>
      <operants>self.escala end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.crear"/>
    <classElements xsi:type="rails:OperationsChain" name="parametros.each do |parametro|"/>
    <classElements xsi:type="rails:OperationsChain" name="nuevo">
      <operators>=</operators>
      <operants>self.new(parametro) unless nuevo.save! nuevo.escala.errors.add_to_base(&quot;Error no se ha guardado&quot;) return false end end return true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.minimo}  -  #{self.maximo}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_full_name"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.homologacion.texto} (#{self.minimo}  -  #{self.maximo})&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="Opcion" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":pregunta" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":respuestas" relationType="has_many">
      <options key=":conditions" value="{:active => true}"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :text, :message => I18n.t(&quot;Describa un texto para la opci&#xf3;n&quot;) validates_presence_of :value, :message =>I18n.t(&quot;Describa un valor de respuesta para la opci&#xf3;n&quot;) validates_numericality_of :value, :message => I18n.t(&quot;El valor de respuesta debe ser numerico&quot;)"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.active</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active">
      <operators>=</operators>
      <operants>false self.save end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="text end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_url_image"/>
    <classElements xsi:type="rails:OperationsChain" name="return nil unless url config">
      <operators>=</operators>
      <operants>Pregunta.get_config_files AWS::S3::Base.establish_connection!(
      :access_key_id=>config[ENV['RAILS_ENV']][&quot;access_key_id&quot;],
      :secret_access_key=>config[ENV['RAILS_ENV']][&quot;secret_access_key&quot;]
    ) AWS::S3::S3Object.url_for(url,
      config[ENV['RAILS_ENV']][&quot;bucket_name&quot;]
      #,
      #:expires_in=> 10,
      #:use_ssl => true
    ) end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Pais" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegios" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":departamentos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":ciudades" relationType="has_many"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.nombre}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="ParentOnbehalfStudentPermission" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="PendingNotification" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":event" relationType="belongs_to">
      <options key=":class_name" value="Evento"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":homework" relationType="belongs_to">
      <options key=":class_name" value="Tarea"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":topic" relationType="belongs_to">
      <options key=":class_name" value="Materia"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":post" relationType="belongs_to">
      <options key=":class_name" value="Comentario"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":test" relationType="belongs_to">
      <options key=":class_name" value="Evaluacion"/>
      <options key=":conditions" value="{:active=>true}"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="before_create :set_school"/>
    <classElements xsi:type="rails:RubyMethod" name="self.kinds"/>
    <classElements xsi:type="rails:OperationsChain" name="@@kinds">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{homework event test forum}"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id">
      <operators>=</operators>
      <operants>self.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Perfil" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="ADMINISTRADOR">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 ESTUDIANTE</operants>
      <operants>2 ACUDIENTE</operants>
      <operants>3 ADMINISTRATIVO</operants>
      <operants>4 DOCENTE</operants>
      <operants>5 EDITOR</operants>
      <operants>6 SOPORTE</operants>
      <operants>15 SUPERADMIN</operants>
      <operants>16 @@profile_object</operants>
      <operants>{Perfil::ESTUDIANTE=>:estudiante,
    Perfil::ACUDIENTE=>:acudiente, Perfil::ADMINISTRATIVO => :administrador,
    Perfil::DOCENTE => :docente}</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":usuarios" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:Relationship" name=":permisos" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_relationships_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="@@profile_object.invert end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_profile_object"/>
    <classElements xsi:type="rails:OperationsChain" name="@@profile_object[self.id]"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="nombre_perfil"/>
    <classElements xsi:type="rails:OperationsChain" name="self.nombre end"/>
    <classElements xsi:type="rails:RubyMethod" name="take_off_printing"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.ipaper_id Scribd::API.instance.send_request('docs.changeSettings',&#xA;        :doc_ids => self.ipaper_id,&#xA;        :download_formats=>'',:disable_print=>1,&#xA;        :disable_select_text=> 1,&#xA;        :disable_upload_link => 1) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="make_ipaper_secure_digest"/>
    <classElements xsi:type="rails:OperationsChain" name="session_id">
      <operators>=</operators>
      <operators>=</operators>
      <operants>&quot;#{Digest::MD5.hexdigest(request.session_options[:id])}ip#{request.remote_ip}&quot; texto</operants>
      <operants>scribd_config[&quot;secret&quot;]</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="PerfilPermiso" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:TableName" name="perfiles_permisos"/>
    <classElements xsi:type="rails:RubyMethod" name="id"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{perfil_id}_#{permiso_id}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="PerfilUsuario" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:TableName" name="perfiles_usuarios"/>
    <classElements xsi:type="rails:RubyMethod" name="id"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{perfil_id}_#{usuario_id}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="PerformanceResult" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":performancetest" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":resultado" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="Performancetest" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":performance_results" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":allocation" relationType="belongs_to">
      <options key=":foreign_key" value="variable_assignment_id"/>
      <options key=":class_name" value="VariableAssignment"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":supervisor" relationType="belongs_to">
      <options key=":foreign_key" value="supervisor_id"/>
      <options key=":class_name" value="Docente"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="before_create :set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :change_performance_test"/>
    <classElements xsi:type="rails:Relationship" name=":parent" relationType="belongs_to">
      <options key=":class_name" value="Acudiente"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student" relationType="belongs_to">
      <options key=":class_name" value="Estudiante"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":teacher" relationType="belongs_to">
      <options key=":class_name" value="Docente"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :variable_assignment_id"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_course_allocation, lambda { |search| ; {&#xA;    :joins=>&quot;INNER JOIN estudiantes AS estudiantes_1 ON (estudiantes_1.id = performancetests.student_id AND estudiantes_1.estado = 'active' AND estudiantes_1.activo = 1)&#xA;          INNER JOIN personas AS estudiante_personas ON estudiante_personas.id = estudiantes_1.persona_id &#xA;          INNER JOIN acudientes AS acudientes_1 ON acudientes_1.id = performancetests.parent_id &#xA;          INNER JOIN personas AS acudiente_personas ON acudiente_personas.id = acudientes_1.persona_id&quot;,&#xA;      :conditions=>[&quot;(estudiante_personas.full_name like ?) OR (acudiente_personas.full_name like ?)&quot;,&#xA;          &quot;%#{search}%&quot;, &quot;%#{search}%&quot; ]&#xA;    }&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :answered, lambda {|search| &#xA;    conditions = case search.to_i&#xA;    when 1&#xA;      [&quot;resultados_answered.finalizado = ?&quot;,true]&#xA;    when 0&#xA;      [&quot;resultados_answered.finalizado IS NULL OR resultados_answered.finalizado = ?&quot;,false]&#xA;    end ;&#xA;    {&#xA;    :joins => &quot;LEFT JOIN performance_results AS performance_results_answered &#xA;      ON performance_results_answered.performancetest_id = performancetests.id &#xA;      LEFT JOIN resultados AS resultados_answered &#xA;      ON performance_results_answered.resultado_id = resultados_answered.id&quot;, &#xA;      :conditions => conditions, :select=>'performancetests.*, performance_results_answered.id as ans'&#xA;    }}"/>
    <classElements xsi:type="rails:OperationsChain" name="EVALUATOR_TYPES">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{teacher supervisor}"/>
    <classElements xsi:type="rails:OperationsChain" name="EVALUATED_TYPES">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{auto teacher}"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_or_generate_performancetest"/>
    <classElements xsi:type="rails:OperationsChain" name="performance">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Performancetest.find(:last, :conditions => arg) unless performance performance</operants>
      <operants>Performancetest.create(arg) end performance end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id">
      <operators>=</operators>
      <operants>Performancetest.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="change_performance_test"/>
    <classElements xsi:type="rails:OperationsChain" name="respuesta">
      <operators>=</operators>
      <operants>false self.performance_results.each do |pr|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="unless pr.resultado.respuestas.blank? respuesta">
      <operators>=</operators>
      <operators>!=</operators>
      <operators>==</operators>
      <operants>true end end if self.performance_results and self.variable_assignment_id</operants>
      <operants>self.variable_assignment_id_was and respuesta</operants>
      <operants>true self.errors.add(:performance_results,I18n.t(&quot;pendiente&quot;)) return false end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_generate_results"/>
    <classElements xsi:type="rails:OperationsChain" name="performance">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Performancetest.allocation_id_not_null.school_id_equals(self.get_school()).find(:last, :conditions => arg_performance_test) if performance performance_result</operants>
      <operants>performance.performance_results.resultado_persona_id_equals(evaluator_id).persona_id_equals(evaluated_id).first if performance_result return performance_result.resultado else result</operants>
      <operants>nil Resultado.transaction do result</operants>
      <operants>Resultado.create!(:persona_id=>evaluator_id, :periodo_id=>performance.periodo_id, :evaluacion_id => performance.allocation.evaluacion_id) perfor_result</operants>
      <operants>PerformanceResult.create!(:resultado_id => result.id, :performancetest_id => performance.id, :persona_id => evaluated_id) end return result end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_generate_all_results"/>
    <classElements xsi:type="rails:OperationsChain" name="performances">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operants>Performancetest.allocation_id_not_null.school_id_equals(self.get_school()).find(:all, :conditions => arg_performance_test) results</operants>
      <operants>[] unless performances.blank? for performance in performances performance_result</operants>
      <operants>performance.performance_results.resultado_persona_id_equals(evaluator_id).persona_id_equals(evaluated_id).first if performance_result logger.error(&quot;res1:&quot; + performance_result.resultado.to_yaml) results</operants>
      <operants>performance_result.resultado else result</operants>
      <operants>nil Resultado.transaction do result</operants>
      <operants>Resultado.create!(:persona_id=>evaluator_id, :periodo_id=>performance.periodo_id, :evaluacion_id => performance.allocation.evaluacion_id) perfor_result</operants>
      <operants>PerformanceResult.create!(:resultado_id => result.id, :performancetest_id => performance.id, :persona_id => evaluated_id) end logger.error(&quot;res2:&quot; + result.to_yaml) results</operants>
      <operants>result end end end return results end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.find_parents_tests"/>
    <classElements xsi:type="rails:OperationsChain" name="academic_year">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Periodo.academic_years.find(academic_year_id) periodo</operants>
      <operants>academic_year periodo</operants>
      <operants>academic_year.periodos.find_by_id(period_id) unless academic_year.test_teacher logger.error(&quot;academic_year #{academic_year.id} #{academic_year.to_s}  &quot;) course_ids</operants>
      <operants>Curso.electivo_equals(0). periodo_id_equals(academic_year.id).all(:select=>:id,
      :conditions=>(search[:grade_id].blank? ? {} : {:grade_id=>search[:grade_id]})) if search[:variable_assignament_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="variable_condition">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>&quot;INNER JOIN variable_assignments ON (variable_assignments.id = performancetests.variable_assignment_id 
        AND variable_assignments.id = #{search[:variable_assignament_id]})&quot; else variable_condition</operants>
      <operants>nil end order</operants>
      <operants>get_order_for_find_parents_tests(search[:order])</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="CourseStudent.state_equals('active').course_id_equals(course_ids).paginate(:page=>page, :per_page => search[:per_page]||30,&#xA;      :joins=>&quot;INNER JOIN estudiantes ON (estudiantes.id = course_students.student_id AND estudiantes.estado = 'active' AND estudiantes.activo = 1)&#xA;          INNER JOIN personas AS estudiante_personas ON estudiante_personas.id = estudiantes.persona_id &#xA;          INNER JOIN acudientes ON acudientes.id = estudiantes.acudiente_id &#xA;          INNER JOIN personas AS acudiente_personas ON acudiente_personas.id = acudientes.persona_id &#xA;          INNER JOIN cursos ON (course_students.course_id = cursos.id AND cursos.activo = 1 )&#xA;          INNER JOIN grades ON grades.id = cursos.grade_id&#xA;          LEFT JOIN performancetests ON &#xA;            (performancetests.student_id = estudiantes.id AND performancetests.parent_id = acudientes.id AND performancetests.periodo_id = #{periodo.id} &#xA;            AND performancetests.evaluator = 'parent' AND performancetests.evaluated = 'course') #{variable_condition}&quot;, &#xA;        :select=> &quot;course_students.*, performancetests.name AS evaluacion, performancetests.id AS performancetests_id&quot;, &#xA;        :include=>{:estudiante=>{:persona=>nil, :acudiente=>:persona}, :curso=>:grade},&#xA;        :group=>'course_students.id',&#xA;        :conditions=>[&quot;(estudiante_personas.full_name like ?) OR (acudiente_personas.full_name like ?)&quot;,&#xA;          &quot;%#{search[:search]}%&quot;, &quot;%#{search[:search]}%&quot; ], :order=>order&#xA;      ) end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_order_for_find_parents_tests"/>
    <classElements xsi:type="rails:OperationsChain" name="case order when &quot;ascend_by_estudiante_acudiente_persona_full_name&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;acudiente_personas.full_name&quot; when &quot;descend_by_estudiante_acudiente_persona_full_name&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;acudiente_personas.full_name DESC&quot; when &quot;ascend_by_estudiante_persona_full_name&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;estudiante_personas.full_name&quot; when &quot;descend_by_estudiante_persona_full_name&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;estudiante_personas.full_name DESC&quot; when &quot;ascend_by_curso&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;grades.name, cursos.nombre&quot; when &quot;descend_by_curso&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;grades.name, cursos.nombre DESC&quot; when 'ascend_by_evaluacion'"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;performancetests.name,acudiente_personas.full_name&quot; when 'descend_by_evaluacion'"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;performancetests.name DESC,acudiente_personas.full_name&quot; else &quot;performancetests.id DESC&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_or_create_performance_result"/>
    <classElements xsi:type="rails:OperationsChain" name="person">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Persona.by_current_school.find(person_id) performance_result</operants>
      <operants>self.performance_results.find_by_persona_id(person.id) unless performance_result Performancetest.transaction resultado</operants>
      <operants>Resultado.create(:evaluacion_id => self.allocation.evaluacion_id, :persona_id => person.id) performance_result</operants>
      <operants>self.performance_results.create(:persona_id=>person_id, 
         :resultado => resultado) resultado.create_answers end end performance_result end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Periodo" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="default_scope :order => 'fecha_inicio'"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :config_step"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :sub_period_number"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :period_naming_type"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :numeros_attributes"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :letras"/>
    <classElements xsi:type="rails:OperationsChain" name="MAX_SUB_PERIODOS">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>12 NIVELES_RECUPERACION</operants>
      <operants>['year_and_period', 'year', 'period','accomplishment', 'accomplishment_indicator', 'activity'] NIVELES_RECUPERACION_HASH</operants>
      <operants>{:year => 'year', :period => 'period', :accomplishment => 'accomplishment',&#xD;
    :indicator => 'accomplishment_indicator', :activity => 'activity', :year_and_period => 'year_and_period'&#xD;
  }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FINAL_SCORE_BY_SUBJECTS">
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 FINAL_SCORE_BY_SUPER_MATERIAS</operants>
      <operants>2</operants>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodos" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_many">
      <options key=":conditions" value="{:activo => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":logros" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":escala" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":calificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":cobros" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":boletines" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":contador_asistencias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":super_materia_pesos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":allocations" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":informes" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre, :if => Proc.new{|obj| obj.step_gt_or_eq(2) }"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validates_uniqueness_of_nombre, :if => Proc.new{|obj| obj.step_gt_or_eq(2)}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :code_period, :scope=>[:colegio_id, :periodo_id], :if=>:code_period"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :nombre, :maximum=>30"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :fecha_inicio, :if => Proc.new{|obj| obj.step_gt_or_eq(2) }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :fecha_fin, :if => Proc.new{|obj| obj.step_gt_or_eq(2) }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :min_printing_date"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :type_study_plan, :unless => :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :initial_registration_date_ratings, :unless => :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_fecha, :if => Proc.new{|obj| obj.step_gt_or_eq(2) }"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_padre"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_nuevo"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_suscription_time, :validate_notes_time"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_scale, :unless => :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_all_dates, :if => :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_dates_test_teacher_academic_year"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :numericality_of_sub_period_number, :if => Proc.new{|obj| obj.config_step == '5' }"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_letter_scales, :if => Proc.new{|obj| obj.config_step == '6' }"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_fecha_hoja_de_matricula"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_fecha_limite_modificacion_asignaturas"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_times"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :calificaciones"/>
    <classElements xsi:type="rails:RubyMethod" name="available?"/>
    <classElements xsi:type="rails:OperationsChain" name="today">
      <operators>=</operators>
      <operators>>=</operators>
      <operators>&amp;&amp;</operators>
      <operators>&lt;=</operators>
      <operants>Date.current today</operants>
      <operants>self.fecha_inicio</operants>
      <operants>today</operants>
      <operants>self.fecha_fin end default_scope :conditions=>{:activo=> true}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xD;&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :academic_years, lambda { {&#xD;&#xA;      :conditions => {:colegio_id => self.get_school(),&#xD;&#xA;      :periodo_id => nil},:order=> &quot;periodos.fecha_inicio&quot; } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :sub_periods, lambda{ {&#xD;&#xA;    :joins => &quot;INNER JOIN periodos as academic_year ON periodos.periodo_id = academic_year.id&quot;,&#xD;&#xA;    :conditions => [&quot;periodos.colegio_id = ? AND periodos.periodo_id IS NOT NULL AND academic_year.activo = ?&quot;, self.get_school(), 1]&#xD;&#xA;  } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :current_and_future, lambda{{&#xD;&#xA;    :conditions => [&quot;periodos.fecha_fin >= ?&quot;, Date.current]&#xD;&#xA;  } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :with_active_tests, lambda { {&#xD;&#xA;      :conditions => [&quot;(periodos.initial_test_teacher &lt;= ? &#xD;&#xA;          AND periodos.ending_test_teacher >= ? &#xD;&#xA;          AND periodos.activo = ?)&quot;,&#xD;&#xA;       Date.current, Date.current, true]} }"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_scale"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:escala_numerica, I18n.t('activerecord.errors.messages.empty')) if self.escala_numerica.nil? end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_times"/>
    <classElements xsi:type="rails:OperationsChain" name="self.fecha_inscripciones">
      <operators>||=</operators>
      <operators>=</operators>
      <operants>self.fecha_inicio self.colegio_id</operants>
      <operants>Periodo.get_school if Periodo.get_school end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.process_field"/>
    <classElements xsi:type="rails:OperationsChain" name="field.to_s.gsub(Persona::NAME_INVERSE_VALIDATOR,'').gsub(/ +/,' ').strip end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 school</operants>
      <operants>Colegio.f(Persona.get_school) rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',&#xD;
      &quot;#{self.to_s}.periodos_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename, :headers=>true) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin periodo">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Periodo.colegio_id_equals(school.id).code_period_equals(process_field(row['code_period'])).last if periodo.blank? periodo</operants>
      <operants>Periodo.new() periodo.fecha_inicio</operants>
      <operants>Date.strptime((process_field(row['fecha_inicial'])), &quot;%m-%d-%Y&quot;) periodo.fecha_fin</operants>
      <operants>Date.strptime(((process_field(row['fecha_final']))), &quot;%m-%d-%Y&quot;) periodo.activo</operants>
      <operants>true periodo.escala_numerica</operants>
      <operants>(process_field(row['escala_numerica'])) periodo.nombre</operants>
      <operants>(process_field(row['nombre'])) periodo.min_printing_date</operants>
      <operants>Date.strptime((process_field(row['fecha_final'])), &quot;%m-%d-%Y&quot;) periodo.type_study_plan</operants>
      <operants>&quot;academic_year&quot; periodo.initial_registration_date_ratings</operants>
      <operants>Date.strptime((process_field(row['fecha_final'])), &quot;%m-%d-%Y&quot;) periodo.colegio_id</operants>
      <operants>school.id periodo.code_period</operants>
      <operants>(process_field(row['code_period'])) periodo.period_closed</operants>
      <operants>true periodo.save! escala</operants>
      <operants>Escala.new() escala.periodo_id</operants>
      <operants>periodo.id escala.colegio_id</operants>
      <operants>school.id escala.save! period_with_escala_numero</operants>
      <operants>Periodo.colegio_id_equals(school.id).periodo_id_null(true).select{|p| p.escala }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="period_with_escala_letra">
      <operators>=</operators>
      <operants>Periodo.colegio_id_equals(90).periodo_id_null(true).select{|p| p.escala }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="period_with_letters">
      <operators>=</operators>
      <operants>period_with_escala_letra.detect{|p| !p.escala.letras.blank?}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="period_with_numbers">
      <operators>=</operators>
      <operants>period_with_escala_numero.detect{|p| !p.escala.numeros.blank?}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="period_with_numbers period_with_letters unless periodo.escala_numerica.blank? period_with_numbers.escala.numeros.each do |n|"/>
    <classElements xsi:type="rails:OperationsChain" name="numero">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Numero.new() numero.maximo</operants>
      <operants>n.maximo numero.minimo</operants>
      <operants>n.minimo numero.escala_id</operants>
      <operants>periodo.escala.id numero.save! end end end rescue_file.puts((row.to_a+['correct']).map{|a| &quot;\&quot;#{a.to_s.gsub(',','')}\&quot;&quot;}.join(',')) rescue ActiveRecord::Base.logger.error &quot;No se pudo procesar l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row.to_a+['fail',$!.message]).map{|a| &quot;\&quot;#{a.to_s.gsub(',','')}\&quot;&quot;}.join(',')) end counter">
      <operators>+=</operators>
      <operants>1 end end rescue_file_path end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_dates_test_teacher_academic_year"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.initial_test_teacher.blank? if self.initial_test_teacher">
      <operators>&lt;</operators>
      <operators>></operators>
      <operators>&lt;</operators>
      <operators>></operators>
      <operators>&lt;</operators>
      <operators>&lt;</operators>
      <operants>self.fecha_inicio or self.initial_test_teacher</operants>
      <operants>self.fecha_fin self.errors.add(:initial_test_teacher,&#xD;
          I18n.t(&quot;initial_date_test_teacher_must_be_higher_to_the_period_start_date&quot;)) end end unless self.ending_test_teacher.blank? if self.ending_test_teacher</operants>
      <operants>self.fecha_inicio or self.ending_test_teacher</operants>
      <operants>self.fecha_fin if self.ending_test_teacher</operants>
      <operants>self.initial_test_teacher self.errors.add(:ending_test_teacher,&#xD;
            I18n.t(&quot;ending_date_test_teacher_must_be_higher_or_equal_to_initial_date_test_teacher&quot;)) else self.errors.add(:ending_test_teacher,&#xD;
            I18n.t(&quot;ending_date_test_teacher_must_be_higher_to_the_period_start_date&quot;)) end else if self.ending_test_teacher</operants>
      <operants>self.initial_test_teacher self.errors.add(:ending_test_teacher,&#xD;
            I18n.t(&quot;ending_date_test_teacher_must_be_higher_or_equal_to_initial_date_test_teacher&quot;)) end end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_suscription_time"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:fecha_inscripciones,&#xD;&#xA;      I18n.t(&quot;suscription_time_must_be_in_the_period&quot;)) if (self.fecha_inscripciones &lt; self.fecha_inicio or&#xD;&#xA;        self.fecha_inscripciones > self.fecha_fin)"/>
    <classElements xsi:type="rails:OperationsChain" name="and (self.periodo_id.nil?)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_accumulated_score"/>
    <classElements xsi:type="rails:OperationsChain" name="materia"/>
  </rubyClasses>
  <rubyClasses name="Permiso" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":perfiles" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="return &quot;#{self.menu}/#{self.submenu} - #{self.controlador}/#{self.accion}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="PersonConfiguration" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":person" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="include BCrypt after_save :check_email_validation"/>
    <classElements xsi:type="rails:RubyMethod" name="compare_validation_token"/>
    <classElements xsi:type="rails:OperationsChain" name="Password.new(Base64.decode64(token))">
      <operators>==</operators>
      <operants>&quot;#{self.id},#{self.person.id},#{self.person.usuario.id},#{self.person.e_mail.downcase}&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_email_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.email_copy">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operants>self.person.usuario self.email_validation</operants>
      <operants>'pending' self.send(:update_without_callbacks) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.set_email_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="school">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.get_school_id person_config_ids</operants>
      <operants>PersonConfiguration. person_usuario_colegio_id_equals(school.id). email_validation_equals('no').email_copy_equals(true). all(:select=> 'person_configurations.id').map(&amp;:id) PersonConfiguration.id_equals(person_config_ids).update_all(:email_validation=>'pending') end protected</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="check_email_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.email_copy">
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operants>self.email_validation</operants>
      <operants>'no' set_email_validation end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end end"/>
  </rubyClasses>
  <rubyClasses name="Persona" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="serialize :social_situation"/>
    <classElements xsi:type="rails:OperationsChain" name="serialize :disability"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="has_attached_file :photo, :styles => {:default=> [&quot;170x170>&quot;,'jpg'],:thumb=>['100x100','jpg'],:mini_thumb=>'40x40'  }, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;    :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;    :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;  },:s3_permissions => :private, :bucket => AWS_S3_SECURE['bucket_name'], :s3_protocol=> :https, :path => &quot;schools/:school_id/:class/photo/:id/:style_:filename&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :photo, :content_type=>['image/jpg', 'image/jpeg','image/pjpeg',&#xA;    'image/tiff','image/png','image/gif'], :message => I18n.t(:person_photo_format_no_valid) validates_attachment_size :photo, :less_than => 1.megabyte, :message => I18n.t(:person_photo_size_no_valid) attr_accessor :current_tab, :type_eps, :e_mail_required, :skip_email_validation"/>
    <classElements xsi:type="rails:Relationship" name=":administrador" relationType="has_one">
      <options key=":conditions" value="['administradores.colegio_id = #{Persona.get_school || self.colegio_id} and administradores.activo=1']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":docente" relationType="has_one">
      <options key=":conditions" value="['docentes.colegio_id = #{Persona.get_school || self.colegio_id} and docentes.activo=1']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":estudiante" relationType="has_one">
      <options key=":conditions" value="['estudiantes.colegio_id = #{Persona.get_school || self.colegio_id} and estudiantes.activo=1']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":graduate" relationType="has_one">
      <options key=":conditions" value="['graduates.school_id = #{Persona.get_school || self.colegio_id} and graduates.active=1']"/>
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="Graduate"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":transporter" relationType="has_one">
      <options key=":conditions" value="['transporters.colegio_id = #{Persona.get_school || self.colegio_id} and transporters.active=1']"/>
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="Transporter"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":usuario" relationType="has_one">
      <options key=":conditions" value="['usuarios.colegio_id = #{Persona.get_school || self.colegio_id}']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":user_for_support" relationType="has_one">
      <options key=":class_name" value="Usuario"/>
      <options key=":foreign_key" value="persona_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":user" relationType="has_one">
      <options key=":class_name" value="Usuario"/>
      <options key=":foreign_key" value="persona_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":person_configuration" relationType="has_one">
      <options key=":foreign_key" value="person_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":acudiente" relationType="has_one">
      <options key=":conditions" value="['acudientes.colegio_id = #{Persona.get_school || self.colegio_id} and acudientes.activo=1']"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":medical_background" relationType="has_one">
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="MedicalBackground"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":medical_test" relationType="has_one">
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="MedicalTest"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":boletines" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":resultados" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":health_histories" relationType="has_many">
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="HealthHistory"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":studies" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":work_experiences" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :estudiante"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :acudiente"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :docente"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :usuario, :reject_if => Proc.new { |attr| !attr[:perfil_ids].blank? }"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :health_histories, :reject_if => proc { |attrs| attrs.deep_empty? }"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :medical_background"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :person_configuration"/>
    <classElements xsi:type="rails:Relationship" name=":valores" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":notificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":ciudad" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":comuna" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":birth_city" relationType="belongs_to">
      <options key=":class_name" value="Ciudad"/>
      <options key=":foreign_key" value="ciudad_nac_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":expedition_place_city" relationType="belongs_to">
      <options key=":class_name" value="Ciudad"/>
      <options key=":foreign_key" value="expedition_place_city_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":pais" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":departamento" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":tipo_documento" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":student_subject_revisions" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":bus_paths" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":transporter" relationType="has_one">
      <options key=":foreign_key" value="person_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":appointments" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":persona_blocks" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":blocks" relationType="has_many">
      <options key=":through" value=":persona_blocks"/>
      <options key=":class_name" value="Block"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":binarios" relationType="has_and_belongs_to_many">
      <options key=":conditions" value="{:state => Binario::ESTADO_ACTIVO}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student_logs" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":cambio_estado" relationType="has_one">
      <options key=":foreign_key" value="persona_id"/>
      <options key=":class_name" value="StudentLog"/>
      <options key=":order" value="id DESC"/>
      <options key=":conditions" value="state IS NOT NULL"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :apellido"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :tipo_documento_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :identificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :fecha_nacimiento"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :e_mail, :maximum => 250, :if => :e_mail"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :e_mail, :if=>Proc.new{|obj| obj.e_mail_required or obj.usuario }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :telefono"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :celular, :if=>Proc.new{|o| o.id.blank? || (o.celular_was.present?)}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :direccion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :colegio_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :identificacion, :message => I18n.t(&quot;identification_already_exists&quot;), :scope => [:colegio_id, :activo], :if => :activo"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :e_mail, :message=> I18n.t(&quot;email_already_exists&quot;), :if => Proc.new{|obj| !obj.e_mail.blank? &amp;&amp; obj.activo }, :scope => [:colegio_id, :activo]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :telefono, :maximum => 30, :if => :telefono"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :nombre, :maximum => 250, :if => :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :apellido, :maximum => 250, :if => :apellido"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :identificacion, :maximum => 250, :if => :identificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :direccion, :maximum => 250, :if => :direccion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :identificacion, :with => /^[A-Za-z0-9\-]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="NAME_VALIDATOR">
      <operators>=</operators>
      <operants>/^[A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;\-\.\/']*\z/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="NAME_INVERSE_VALIDATOR">
      <operators>=</operators>
      <operants>/[^A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;\-\.\/']*/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :nombre, :apellido, :second_nombre, :second_apellido, :emergency_contact_name, :with => NAME_VALIDATOR , :message=> 'Tiene caracteres no v&#xe1;lidos'"/>
    <classElements xsi:type="rails:OperationsChain" name="MOBILE_PHONE_VALIDATOR">
      <operators>=</operators>
      <operants>/^3([01][0-9]|2[0-4]|50)[0-9]{7}\z/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :celular, :with => MOBILE_PHONE_VALIDATOR , :if=>Proc.new{|o| o.celular.present? &amp;&amp; o.celular != o.celular_was}, :message => 'Formato no v&#xe1;lido. Se esperaba (3XXXXXXXXX)'"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :direccion, :with => /^[A-Z a-z 0-9 \/&#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;&#xb0;&#xba; #\-\.(),]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="E_MAIL_VALIDATOR">
      <operators>=</operators>
      <operants>/^[A-Z0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}$/i</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :e_mail, :with => E_MAIL_VALIDATOR, :unless=>Proc.new{|obj| obj.e_mail.blank? }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :puntaje_sisben, :if => :puntaje_sisben"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_fecha, :if=>:fecha_nacimiento"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_genero"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school, :on => :create"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :assigment_new_user, :on => :update"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_full_name"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :strip_identification"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :set_email_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :email_validated, lambda { |param|&#xA;    hash = {&#xA;      :joins=>&quot;LEFT OUTER JOIN person_configurations AS person_configs ON personas.id = person_configs.person_id LEFT OUTER JOIN usuarios AS users ON personas.id = users.persona_id&quot;&#xA;    }&#xA;    if param == 'enabled'&#xA;      hash[:conditions] = &quot;person_configs.email_validation = 'ok' &quot;&#xA;    elsif param == 'disabled'&#xA;      hash[:conditions] = &quot;person_configs.email_copy = 0 OR users.id IS NULL&quot;&#xA;    elsif param == 'not_validated'&#xA;      hash[:conditions] = &quot;person_configs.email_validation in ('pending', 'sent') AND person_configs.email_copy = 1 &quot;&#xA;    end&#xA;    hash&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :with_students_course, {&#xA;    :joins=> &quot;LEFT OUTER JOIN estudiantes ON personas.id = estudiantes.persona_id \&#xA;    LEFT OUTER JOIN course_students ON course_students.student_id = estudiantes.id AND course_students.current_sign_up= 1 \&#xA;    LEFT OUTER JOIN  cursos ON cursos.id = course_students.course_id  \&#xA;    LEFT OUTER JOIN  grades ON grades.id = cursos.grade_id&quot;,&#xA;    :select => &quot;personas.id, personas.full_name, personas.identificacion, CONCAT(grades.name, ' ',cursos.nombre) AS course_name&quot;&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_full_name, lambda { |param|&#xA;    param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xA;    if param.count == 1&#xA;      param =  param*3&#xA;      sql = '(personas.full_name Like ?) OR (personas.identificacion Like ? ) OR (personas.e_mail like ? )'&#xA;    else&#xA;      sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xA;    end&#xA;    param.insert(0,sql)&#xA;    {&#xA;      :conditions => param ,&#xA;      :joins=> {}} }"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $!, :error, 10000</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="strip_identification"/>
    <classElements xsi:type="rails:OperationsChain" name="self.identificacion">
      <operators>=</operators>
      <operants>self.identificacion.to_s.strip end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id end"/>
    <classElements xsi:type="rails:RubyMethod" name="edad"/>
    <classElements xsi:type="rails:OperationsChain" name="begin age">
      <operators>=</operators>
      <operators>-</operators>
      <operators>-=</operators>
      <operators>&lt;</operators>
      <operants>fecha.year</operants>
      <operants>self.fecha_nacimiento.year age</operants>
      <operants>1 if fecha.to_date</operants>
      <operants>(self.fecha_nacimiento + age.years).to_date return age rescue logger.exc return 0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="antiguedad"/>
    <classElements xsi:type="rails:OperationsChain" name="begin age">
      <operators>=</operators>
      <operators>-</operators>
      <operators>-=</operators>
      <operators>&lt;</operators>
      <operants>fecha.year</operants>
      <operants>docente.date_of_ingress.year age</operants>
      <operants>1 if fecha.to_date</operants>
      <operants>(docente.date_of_ingress + age.years).to_date return age rescue logger.exc return 0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="full_name_capital"/>
    <classElements xsi:type="rails:OperationsChain" name="nombre_completo">
      <operators>=</operators>
      <operators>=</operators>
      <operants>(self.apellido.to_s.capitalize+' '+self.second_apellido.to_s.capitalize+' '+self.nombre.to_s.capitalize+' '+self.second_nombre.to_s.capitalize) self.full_name</operants>
      <operants>nombre_completo end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_full_name"/>
    <classElements xsi:type="rails:OperationsChain" name="nombre_completo">
      <operators>=</operators>
      <operators>=</operators>
      <operants>(self.apellido.to_s+' '+self.second_apellido.to_s+' '+self.nombre.to_s+' '+self.second_nombre.to_s).accents_downcase nombre_completo.gsub!('  ',' ') self.full_name</operants>
      <operants>nombre_completo.strip end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="assigment_new_user"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.usuario and self.e_mail">
      <operators>!=</operators>
      <operators>=</operators>
      <operants>self.e_mail_was self.usuario.nombre</operants>
      <operants>self.e_mail end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validar_fecha"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.fecha_nacimiento">
      <operators>&lt;</operators>
      <operants>Date.current self.errors.add(:fecha_nacimiento,I18n.t(&quot;invalid_birth_date&quot;)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validar_genero"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.sexo">
      <operators>==</operators>
      <operants>nil self.errors.add(:sexo,I18n.t(&quot;activerecord.errors.messages.blank&quot;)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.departamento">
      <operators>=</operators>
      <operators>!</operators>
      <operators>=</operators>
      <operators>!</operators>
      <operants>self.ciudad.departamento if</operants>
      <operants>self.departamento and self.ciudad self.pais</operants>
      <operants>self.ciudad.departamento.pais if</operants>
      <operants>self.pais and self.ciudad end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.apellido} #{self.second_apellido.to_s} #{self.nombre} #{self.second_nombre.to_s}&quot;.accents_downcase.titleize end"/>
    <classElements xsi:type="rails:RubyMethod" name="ciudad_fecha_na"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.ciudad_nac.nombre} #{self.fecha_nacimiento.strftime(&quot;%b, %d de %Y&quot;)}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="ubicacion"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.ciudad.to_s}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="ubicacion_nacimiento"/>
    <classElements xsi:type="rails:OperationsChain" name="Ciudad.find(self.ciudad_nac_id).nombre end"/>
    <classElements xsi:type="rails:RubyMethod" name="nombre_completo"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.apellido} #{self.second_apellido.to_s} #{self.nombre} #{self.second_nombre.to_s}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="nombre_ordenado"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.nombre} #{self.second_nombre.to_s} #{self.apellido} #{self.second_apellido.to_s}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="apellidos"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.apellido} #{self.second_apellido.to_s}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="nombres"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.nombre} #{self.second_nombre.to_s}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_disability"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.medical_background if self.medical_background.disability['0']"/>
    <classElements xsi:type="rails:OperationsChain" name="and self.medical_background.disability['0']">
      <operators>==</operators>
      <operators>=</operators>
      <operants>'Otra' discapacidad</operants>
      <operants>self.medical_background.disability['1']</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="elsif self.medical_background.disability['1']">
      <operators>!=</operators>
      <operators>=</operators>
      <operants>&quot;&quot; discapacidad</operants>
      <operants>self.medical_background.disability['1']</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="else discapacidad">
      <operators>=</operators>
      <operants>self.medical_background.disability['0']</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end else discapacidad">
      <operators>=</operators>
      <operants>'' end return discapacidad end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.discapacidad"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Auditiva'],&#xA;      ['Visual'],&#xA;      ['Motora'],&#xA;      ['Cognitiva'],&#xA;      ['Autismo'],&#xA;      ['Multiple'],&#xA;      ['Otra']] end"/>
    <classElements xsi:type="rails:RubyMethod" name="autocomplete_name"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.identificacion} - #{self.apellido} #{self.nombre}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>||=</operators>
      <operants>GestorUsuario.obtener_colegio end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.full_name">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.full_name.remove_accents self.send(:update_without_callbacks) self.created_by</operants>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true if self.activo.nil? end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.full_name">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.full_name.remove_accents self.send(:update_without_callbacks) self.updated_by</operants>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="boletin"/>
    <classElements xsi:type="rails:OperationsChain" name="self.boletines.periodo_id_equals(periodo_id).first end"/>
    <classElements xsi:type="rails:RubyMethod" name="crear_usuario"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.usuario nombre_default">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operators>+=</operators>
      <operators>=</operators>
      <operants>self.e_mail usuario_existente</operants>
      <operants>Usuario.find_by_nombre(nombre_default) i</operants>
      <operants>1 while usuario_existente nombre_default</operants>
      <operants>self.e_mail</operants>
      <operants>&quot;.&quot;</operants>
      <operants>i.to_s usuario_existente</operants>
      <operants>Usuario.find_by_nombre(nombre_default) i</operants>
      <operants>1 end usuario_nuevo</operants>
      <operants>Usuario.create(:nombre => nombre_default, :password => nombre_default,
        :password_confirmation => nombre_default, :activo => true, :persona_id => self.id,
        :created_by => GestorUsuario.obtener_usuario,:updated_by => GestorUsuario.obtener_usuario) raise &quot;Crear Usuario: Se present&#xf3; un error creando el usuario #{nombre_default}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="unless usuario_nuevo perfil_asignado">
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operants>Perfil.find_by_nombre(perfil) if perfil_asignado usuario_nuevo.perfiles</operants>
      <operants>perfil_asignado usuario_nuevo.save! else raise &quot;Crear Usuario: No existe ning&#xfa;n perfil de nombre #{perfil}&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_and_generate_sick_illness"/>
    <classElements xsi:type="rails:OperationsChain" name="health_histories">
      <operators>=</operators>
      <operants>self.health_histories.group_by(&amp;:sick_illness_id) sick_illness.each do |sick|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="health_histories[sick.id]">
      <operators>=</operators>
      <operants>[ self.health_histories.new(:sick_illness => sick)] unless health_histories[sick.id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end health_histories end"/>
    <classElements xsi:type="rails:RubyMethod" name="nueva_creacion_usuario"/>
    <classElements xsi:type="rails:OperationsChain" name="value_password">
      <operators>=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operants>Usuario.generate_random_string(3)</operants>
      <operants>self.identificacion self.build_usuario(:nombre => self.e_mail, :password => value_password,
      :password_confirmation => value_password, :activo => true,
      :created_by => GestorUsuario.obtener_usuario,:updated_by => GestorUsuario.obtener_usuario) self.usuario.perfil_ids</operants>
      <operants>[Perfil.profiles[:acudiente]] self.usuario.save end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_sisben_date"/>
    <classElements xsi:type="rails:OperationsChain" name="self.subscription_date_sisben_card">
      <operators>?</operators>
      <operators>: </operators>
      <operants>I18n.l(self.subscription_date_sisben_card, :format=>:bta_fecha)</operants>
      <operants>'' end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.find_by_autocomplete_name"/>
    <classElements xsi:type="rails:OperationsChain" name="self.identificacion_equals(name.split[0]). colegio_id_equals(GestorUsuario.obtener_colegio).last end"/>
    <classElements xsi:type="rails:RubyMethod" name="print_birthday"/>
    <classElements xsi:type="rails:OperationsChain" name="I18n.l(self.fecha_nacimiento,:format => :bta_fecha) end"/>
    <classElements xsi:type="rails:RubyMethod" name="gender"/>
    <classElements xsi:type="rails:OperationsChain" name="case self.sexo when true return I18n.t(:male) when false return I18n.t(:female) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="deceased"/>
    <classElements xsi:type="rails:OperationsChain" name="self.is_dead">
      <operators>?</operators>
      <operators>: </operators>
      <operants>I18n.t(:yes)</operants>
      <operants>I18n.t(:no) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="city_live"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.birth_city return self.birth_city.name_city elsif self.birth_city return &quot;#{I18n.t('foreign_city')} - #{self.other_birth_city}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="else return ''"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="city_expedition"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.expedition_place_city return self.expedition_place_city.name_city elsif self.expedition_place_city return &quot;#{I18n.t('foreign_city')} - #{self.expedition_place_city_foreign}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="else return ''"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="ciudad_nacimiento"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.birth_city return self.birth_city.to_s elsif">
      <operators>!</operators>
      <operants>self.other_birth_city.blank? return self.other_birth_city else return ''</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="ciudad_residencia"/>
    <classElements xsi:type="rails:OperationsChain" name="self.ciudad">
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.ciudad.to_s</operants>
      <operants>&quot;&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_expedition_place"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.expedition_place_city return self.expedition_place_city.to_s elsif self.expedition_place_city_foreign return &quot;#{I18n.t('foreign_city')} - #{self.expedition_place_city_foreign}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="else return ''"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="define_profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="return if @defining_profiles @defining_profiles">
      <operators>=</operators>
      <operators>=</operators>
      <operants>true if self.usuario profiles</operants>
      <operants>[] Perfil.get_relationships_profiles.each do |relationship,profile_id|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if(self.send(relationship))"/>
    <classElements xsi:type="rails:OperationsChain" name="profiles">
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operants>profile_id end end if profiles.any? unless profiles.sort</operants>
      <operants>self.usuario.perfil_ids.sort self.usuario.perfil_ids</operants>
      <operants>(self.usuario.perfil_ids+profiles).uniq self.usuario.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="logger.error &quot;#{self.usuario.nombre} saved with profiles #{self.usuario.perfil_ids.join(' , ')}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.situacion_social"/>
    <classElements xsi:type="rails:OperationsChain" name="[['Desplazado'],&#xA;      ['Hijo de desmovilizado']] end"/>
    <classElements xsi:type="rails:RubyMethod" name="living_city"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.ciudad return self.ciudad.to_s elsif self.ciudad.to_s return self.foreign_city.to_s else return ''"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_rh_person"/>
    <classElements xsi:type="rails:OperationsChain" name="rh_array">
      <operators>=</operators>
      <operants>(Estudiante::tipo_rh()).detect{|valor| valor.at(1)==self.rh}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="rh_array">
      <operators>?</operators>
      <operators>: </operators>
      <operants>rh_array.at(0)</operants>
      <operants>&quot;&quot; end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_illnesess"/>
    <classElements xsi:type="rails:OperationsChain" name="self.medical_background">
      <operators>?</operators>
      <operators>: </operators>
      <operants>self.medical_background.illnesses</operants>
      <operants>nil end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="fill_default_data"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.warn(&quot;DEPRECATED: Persona#fill_default_data&quot;) self.tipo_documento_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operants>1 if self.tipo_documento_id.blank? self.fecha_nacimiento</operants>
      <operants>30.years.ago if self.fecha_nacimiento.blank? self.ciudad_id</operants>
      <operants>Ciudad.nombre_like('bogota').last.id if self.ciudad_id.blank? self.telefono</operants>
      <operants>self.colegio.telefono if self.telefono.blank? self.celular</operants>
      <operants>self.colegio.telefono_movil if self.celular.blank? if self.e_mail.blank? school_domain</operants>
      <operants>self.colegio.e_mail.split('@').last email</operants>
      <operants>(self.apellido.to_s+' '+self.second_apellido.to_s+' '+self.nombre.to_s+' '+self.second_nombre.to_s).accents_downcase.remove_accents. gsub(/ +/,' ').strip.gsub(' ','.') counter</operants>
      <operants>Persona.e_mail_begins_with(email).e_mail_like(&quot;@#{school_domain}&quot;).count unless counter</operants>
      <operants>0 email</operants>
      <operants>email</operants>
      <operants>(&quot;%02d&quot;%(counter+1)) end self.e_mail</operants>
      <operants>email</operants>
      <operants>&quot;@#{school_domain}&quot; end self.sexo</operants>
      <operants>true if self.sexo.nil? end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_email_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.e_mail">
      <operators>!=</operators>
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.e_mail_was</operants>
      <operants>self.usuario config</operants>
      <operants>self.get_config config.person</operants>
      <operants>self config.set_email_validation end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_config"/>
    <classElements xsi:type="rails:OperationsChain" name="self.person_configuration">
      <operators>||</operators>
      <operants>self.create_person_configuration end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.migrate_photos"/>
    <classElements xsi:type="rails:OperationsChain" name="self.temp_photo_url_not_blank.find_each(:batch_size=> 100) do |object|"/>
    <classElements xsi:type="rails:OperationsChain" name="file_png">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>'' begin file_png</operants>
      <operants>File.join(RAILS_ROOT, 'tmp', &quot;#{object.photo_file_name}&quot;) command</operants>
      <operants>&quot;curl '#{object.temp_photo_url}' > #{file_png}&quot; logger.info(&quot;Executing: #{command}&quot;) resultado</operants>
      <operants>'' IO.popen(command, &quot;r+&quot;) do |pipe|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="resultado">
      <operators>&lt;&lt;</operators>
      <operators>=</operators>
      <operants>pipe.read end logger.info(&quot;Result: #{resultado}&quot;) object.photo</operants>
      <operants>File.open(file_png, 'rb') object.save! logger.warn &quot;Persona #{object.id} saved&quot;</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="rescue logger.error &quot;Persona #{object.id} fails&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.exc ensure File.delete(file_png) rescue logger.exc end end end end"/>
  </rubyClasses>
  <rubyClasses name="PersonaBlock" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":block" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Place" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":headquarter" relationType="belongs_to">
      <options key=":class_name" value="Headquarter"/>
      <options key=":foreign_key" value="headquarter_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":place" relationType="has_one"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :name, :maximum => 64"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :description, :maximum => 1024, :if=> :description"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.school_id</operants>
      <operants>GestorUsuario.obtener_colegio end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.headquarter">
      <operators>?</operators>
      <operators>: </operators>
      <operants>&quot;#{self.name} - #{self.headquarter.name}&quot;</operants>
      <operants>self.name end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Plantilla" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.nombre end end"/>
  </rubyClasses>
  <rubyClasses name="Pregunta" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":binario" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":categoria" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":allocation" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":question_type" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":opciones" relationType="has_many">
      <options key=":conditions" value="{:active => true}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":respuestas" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :text"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :question_type_id"/>
    <classElements xsi:type="rails:OperationsChain" name="if AWS_S3_SECURE has_attached_file :picture, :styles => {:default=> [&quot;527x300>&quot;] }, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key'] &#xA;    }, :bucket => AWS_S3_SECURE['bucket_name']"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :picture, :content_type=>['image/jpeg','image/jpeg',&#xA;      'image/tiff','image/png','image/gif'], :message => I18n.t(:question_picture_format_no_valid) validates_attachment_size :picture, :less_than => 1.megabyte, :message => I18n.t(:question_picture_format_no_valid) end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.opciones.blank? if self.question_type_id">
      <operators>==</operators>
      <operators>==</operators>
      <operators>==</operators>
      <operators>==</operators>
      <operants>QuestionType::RANGO Opcion.create(:text => &quot;Totalmente en desacuerdo&quot;,:value => 1,:pregunta_id => self.id) Opcion.create(:text => &quot;En desacuerdo&quot;,:value => 2,:pregunta_id => self.id) Opcion.create(:text => &quot;Ni de acuerdo ni en desacuerdo&quot;,:value => 3,:pregunta_id => self.id) Opcion.create(:text => &quot;De acuerdo&quot;,:value => 4,:pregunta_id => self.id) Opcion.create(:text => &quot;Totalmente de acuerdo&quot;,:value => 5,:pregunta_id => self.id) elsif self.question_type_id</operants>
      <operants>QuestionType::VERDADEROFALSO Opcion.create(:text => &quot;Verdadero&quot;,:value => 1,:pregunta_id => self.id) Opcion.create(:text => &quot;Falso&quot;,:value => 0,:pregunta_id => self.id) elsif self.question_type_id</operants>
      <operants>QuestionType::FRECUENCIA Opcion.create(:text => &quot;Siempre&quot;,:value => 1,:pregunta_id => self.id) Opcion.create(:text => &quot;Casi siempre&quot;,:value => 2,:pregunta_id => self.id) Opcion.create(:text => &quot;A veces&quot;,:value => 3,:pregunta_id => self.id) Opcion.create(:text => &quot;Casi nunca&quot;,:value => 4,:pregunta_id => self.id) Opcion.create(:text => &quot;Nunca&quot;,:value => 5,:pregunta_id => self.id) elsif self.question_type_id</operants>
      <operants>QuestionType::ESCALA_SATISFACCION Opcion.create(:text => &quot;Totalmente insatisfecho&quot;,:value => 1,:pregunta_id => self.id) Opcion.create(:text => &quot;Insatisfecho&quot;,:value => 2,:pregunta_id => self.id) Opcion.create(:text => &quot;Indiferente&quot;,:value => 3,:pregunta_id => self.id) Opcion.create(:text => &quot;Satisfecho&quot;,:value => 4,:pregunta_id => self.id) Opcion.create(:text => &quot;Totalmente satisfecho&quot;,:value => 5,:pregunta_id => self.id) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>||=</operators>
      <operators>||=</operators>
      <operants>GestorUsuario.obtener_usuario unless self.evaluacion_id self.evaluacion_id</operants>
      <operants>self.categoria.evaluacion_id if self.categoria end self.active</operants>
      <operants>true if self.active.nil? self.orden_variable</operants>
      <operants>(self.evaluacion.preguntas.
      maximum(:orden).to_i+1) self.orden</operants>
      <operants>self.orden_variable end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="transaction Opcion.pregunta_id_eq(self.id).update_all(:active => false) self.active">
      <operators>=</operators>
      <operants>false self.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="question_type_name"/>
    <classElements xsi:type="rails:OperationsChain" name="self.question_type.name end"/>
    <classElements xsi:type="rails:RubyMethod" name="categoria_name"/>
    <classElements xsi:type="rails:OperationsChain" name="self.categoria.name end"/>
    <classElements xsi:type="rails:RubyMethod" name="maximum_value"/>
    <classElements xsi:type="rails:OperationsChain" name="self.opciones.maximum(:value) end"/>
    <classElements xsi:type="rails:RubyMethod" name="clonar"/>
    <classElements xsi:type="rails:OperationsChain" name="clonada">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.clone clonada.copia</operants>
      <operants>true clonada.evaluacion_id</operants>
      <operants>evaluacion_id if self.picture.file? image_file</operants>
      <operants>File.join(RAILS_ROOT, 'tmp',
        &quot;book_thumb_#{self.picture_file_name}&quot;) url_request</operants>
      <operants>self.picture.expiring_url(300,:default) logger.error(&quot;url_request: #{url_request}&quot;) uri</operants>
      <operants>URI(url_request)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="response">
      <operators>=</operators>
      <operants>Net::HTTP.get_response(uri) File.open(image_file,'wb') do |file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="file.write response.body end clonada.picture">
      <operators>=</operators>
      <operators>||=</operators>
      <operators>+</operators>
      <operators>||=</operators>
      <operators>=</operators>
      <operants>File.new(image_file,&quot;r&quot;) end clonada.orden_variable</operants>
      <operants>self.evaluacion.preguntas.maximum(:orden).to_i</operants>
      <operants>1 clonada.orden</operants>
      <operants>clonada.orden_variable clonada.opciones</operants>
      <operants>self.opciones.map{|o| option_clone = o.clone; option_clone.pregunta_id = nil; option_clone}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clonada.save! clonada end"/>
    <classElements xsi:type="rails:RubyMethod" name="showable"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active and (&#xA;      (self.question_type_id != (QuestionType::OPCIONES)) or (&#xA;        self.question_type_id == (QuestionType::OPCIONES) and self.opciones.count >= 2&#xA;      )&#xA;    )"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.get_config_files"/>
    <classElements xsi:type="rails:OperationsChain" name="@config_files">
      <operators>||=</operators>
      <operants>YAML.load_file(&quot;#{RAILS_ROOT}/config/amazon_s3.yml&quot;) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_url_image"/>
    <classElements xsi:type="rails:OperationsChain" name="return nil unless self.url config">
      <operators>=</operators>
      <operants>Pregunta.get_config_files AWS::S3::Base.establish_connection!(
      :access_key_id=>config[ENV['RAILS_ENV']][&quot;access_key_id&quot;],
      :secret_access_key=>config[ENV['RAILS_ENV']][&quot;secret_access_key&quot;]
    ) AWS::S3::S3Object.url_for(self.url,
      config[ENV['RAILS_ENV']][&quot;bucket_name&quot;]
      #,
      #:expires_in=> 10,
      #:use_ssl => true
    ) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.text end"/>
    <classElements xsi:type="rails:RubyMethod" name="deep_clone"/>
    <classElements xsi:type="rails:OperationsChain" name="clone">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.clone(:include=>{:opciones=>{}}) if self.picture.file? clone.picture</operants>
      <operants>self.picture end clone end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="ProfilePermission" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":user_profile" relationType="belongs_to">
      <options key=":class_name" value="Perfil"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":permission_profile" relationType="belongs_to">
      <options key=":class_name" value="Perfil"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :editable_attribute, :scope => [:user_profile_id, :permission_profile_id, :colegio_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="ATTRIBUTES">
      <operators>=</operators>
      <operants>[
    &quot;full_name&quot;,
    &quot;identification&quot;,
    &quot;gender&quot;,
    &quot;e_mail&quot;,
    &quot;city_of_birth&quot;,
    &quot;birthday&quot;,
    &quot;citizenship&quot;,
    &quot;birthplace&quot;,
    &quot;marital_status&quot;,
    &quot;phone_number&quot;,
    &quot;address&quot;,
    &quot;celphone_number&quot;,
    &quot;city_of_residence&quot;,
    &quot;departamento_id&quot;,
    &quot;neighborhood&quot;,
    &quot;comuna&quot;,
    &quot;emergency_contact&quot;
  ]</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_or_generate_profile_permissions"/>
    <classElements xsi:type="rails:OperationsChain" name="prof_hash">
      <operators>=</operators>
      <operants>ProfilePermission.by_current_school.user_profile_id_equals(user_profile_id).group_by(&amp;:editable_attribute) ATTRIBUTES.each do |attribute|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if prof_hash[attribute]"/>
  </rubyClasses>
  <rubyClasses name="Programa" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":logros" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":indicadores" relationType="has_many">
      <options key=":through" value=":logros"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":calificaciones" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":study_plans" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :delete_attachment"/>
    <classElements xsi:type="rails:OperationsChain" name="if AWS_S3_SECURE has_attached_file :attachment, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;    },:s3_permissions => :private, :bucket => AWS_S3_SECURE['bucket_name']"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_size :attachment, :less_than => 1.megabyte, :message => I18n.t(:attachment_file_size_no_valid) end"/>
    <classElements xsi:type="rails:RubyMethod" name="calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="@calificacion">
      <operators>||=</operators>
      <operants>self.calificaciones.periodo_id_null().first end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="define_study_plans"/>
    <classElements xsi:type="rails:OperationsChain" name="self.materia.curso.periodo.periodos.each do |periodo|"/>
    <classElements xsi:type="rails:OperationsChain" name="self.study_plans.create(:periodo_id=>periodo.id) unless self.study_plans.detect{|s| s.periodo_id == periodo.id}"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="actividades"/>
    <classElements xsi:type="rails:OperationsChain" name="Actividad.indicador_logro_programa_id_equals(self.id) end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create unless self.asignatura Calificacion.create(:texto => self.texto,:peso => 0.00,:programa_id => self.id) for periodo in self.materia.curso.periodo.periodos Calificacion.create(:texto => self.texto,:peso => 0.00,:programa_id => self.id, :periodo_id => periodo.id) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="setup_scores"/>
    <classElements xsi:type="rails:OperationsChain" name="scores_by_period_id">
      <operators>=</operators>
      <operants>self.calificaciones.group_by(&amp;:periodo_id) for periodo in self.materia.curso.periodo.periodos unless scores_by_period_id[periodo.id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.calificaciones.create(:texto => self.texto,:peso => 0.00, &#xA;          :periodo_id => periodo.id) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="clonar"/>
    <classElements xsi:type="rails:OperationsChain" name="materia_destino">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Materia.id_equals(materia_id).first if materia_destino.programa clonada</operants>
      <operants>materia_destino.programa clonada.texto</operants>
      <operants>self.texto else clonada</operants>
      <operants>self.clone end clonada.copied</operants>
      <operants>true clonada.asignatura_id</operants>
      <operants>nil clonada.materia_id</operants>
      <operants>materia_id clonada.save! if clonada.calificacion and self.calificacion materia_destino.curso.periodo.periodos.each do |p|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="calificacion_periodo_destino">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>p.calificacion(clonada.id) calificacion_periodo_origen</operants>
      <operants>p.calificacion(self.id) if calificacion_periodo_destino and calificacion_periodo_origen calificacion_periodo_destino.peso</operants>
      <operants>calificacion_periodo_origen.peso calificacion_periodo_destino.save! end end end self.logros.each {|l| l.clonar(clonada)}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clonada end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="if delete_attachment">
      <operators>==</operators>
      <operators>=</operators>
      <operants>'true' self.attachment.clear end self.updated_by</operants>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="QualityQuestionnaire" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":assignment_people" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":people" relationType="has_many">
      <options key=":through" value=":assignment_people"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name, :final_date, :initial_date"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :name, :maximum => 50"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :setup_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :delete_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:final_date, &quot;No puede ser menor que la fecha inicial&quot;) if final_date">
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operators>&lt;</operators>
      <operants>initial_date</operants>
      <operants>final_date</operants>
      <operants>initial_date end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="delete_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="begin Questionnaire.find(self.questionnaire_id).destroy if self.questionnaire_id rescue logger.exc end end"/>
    <classElements xsi:type="rails:RubyMethod" name="setup_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.questionnaire_id.blank? begin @questionnaire">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Questionnaire.create(:name=> self.name) self.questionnaire_id</operants>
      <operants>@questionnaire.id self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="rescue ActiveResource::TimeoutError logger.exc end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_questionnaire_access"/>
    <classElements xsi:type="rails:OperationsChain" name="setup_questionnaire if self.questionnaire_id @questionnaire">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Questionnaire.find(self.questionnaire_id) @questionnaire.authentication_change</operants>
      <operants>'renew' @questionnaire.save @questionnaire end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.name end"/>
    <classElements xsi:type="rails:RubyMethod" name="questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.questionnaire_id @questionnaire">
      <operators>||=</operators>
      <operants>Questionnaire.find(self.questionnaire_id) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone"/>
    <classElements xsi:type="rails:OperationsChain" name="clone_object">
      <operators>=</operators>
      <operants>super(*args)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.name">
      <operators>=</operators>
      <operants>&quot;Copia de: #{self.name}&quot;[0..49]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.assignment_people">
      <operators>=</operators>
      <operants>self.assignment_people.map{|ap| AssignmentPerson.new(:person_id=>ap.person_id)}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.questionnaire_id">
      <operators>=</operators>
      <operants>self.clone_questionnaire if self.questionnaire clone_object end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="JSON.parse(self.questionnaire.post(:clone).body)['questionnaire']"/>
    <classElements xsi:type="rails:OperationsChain" name="['id'] end end"/>
  </rubyClasses>
  <rubyClasses name="QualityStudentQuestionnaire" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student_questionnaire_subjects" relationType="has_many">
      <options key=":dependent" value=":delete_all"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":subjects" relationType="has_many">
      <options key=":through" value=":student_questionnaire_subjects"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student_questionnaire_answer_sheets" relationType="has_many">
      <options key=":through" value=":student_questionnaire_subjects"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;    :conditions => {:school_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :setup_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :delete_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.name end"/>
    <classElements xsi:type="rails:RubyMethod" name="setup_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.questionnaire_id.blank? begin @questionnaire">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Questionnaire.create(:name=> self.name) self.questionnaire_id</operants>
      <operants>@questionnaire.id self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="@questionnaire rescue logger.exc end elsif questionnaire questionnaire.name">
      <operators>=</operators>
      <operants>self.name questionnaire.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.questionnaire_id begin @questionnaire">
      <operators>||=</operators>
      <operants>Questionnaire.find(self.questionnaire_id) rescue logger.exc nil end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="delete_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="begin Questionnaire.find(self.questionnaire_id).destroy if self.questionnaire_id rescue logger.exc end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_questionnaire_access"/>
    <classElements xsi:type="rails:OperationsChain" name="setup_questionnaire if self.questionnaire_id @questionnaire">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Questionnaire.find(self.questionnaire_id) @questionnaire.authentication_change</operants>
      <operants>'renew' @questionnaire.save @questionnaire end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone"/>
    <classElements xsi:type="rails:OperationsChain" name="clone_object">
      <operators>=</operators>
      <operants>super(*args)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.name">
      <operators>=</operators>
      <operants>&quot;Copia de: #{self.name}&quot;[0..49]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.student_questionnaire_subjects">
      <operators>=</operators>
      <operants>self.student_questionnaire_subjects.map{|scs| StudentQuestionnaireSubject.new(:subject_id=>scs.subject_id)}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.questionnaire_id">
      <operators>=</operators>
      <operants>self.clone_questionnaire if self.questionnaire clone_object end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="JSON.parse(self.questionnaire.post(:clone).body)['questionnaire']"/>
    <classElements xsi:type="rails:OperationsChain" name="['id'] end end"/>
  </rubyClasses>
  <rubyClasses name="QualityTeacherQuestionnaire" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":assignment_subjects" relationType="has_many">
      <options key=":dependent" value=":delete_all"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":subjects" relationType="has_many">
      <options key=":through" value=":assignment_subjects"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":teacher_questionnaire_answer_sheets" relationType="has_many">
      <options key=":through" value=":assignment_subjects"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.profiles"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{student parent}"/>
    <classElements xsi:type="rails:OperationsChain" name="end validates_inclusion_of :to_profile, :in => QualityTeacherQuestionnaire.profiles validates_presence_of :name, :final_date, :initial_date"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :name, :maximum => 50"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;  :conditions => {:school_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :setup_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :delete_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:final_date, &quot;No puede ser menor que la fecha inicial&quot;) if final_date">
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operators>&lt;</operators>
      <operants>initial_date</operants>
      <operants>final_date</operants>
      <operants>initial_date end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="setup_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.questionnaire_id.blank? begin @questionnaire">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Questionnaire.create(:name=> self.name) self.questionnaire_id</operants>
      <operants>@questionnaire.id self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="@questionnaire rescue logger.exc end elsif questionnaire questionnaire.name">
      <operators>=</operators>
      <operants>self.name questionnaire.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_questionnaire_access"/>
    <classElements xsi:type="rails:OperationsChain" name="setup_questionnaire if self.questionnaire_id @questionnaire">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Questionnaire.find(self.questionnaire_id) @questionnaire.authentication_change</operants>
      <operants>'renew' @questionnaire.save @questionnaire end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="delete_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="begin Questionnaire.find(self.questionnaire_id).destroy if self.questionnaire_id rescue logger.exc end end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.name end"/>
    <classElements xsi:type="rails:RubyMethod" name="questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.questionnaire_id begin @questionnaire">
      <operators>||=</operators>
      <operants>Questionnaire.find(self.questionnaire_id) rescue logger.exc nil end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone"/>
    <classElements xsi:type="rails:OperationsChain" name="clone_object">
      <operators>=</operators>
      <operants>super(*args)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.name">
      <operators>=</operators>
      <operants>&quot;Copia de: #{self.name}&quot;[0..49]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.assignment_subjects">
      <operators>=</operators>
      <operants>self.assignment_subjects.map{|as| AssignmentSubject.new(:subject_id=>as.subject_id)}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_object.questionnaire_id">
      <operators>=</operators>
      <operants>self.clone_questionnaire if self.questionnaire clone_object end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone_questionnaire"/>
    <classElements xsi:type="rails:OperationsChain" name="JSON.parse(self.questionnaire.post(:clone).body)['questionnaire']"/>
    <classElements xsi:type="rails:OperationsChain" name="['id'] end end"/>
  </rubyClasses>
  <rubyClasses name="QuestionType" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":preguntas" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="ABIERTA">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 OPCIONES</operants>
      <operants>2 RANGO</operants>
      <operants>3 VERDADEROFALSO</operants>
      <operants>4 LLENAR_ESPACIOS</operants>
      <operants>5 FECHA</operants>
      <operants>6 OPCIONES_MULTIPLE</operants>
      <operants>7 FRECUENCIA</operants>
      <operants>8 ESCALA_SATISFACCION</operants>
      <operants>9</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.active</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.has_options"/>
    <classElements xsi:type="rails:OperationsChain" name="@@options_types">
      <operators>||=</operators>
      <operants>[QuestionType::OPCIONES,
      QuestionType::RANGO, QuestionType::OPCIONES_MULTIPLE, 
      QuestionType::VERDADEROFALSO, QuestionType::FRECUENCIA,
      QuestionType::ESCALA_SATISFACCION
    ] @@options_types.include?(item.question_type_id) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.has_options_unique_answer"/>
    <classElements xsi:type="rails:OperationsChain" name="@@options_types">
      <operators>||=</operators>
      <operants>[QuestionType::OPCIONES, QuestionType::RANGO, 
      QuestionType::VERDADEROFALSO, QuestionType::FRECUENCIA, 
      QuestionType::ESCALA_SATISFACCION] @@options_types.include?(item.question_type_id) end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Rango" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":categoria" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="RenderTemplate" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name, :template_file_name"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :name, :maximum => 64"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :description, :maximum => 255, :allow_blank=>true if AWS_S3_SECURE has_attached_file :template, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;    },:s3_headers => {&quot;Content-Disposition&quot; => &quot;attachment&quot;}, :s3_permissions => :private, :bucket => AWS_S3_SECURE['bucket_name']"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_presence :template, :message=> t('not_xml_file')"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :template, :content_type => 'text/xml', :message=> t('not_xml_format_file')"/>
    <classElements xsi:type="rails:OperationsChain" name="end named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="WORDNAMESPACE">
      <operators>=</operators>
      <operants>{'wpc'=>&quot;http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas&quot;     , 'mc'=>&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; ,
    'o'=>&quot;urn:schemas-microsoft-com:office:office&quot;     , 'r'=>&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships&quot;     ,
    'm'=>&quot;http://schemas.openxmlformats.org/officeDocument/2006/math&quot; , 'v'=>&quot;urn:schemas-microsoft-com:vml&quot;     ,
    'wp14'=>&quot;http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing&quot;     , 'wp'=>&quot;http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing&quot;     ,
    'w10'=>&quot;urn:schemas-microsoft-com:office:word&quot;     , 'w'=>&quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;     ,
    'w14'=>&quot;http://schemas.microsoft.com/office/word/2010/wordml&quot;     , 'wpg'=>&quot;http://schemas.microsoft.com/office/word/2010/wordprocessingGroup&quot;     ,
    'wpi'=>&quot;http://schemas.microsoft.com/office/word/2010/wordprocessingInk&quot;    , 'wne'=>&quot;http://schemas.microsoft.com/office/word/2006/wordml&quot;  ,
    'wps'=>&quot;http://schemas.microsoft.com/office/word/2010/wordprocessingShape&quot;}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="TYPE_OLD_STUDENT_CERTIFICATION">
      <operators>=</operators>
      <operators>=</operators>
      <operants>'old_students_certification' TYPE_STUDENT_CERTIFICATION</operants>
      <operants>'students_certification'</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.get_types"/>
    <classElements xsi:type="rails:OperationsChain" name="@@types">
      <operators>||=</operators>
      <operants>self.constants.select(){|a| a.match('^TYPE_')}</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="ResetPasswordInformation" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":user" relationType="belongs_to">
      <options key=":class_name" value="Usuario"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :token, :user_id"/>
    <classElements xsi:type="rails:RubyMethod" name="token_valid?"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_at">
      <operators>||=</operators>
      <operators>></operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operants>DateTime.current self.created_at</operants>
      <operants>12.hours.ago</operants>
      <operants>self.user.reset_password_informations.last.id</operants>
      <operants>self.id end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Response" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":task" relationType="belongs_to">
      <options key=":foreign_key" value="task_id"/>
      <options key=":class_name" value="AsyncTask"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":binary" relationType="belongs_to">
      <options key=":class_name" value="Binario.name end"/>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Respuesta" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="serialize :arreglo"/>
    <classElements xsi:type="rails:Relationship" name=":resultado" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":pregunta" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":opcion" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :question_type_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :comments, :maximum => 512, :allow_nil => true"/>
    <classElements xsi:type="rails:RubyMethod" name="get_text"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.pregunta.question_type_id">
      <operators>==</operators>
      <operators>==</operators>
      <operants>QuestionType::ABIERTA return self.valor elsif QuestionType.has_options_unique_answer(self.pregunta) return self.opcion.text rescue nil elsif self.pregunta.question_type_id</operants>
      <operants>QuestionType::LLENAR_ESPACIOS (self.arreglo||[])</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Resultado" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":asignacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":allocation" relationType="belongs_to">
      <options key=":class_name" value="VariableAssignment"/>
      <options key=":foreign_key" value="variable_assignment_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to">
      <options key=":class_name" value="Materia"/>
      <options key=":foreign_key" value="materia_survey_teacher_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":respuestas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":performance_result" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":graduate" relationType="has_one">
      <options key=":foreign_key" value="answer_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":sign_up" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":valor" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":variable_assignment" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":course_institution_survey" relationType="belongs_to">
      <options key=":class_name" value="Curso"/>
      <options key=":foreign_key" value="course_school_survey_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":course_survey" relationType="belongs_to">
      <options key=":class_name" value="Curso"/>
      <options key=":foreign_key" value="course_director_survey_course_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :respuestas"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :evaluacion_id, :message => I18n.t(&quot;Debe Seleccionar una Evaluaci&#xf3;n&quot;) validates_presence_of :persona_id, :message => I18n.t(&quot;Indique la persona a quien se le realiz&#xf3; la Evaluaci&#xf3;n&quot;) validates_length_of :concepto, :maximum => 512, :allow_nil => true validates_numericality_of :calificacion, :if => :validate_calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_score_range"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_score_date"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :for_current_user, lambda { {&#xA;      :conditions => {:persona_id => GestorUsuario.get_person_id,:colegio_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_score_date"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.evaluacion.calificacion">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operants>periodo</operants>
      <operants>self.evaluacion.calificacion.get_period if periodo.initial_registration_date_ratings</operants>
      <operants>periodo.fecha_calificaciones</operants>
      <operants>(periodo.fecha_calificaciones.end_of_day &lt; Time.now ||
            Time.now() &lt; periodo.initial_registration_date_ratings) self.errors.add(:calificacion, I18n.t(&quot;time_in_scores_is_over&quot;)) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_calificacion"/>
    <classElements xsi:type="rails:OperationsChain" name="return self.calificacion">
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operants>self.evaluacion.calificacion</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.evaluacion.calificacion.get_period. nil?">
      <operators>&amp;&amp;</operators>
      <operants>self.evaluacion.calificacion.get_topic.curso.periodo.escala_numerica end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_score_range"/>
    <classElements xsi:type="rails:OperationsChain" name="if validate_calificacion and (self.calificacion.to_f > self.evaluacion.calificacion.get_topic.curso.periodo.escala.get_maximum_numeric_value or&#xA;          self.calificacion.to_f &lt; self.evaluacion.calificacion.get_topic.curso.periodo.escala.get_minimum_numeric_value)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:calificacion, I18n.t(&quot;the_value_does_not_match_the_set_range&quot;)) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="create_answers"/>
    <classElements xsi:type="rails:OperationsChain" name="self.evaluacion.preguntas.ascend_by_orden.each do |pregunta|"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.respuestas.detect{|respuesta| respuesta.pregunta_id == pregunta.id}"/>
    <classElements xsi:type="rails:OperationsChain" name="self.respuestas.create(:pregunta=> pregunta) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_varible_assignment_same_period"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.variable_assignment_id and self.periodo_id end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_asignatura"/>
    <classElements xsi:type="rails:OperationsChain" name="self.materia.to_s end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_curso"/>
    <classElements xsi:type="rails:OperationsChain" name="self.materia.curso.to_s end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_area"/>
    <classElements xsi:type="rails:OperationsChain" name="self.materia.area.to_s end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_teacher"/>
    <classElements xsi:type="rails:OperationsChain" name="self.materia.docente.nombre_completo end"/>
    <classElements xsi:type="rails:RubyMethod" name="add_period"/>
    <classElements xsi:type="rails:OperationsChain" name="self.periodo_id">
      <operators>=</operators>
      <operants>periodo_id self.send(:update_without_callbacks) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.fecha">
      <operators>||=</operators>
      <operators>=</operators>
      <operants>Date.current self.colegio_id</operants>
      <operants>self.class.get_school end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_answer"/>
    <classElements xsi:type="rails:OperationsChain" name="@respuestas_by_question_hash">
      <operators>||=</operators>
      <operants>self.respuestas.group_by(&amp;:pregunta_id) begin @respuestas_by_question_hash[pregunta_id]</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SchoolConfig" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.advertisements"/>
    <classElements xsi:type="rails:OperationsChain" name="@@advertisements">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{none saberes external}"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.allow_migrations"/>
    <classElements xsi:type="rails:OperationsChain" name="@@allow_migrations">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{no yes}"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
  </rubyClasses>
  <rubyClasses name="SchoolKey" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.key_types"/>
    <classElements xsi:type="rails:OperationsChain" name="@@key_types">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{read-only}"/>
    <classElements xsi:type="rails:OperationsChain" name="end named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :api_key"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :api_secret"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :key_type"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_inclusion_of :key_type, :in => self.key_types before_validation :generate_keys"/>
    <classElements xsi:type="rails:RubyMethod" name="generate_keys"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.get_school() self.api_key</operants>
      <operants>SecureRandom.base64(20).gsub('/','!').gsub('=','#')[0..20]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.api_secret">
      <operators>=</operators>
      <operants>SecureRandom.base64(40).gsub('/','!').gsub('=','#')[0..40]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="logger.warn(&quot;API_KEY generated for school_id #{self.school_id}, key #{self.api_key}&quot;) end end"/>
  </rubyClasses>
  <rubyClasses name="ScoreStatistic" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":homologacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":course" relationType="belongs_to">
      <options key=":class_name" value="Curso"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":period" relationType="belongs_to">
      <options key=":class_name" value="Periodo"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school, :on => :create"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :school_id"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :set_average"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_homologacion_score"/>
    <classElements xsi:type="rails:OperationsChain" name="if homologacion_id self.relative_alfanumeric_score">
      <operators>+=</operators>
      <operants>((1000**(4-homologacion_id-1))*counter) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_average"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.counter">
      <operators>></operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>0 self.average_score</operants>
      <operants>self.sum else self.average_score</operants>
      <operants>nil end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $!, :error, 10000</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end end"/>
  </rubyClasses>
  <rubyClasses name="Section" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":grades" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":administrador" relationType="belongs_to">
      <options key=":foreign_key" value="admin_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name, :message => I18n.t(&quot;Ingrese el nombre&quot;) validates_presence_of :description, :message => I18n.t(&quot;Ingrese la descripci&#xf3;n&quot;) validates_length_of :description, :maximum=>1024, :if => :description"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.by_current_school"/>
    <classElements xsi:type="rails:OperationsChain" name="self.school_id_equals(self.get_school) end"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.name}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="Service" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":service_days" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":bus_paths" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":service_students" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :name"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 school</operants>
      <operants>Colegio.f(Persona.get_school) rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',
      &quot;#{self.to_s}.docentes_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin ActiveRecord::Base.transaction do nombre">
      <operators>=</operators>
      <operants>process_field(row[0])</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="ServiceDay" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":service" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":service_schedules" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :day"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :start_hour"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="unless self.service_schedules.first super else self.errors.add(:base, 'No se puede eliminar si tiene service_schedules') return false end end end"/>
  </rubyClasses>
  <rubyClasses name="ServiceSchedule" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":service_student" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":service_day" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":bus_path" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation_on_update :cleanup_addresses"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :set_service_student_state"/>
    <classElements xsi:type="rails:RubyMethod" name="clean="/>
    <classElements xsi:type="rails:OperationsChain" name="@clean">
      <operators>=</operators>
      <operators>=</operators>
      <operants>value self.updated_at</operants>
      <operants>DateTime.now end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="clean"/>
    <classElements xsi:type="rails:OperationsChain" name="@clean end"/>
    <classElements xsi:type="rails:RubyMethod" name="requested"/>
    <classElements xsi:type="rails:OperationsChain" name="self.requested_address">
      <operators>!=</operators>
      <operants>self.current_address end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="cleanup_addresses"/>
    <classElements xsi:type="rails:OperationsChain" name="if @clean">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operants>self.bus_path self.current_address</operants>
      <operants>self.requested_address end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="set_service_student_state"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.service_student.service_schedules.select{|s| s.service_day}"/>
  </rubyClasses>
  <rubyClasses name="ServiceStudent" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":service" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":student" relationType="belongs_to">
      <options key=":foreign_key" value="student_id"/>
      <options key=":class_name" value="Estudiante"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":service_schedules" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :service_schedules"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :service_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :student_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :service_id, :scope => :student_id"/>
    <classElements xsi:type="rails:OperationsChain" name="before_create :set_state"/>
    <classElements xsi:type="rails:OperationsChain" name="after_save :detect_state"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :request_disabled"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :student_active, lambda { {&#xA;      :conditions => [&quot;estudiantes.activo IS NOT NULL&quot;],&#xA;      :include=>{:estudiante=>{}}}}"/>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_creation_csv"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 school</operants>
      <operants>Colegio.f(Persona.get_school) rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',
      &quot;#{self.to_s}.docentes_csv_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin ActiveRecord::Base.transaction do estudiante">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Estudiante.code_equals(process_field(row[0]).gsub(&quot;'&quot;,'').gsub(&quot;.&quot;,'').gsub(' ','').gsub(',','')).last servicio</operants>
      <operants>Service.by_current_school.id_equals(row[1].to_i).first if estudiante and servicio service_student</operants>
      <operants>ServiceStudent.student_id_equals(estudiante.id).service_id_equals(servicio.id).last unless service_student service_student</operants>
      <operants>ServiceStudent.new() estado</operants>
      <operants>&quot;without_changes&quot; service_student.attributes</operants>
      <operants>{:student_id=>estudiante.id,
                  :service_id=>servicio.id, :state=>estado.to_s}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="service_student.save! if service_student.service_schedules.blank? service_student.service.service_days.each do |sd|"/>
    <classElements xsi:type="rails:OperationsChain" name="service_schedule">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>ServiceSchedule.new() service_schedule.service_student_id</operants>
      <operants>service_student.student_id service_schedule.service_day_id</operants>
      <operants>sd.id service_schedule.current_address</operants>
      <operants>service_student.student.persona.direccion service_schedule.requested_address</operants>
      <operants>service_student.student.persona.direccion ruta</operants>
      <operants>servicio.bus_paths.select{|b| b.plate.gsub(/[^a-zA-Z0-9]/,'')[0..5].upcase==(row[2].gsub(/[^a-zA-Z0-9]/,'')[0..5].upcase)}</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SickIllness" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":health_histories" relationType="has_many"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="SignUp" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":estudiante" relationType="belongs_to">
      <options key=":dependent" value=":destroy"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":resultado" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :estudiante"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :csv, :render_template_id, :render_academic_years_id, :render_academic_period_id"/>
    <classElements xsi:type="rails:OperationsChain" name="FILTER_DATA">
      <operators>=</operators>
      <operants>/[^A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;\-\.\/'#]*/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :name_string,"/>
    <classElements xsi:type="rails:OperationsChain" name="lambda"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_parents, lambda { |param| {&#xA;      :conditions => [&quot;estudiantes.acudiente_id = ? or estudiantes.madre_id = ?\&#xA;        or estudiantes.padre_id = ?&quot;, param,param,param] ,&#xA;      :include=> {:estudiante=>{}}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :with_route, lambda {|route| route.nil? ? {} : {&#xA;      :joins => &quot;LEFT JOIN service_students ss ON ss.student_id = `estudiantes`.id \&#xA;                 LEFT JOIN service_students ss2 ON ss2.student_id = `estudiantes`.id AND ss.id &lt; ss2.id&quot;,&#xA;      :conditions => &quot;ss2.id IS NULL AND &quot; + (route ? &quot;ss.id IS NULL&quot; : &quot;ss.id IS NOT NULL&quot;)}}"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_sign_up_estudiante_persona_parameters, lambda { |param|&#xA;    param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xA;    if param.count == 1&#xA;      param =  param*4&#xA;      sql = '(personas.full_name Like ?) OR (personas.identificacion Like ? ) OR (estudiantes.code Like ? ) OR (personas.e_mail like ?)'&#xA;    else&#xA;      sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xA;    end&#xA;    param.insert(0,sql)&#xA;    {&#xA;      :conditions => param ,&#xA;      :joins=> {}} }"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_name_or_code, lambda { |param|&#xA;      param = param.to_s.split.map{|subelement| &quot;%#{subelement.accents_downcase}%&quot;}&#xA;      param = param.map{|subelement| &quot;%#{subelement.gsub('.','')}%&quot;}&#xA;      if param.count == 1&#xA;        param =  param*2&#xA;        sql = '(personas.full_name Like ?) OR (estudiantes.code Like ? )'&#xA;      else&#xA;        sql = param.map {|element|   'personas.full_name Like ?' }.join(' AND ')&#xA;      end&#xA;      param.insert(0,sql)&#xA;      {&#xA;        :conditions => param,&#xA;        :include=> :estudiante&#xA;      }&#xA;    }"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :state, :csv"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end unless self.resultado_id if self.colegio.sign_up_test result</operants>
      <operants>Resultado.new result.colegio_id</operants>
      <operants>self.get_school result.evaluacion_id</operants>
      <operants>Colegio.find(self.get_school). sign_up_test.evaluacion_id result.persona_id</operants>
      <operants>GestorUsuario.get_person_id result.save self.resultado_id</operants>
      <operants>result.id end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="old_new"/>
    <classElements xsi:type="rails:OperationsChain" name="@courses">
      <operators>||=</operators>
      <operants>self.estudiante.course_students.curso_activo_equals(true).curso_electivo_equals(false).all end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>[&quot;student&quot;, &quot;father&quot;, &quot;mother&quot;, &quot;guardian&quot;, &quot;survey&quot;, &quot;sign_up&quot;,
      'transport_paths', &quot;nursing&quot;, &quot;end&quot;].freeze end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="is_preregistration?"/>
    <classElements xsi:type="rails:OperationsChain" name="return (self.estudiante.current_course_student.blank? or&#xA;        self.estudiante.current_course_student.curso.grade_id != self.estudiante.grade.id or&#xA;        self.estudiante.current_course_student.curso.periodo.fecha_inicio.year != self.year)"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states_two"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states_2">
      <operators>||=</operators>
      <operants>[&quot;student&quot;, &quot;father&quot;, &quot;mother&quot;, &quot;guardian&quot;,&quot;survey&quot;,'transport_paths', &quot;nursing&quot;, &quot;end&quot;].freeze end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.states_parents"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states_parents">
      <operators>||=</operators>
      <operants>[&quot;father&quot;, &quot;mother&quot;, &quot;guardian&quot;, &quot;end&quot;].freeze end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.batch_update"/>
    <classElements xsi:type="rails:OperationsChain" name="counter">
      <operators>=</operators>
      <operators>=</operators>
      <operants>1 rescue_file_path</operants>
      <operants>File.join(RAILS_ROOT,'tmp',&quot;#{self.to_s}.batch_update_#{Time.now.to_i.to_s}.csv&quot;) File.open(rescue_file_path,'w+') do |rescue_file|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="FasterCSV.foreach(filename) do |row|"/>
    <classElements xsi:type="rails:OperationsChain" name="begin student">
      <operators>=</operators>
      <operants>Estudiante.by_current_school.find_by_code(row[0].to_s.downcase.strip.gsub(',','')) raise('Estudiante no encontrada')</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="rescue_file.puts(row+['data_migrated', student.code]) rescue ActiveRecord::Base.logger.error &quot;No se pudo procesar l&#xed;nea #{counter}: #{row.to_a.join(',')}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.exc rescue_file.puts((row+['fail',$!.message]).map{|a| &quot;\&quot;#{a.to_s.gsub(',','')}\&quot;&quot;}.join(',')) end counter">
      <operators>+=</operators>
      <operants>1 end end rescue_file_path end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="persona"/>
    <classElements xsi:type="rails:OperationsChain" name="self.estudiante.persona end"/>
    <classElements xsi:type="rails:RubyMethod" name="parent_ids"/>
    <classElements xsi:type="rails:OperationsChain" name="self.estudiante.parent_ids end"/>
    <classElements xsi:type="rails:RubyMethod" name="current_course_student"/>
    <classElements xsi:type="rails:OperationsChain" name="self.estudiante.current_course_student end"/>
    <classElements xsi:type="rails:RubyMethod" name="estado"/>
    <classElements xsi:type="rails:OperationsChain" name="self.estudiante.estado end"/>
    <classElements xsi:type="rails:RubyMethod" name="grado_a_matricular"/>
    <classElements xsi:type="rails:OperationsChain" name="curso_actual_estudiante">
      <operators>=</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>==</operators>
      <operators>||</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.estudiante.current_course_student if curso_actual_estudiante.blank? grado</operants>
      <operants>self.estudiante.grade elsif curso_actual_estudiante.approved</operants>
      <operants>true grado</operants>
      <operants>Grade.by_current_school.level_equals(curso_actual_estudiante.curso.grade.level + 1).first elsif curso_actual_estudiante.approved</operants>
      <operants>false</operants>
      <operants>curso_actual_estudiante.approved</operants>
      <operants>nil grado</operants>
      <operants>curso_actual_estudiante.curso.grade else grado</operants>
      <operants>nil end return grado end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.process_field"/>
    <classElements xsi:type="rails:OperationsChain" name="field.to_s.gsub(',','').gsub('  ',' ').gsub('\f','').strip.gsub(FILTER_DATA,'') end end"/>
  </rubyClasses>
  <rubyClasses name="SignUpTest" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :evaluacion"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :colegio_id, :if => :active, :scope=>[:active,:test_type], :message => I18n.t(:you_can_have_only_one_active_test ) named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="initialize"/>
    <classElements xsi:type="rails:OperationsChain" name="super(args)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.build_evaluacion unless self.evaluacion end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_validation"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>=</operators>
      <operants>get_school end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.active">
      <operators>=</operators>
      <operants>false self.send(:update_without_callbacks) self.save! end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.types"/>
    <classElements xsi:type="rails:OperationsChain" name="@@types">
      <operators>||=</operators>
      <operants>['student','graduate'] end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SliceTemplate" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="attr_reader :content"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :slices"/>
    <classElements xsi:type="rails:RubyMethod" name="initialize"/>
    <classElements xsi:type="rails:OperationsChain" name="@content">
      <operators>=</operators>
      <operators>=</operators>
      <operants>File.read(filename) @slices</operants>
      <operants>{}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="parse end"/>
    <classElements xsi:type="rails:RubyMethod" name="initialize_copy"/>
    <classElements xsi:type="rails:OperationsChain" name="@content">
      <operators>=</operators>
      <operators>=</operators>
      <operants>other.content.clone @slices</operants>
      <operants>other.slices.clone end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod"/>
    <classElements xsi:type="rails:OperationsChain" name="[](slice_name)"/>
    <classElements xsi:type="rails:OperationsChain" name="@slices[slice_name]">
      <operators>=</operators>
      <operants>Slice.new(@slices[slice_name]) unless @slices[slice_name]</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SmtpConfigValidatorMailer" superType="ActionMailer::Base">
    <classElements xsi:type="rails:RubyMethod" name="mail"/>
    <classElements xsi:type="rails:OperationsChain" name="recipients Usuario.find(GestorUsuario.obtener_usuario).nombre subject &quot;Validaci&#xf3;n de configuraci&#xf3;n de servidor smtp&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="from smtp_server.user_name content_type &quot;text/plain&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="reply_to &quot;No responder &lt;#{smtp_server.user_name}>&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
  </rubyClasses>
  <rubyClasses name="SmtpServer" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="has_one"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :password_confirmation"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :user_name, :adress, :port, :password"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :port"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :password_confirmation, :unless => Proc.new {|object| object.password == object.password_was}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_confirmation_of :password, :unless => Proc.new {|object| object.password_confirmation.blank?}"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :correct_configuration"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="correct_configuration"/>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.warn(&quot;Using: #{self.inspect}&quot;) begin ActionMailer::Base.smtp_settings">
      <operators>=</operators>
      <operants>{:user_name => self.user_name,
        :tls => self.tls,
        :address => self.adress,
        :port => self.port,
        :authentication => (self.authentication || :login).to_sym,
        :password => self.password
      }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="ActiveRecord::Base.logger.warn(&quot;Using: #{ActionMailer::Base.smtp_settings}&quot;) SmtpConfigValidatorMailer.deliver_mail(self) rescue Timeout::Error"/>
    <classElements xsi:type="rails:OperationsChain" name="e ActiveRecord::Base.logger.exc errors.add(:adress, &quot;El servidor smtp y/o puerto no son v&#xe1;lidos&quot;) errors.add(:port, &quot;El servidor smtp y/o puerto no son v&#xe1;lidos&quot;) rescue Net::SMTPAuthenticationError"/>
    <classElements xsi:type="rails:OperationsChain" name="e ActiveRecord::Base.logger.exc errors.add(:user_name, &quot;El usuario y/o contrase&#xf1;a no son v&#xe1;lidos. \n Error interno: #{e.message}&quot;) errors.add(:password, &quot;El usuario y/o contrase&#xf1;a no son v&#xe1;lidos. \n Error interno: #{e.message}&quot;) rescue"/>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="e ActiveRecord::Base.logger.exc errors.add(:adress, &quot;Error en la configuraci&#xf3;n de servidor de correo. \n Error interno: #{e.message}&quot;) end end end"/>
  </rubyClasses>
  <rubyClasses name="SoldBook" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":book" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":school" relationType="belongs_to">
      <options key=":class_name" value="Colegio"/>
      <options key=":foreign_key" value="school_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":cursos" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :size_cuantity_and_students"/>
    <classElements xsi:type="rails:RubyMethod" name="size_cuantity_and_students"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.warn &quot;debug #{self.cursos.map(&amp;:id).join()} #{self.cuantity}&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="if">
      <operators>!</operators>
      <operators>>=</operators>
      <operants>self.cursos.blank? and self.cursos.sum(:count_students)</operants>
      <operants>self.cuantity self.errors.add(:curso_ids, I18n.t(:size_book_not_enought)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
      <operants>{:initial => 0}</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="StudentLog" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":usuario" relationType="belongs_to">
      <options key=":foreign_key" value="created_by"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":cargo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":inspection_points" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :student_state"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :notifications_for"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :reason"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :privacy"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :date_occurrence"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :reason, :within =>">
      <operators>..</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>2048 validates_length_of :sugestions, :maximum => 2048, :allow_blank => true ADMINISTRATIVO</operants>
      <operants>1 DOCENTE</operants>
      <operants>2 DIRECTOR_CURSO</operants>
      <operants>3 PSICOLOGO</operants>
      <operants>4 TYPES</operants>
      <operants>{&quot;private&quot; => {:image => &quot;page_white_zip.png&quot;, :label => &quot;private&quot;, :description => &quot;footprint_is_private_message&quot;},
    &quot;public&quot; => {:image => &quot;page.png&quot;, :label => &quot;public&quot;, :description => &quot;footprint_is_public_message&quot;},
    &quot;psychosocial&quot; => {:image => &quot;page_white_wrench.png&quot;, :label => &quot;psychosocial&quot;, :description =>&quot;footprint_is_psychosocial_message&quot;}}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="TYPE_PRIVATE">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>&quot;private&quot; TYPE_PUBLIC</operants>
      <operants>&quot;public&quot; TYPE_PSYCHOSOCIAL</operants>
      <operants>&quot;psychosocial&quot; validate :validate_date</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_author, lambda { |param| param = &quot;%#{param}%&quot; ; {&#xA;      :conditions => [&quot;personas.nombre like ? or personas.apellido like ?\&#xA;      or personas.identificacion like ? &quot;, param,param,param] ,&#xA;      :joins=> {:usuario =>:persona} }}"/>
    <classElements xsi:type="rails:RubyMethod" name="estudiante"/>
    <classElements xsi:type="rails:OperationsChain" name="self.persona.estudiante end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create unless self.notifications_for.blank? self.notifications_for.each do |person|"/>
    <classElements xsi:type="rails:OperationsChain" name="notificacion">
      <operators>=</operators>
      <operators>=</operators>
      <operants>Notificacion.create(:asunto => &quot;Huella: #{self.reason},para el estudiante #{self.persona.to_s}&quot;, :mensaje => &quot;#{self.reason}\n\n#{self.sugestions}&quot;, :persona_id => person ) notificacion.state</operants>
      <operants>2</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="notificacion.send(:update_without_callbacks) if notificacion.errors.present? StudentLog.logger.error(&quot;Error al generar notificaciones de la Huella #{self.id}, Notificacion errors: #{notificacion.errors.full_messages.inspect}&quot;) end end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.notifications_for</operants>
      <operants>[] if (self.estudiante and self.estudiante.current_course_student and self.estudiante.current_course_student.curso.periodo.available?)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="or (self.estudiante and self.estudiante.current_course_student and self.estudiante.current_course_student.curso.periodo.fecha_inicio > DateTime.now)"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.privacy">
      <operators>==</operators>
      <operators>&lt;&lt;</operators>
      <operators>&lt;&lt;</operators>
      <operators>&lt;&lt;</operators>
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>&lt;&lt;</operators>
      <operators>==</operators>
      <operators>=</operators>
      <operants>StudentLog::TYPE_PUBLIC self.notifications_for</operants>
      <operants>self.estudiante.acudiente.persona_id unless self.estudiante.acudiente.blank? self.notifications_for</operants>
      <operants>self.estudiante.padre.persona_id unless self.estudiante.padre.blank? self.notifications_for</operants>
      <operants>self.estudiante.madre.persona_id unless self.estudiante.madre.blank? self.notifications_for</operants>
      <operants>self.estudiante.current_course_student.curso.docente.persona_id if self.estudiante.current_course_student and self.estudiante.current_course_student.curso.docente elsif self.privacy</operants>
      <operants>StudentLog::TYPE_PRIVATE self.notifications_for</operants>
      <operants>self.estudiante.current_course_student.curso.docente.persona_id if self.estudiante.current_course_student and self.estudiante.current_course_student.curso.docente elsif self.privacy</operants>
      <operants>StudentLog::TYPE_PSYCHOSOCIAL self.notifications_for</operants>
      <operants>self.estudiante.colegio.administradores.activo_equals(true).director_profiles_profile_equals(&quot;psychology&quot;).map(&amp;:persona_id) end end self.notifications_for end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_date"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.date_occurrence">
      <operators>></operators>
      <operants>Time.now() self.errors.add(:date_occurrence,I18n.t(&quot;date_ocurrence_after_now&quot;)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_date"/>
    <classElements xsi:type="rails:OperationsChain" name="I18n.l(self.date_occurrence, :format=>:bta_fecha) end end"/>
  </rubyClasses>
  <rubyClasses name="StudentQuestionnaireAnswerSheet" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":student_questionnaire_subject" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":person" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":subject" relationType="has_one">
      <options key=":through" value=":student_questionnaire_subject"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":quality_student_questionnaire" relationType="has_one">
      <options key=":through" value=":student_questionnaire_subject"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student" relationType="belongs_to">
      <options key=":class_name" value="Estudiante"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy, :destroy_answer_sheet"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{finished not_started started}"/>
    <classElements xsi:type="rails:OperationsChain" name="end validates_uniqueness_of :student_id, :scope => [:student_questionnaire_subject_id, :person_id]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_inclusion_of :state, :in => StudentQuestionnaireAnswerSheet.states"/>
    <classElements xsi:type="rails:RubyMethod" name="before_validation_on_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>=</operators>
      <operants>'not_started' end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="answer_sheet"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.answer_sheet_id @answer_sheet">
      <operators>||=</operators>
      <operators>!=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.student_questionnaire_subject.quality_student_questionnaire.questionnaire.answer_sheet(self.answer_sheet_id) if @answer_sheet.status</operants>
      <operants>self.state self.finished_at</operants>
      <operants>@answer_sheet.last_finished_at self.state</operants>
      <operants>@answer_sheet.status self.save! end @answer_sheet else begin @answer_sheet</operants>
      <operants>self.student_questionnaire_subject.quality_student_questionnaire.questionnaire.create_answer_sheet(:user=> person.id) self.answer_sheet_id</operants>
      <operants>@answer_sheet.id self.save! @answer_sheet rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="e logger.exc e nil end end end protected"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy_answer_sheet"/>
    <classElements xsi:type="rails:OperationsChain" name="if answer_sheet answer_sheet.destroy end end end"/>
  </rubyClasses>
  <rubyClasses name="StudentQuestionnaireSubject" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":quality_student_questionnaire" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":subject" relationType="belongs_to">
      <options key=":class_name" value="Materia"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student_questionnaire_answer_sheets" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="StudentSubjectRevision" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="TYPES">
      <operators>=</operators>
      <operants>[&quot;homework&quot;, &quot;test&quot;, &quot;forum&quot;] before_create :setup_time</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="setup_time"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.student_subject_revisions_type">
      <operators>==</operators>
      <operators>&amp;&amp;</operators>
      <operators>></operators>
      <operators>=</operators>
      <operators>-</operators>
      <operators>=</operators>
      <operants>'forum'</operants>
      <operants>self.materia.comentarios.count</operants>
      <operants>1 self.datetime_last_entry</operants>
      <operants>self.materia.updated_forums_datetime</operants>
      <operants>1.hour else self.datetime_last_entry</operants>
      <operants>DateTime.now end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.datetime_last_entry">
      <operators>=</operators>
      <operants>DateTime.now end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.initialize_topic_for_students"/>
    <classElements xsi:type="rails:OperationsChain" name="persona_ids">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>course.estudiantes.map(&amp;:persona_id) subject_revisions</operants>
      <operants>StudentSubjectRevision.persona_id_equals(persona_ids).find(:all,
      :conditions => args).group_by(&amp;:estudiante_id) args[:created_at]</operants>
      <operants>args[:updated_at]</operants>
      <operants>DateTime.now args[:created_by]</operants>
      <operants>args[:updated_by]</operants>
      <operants>GestorUsuario.obtener_usuario StudentSubjectRevision.transaction do persona_ids.each do |persona_id|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="args[:persona_id]">
      <operators>=</operators>
      <operants>persona_id StudentSubjectRevision::TYPES.each do |type|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="args[:student_subject_revisions_type]">
      <operators>=</operators>
      <operants>type if subject_revisions[persona_id]</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Study" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="LEVELS">
      <operators>=</operators>
      <operants>['no_formal',&quot;secondary&quot;,&quot;technical&quot;,&quot;technologist&quot;,&quot;professional&quot;, &quot;specialization_course&quot;, &quot;master&quot;,&quot;phd&quot;] validates_presence_of :name</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :university"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :grade_date, :if=>:graduated"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :profesional_card_get, :if=>:profesional_card_exist?"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :profesional_card, :within =>">
      <operators>..</operators>
      <operants>255</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="StudyPlan" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":programa" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="before_save :clean_text_plan_study"/>
    <classElements xsi:type="rails:OperationsChain" name="STUDY_PLAN_VALIDATOR">
      <operators>=</operators>
      <operants>/[^A-Z a-z 0-9 &#xe1;&#xe9;&#xed;&#xfa;&#xf3;&#xf6;&#xfc;&#xf1;&#xd1;&#xc1;&#xc9;&#xcd;&#xd3;&#xda;&#xdc;&#xd6;\-\.\&quot;\#\$\&amp;\%\(\)\?\&lt;\>\=\-\_\*\;\:\+\/']*/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if AWS_S3_SECURE has_attached_file :attachment, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;    },:s3_permissions => :private, :bucket => AWS_S3_SECURE['bucket_name']"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_size :attachment, :less_than => 1.megabyte, :message => I18n.t(:attachment_file_size_no_valid) end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.process_field"/>
    <classElements xsi:type="rails:OperationsChain" name="field.to_s.gsub(StudyPlan::STUDY_PLAN_VALIDATOR,'').gsub(/ +/,' ').strip end"/>
    <classElements xsi:type="rails:RubyMethod" name="clean_text_plan_study"/>
    <classElements xsi:type="rails:OperationsChain" name="self.text_plan_study">
      <operators>=</operators>
      <operants>self.text_plan_study.to_s.gsub(StudyPlan::STUDY_PLAN_VALIDATOR,'') end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SuperAdmin" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":super_admin_administrators" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":administrators" relationType="has_many">
      <options key=":through" value=":super_admin_administrators"/>
      <options key=":source" value=":administrator"/>
      <options key=":class_name" value="Administrador"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":main_administrator" relationType="belongs_to">
      <options key=":class_name" value="Administrador"/>
      <options key=":foreign_key" value="main_administrator_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :main_administrator"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :main_administrator_id"/>
    <classElements xsi:type="rails:OperationsChain" name="before_destroy :delete_related_objects"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :school_id"/>
    <classElements xsi:type="rails:RubyMethod" name="schools"/>
    <classElements xsi:type="rails:OperationsChain" name="@schools">
      <operators>||=</operators>
      <operants>[main_administrator.colegio].push(*(administrators.map{|a| a.colegio})) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="delete_related_objects"/>
    <classElements xsi:type="rails:OperationsChain" name="SuperAdminAdministrator.delete_all([&quot;id IN (?)&quot;,self.super_admin_administrators.map(&amp;:id)]) end end"/>
  </rubyClasses>
  <rubyClasses name="SuperAdminAdministrator" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="NONALPHANUMERIC_REGEXP">
      <operators>=</operators>
      <operants>/[^a-z0-9]/</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="STATES">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{active inactive}"/>
    <classElements xsi:type="rails:Relationship" name=":super_admin" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":administrator" relationType="belongs_to">
      <options key=":class_name" value="Administrador"/>
      <options key=":foreign_key" value="administrator_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :administrator_id, :scope => :super_admin_id, :message => &quot;La instituci&#xf3;n ya fu&#xe9; agregada&quot;"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_inclusion_of :state, :in => STATES validate :institucion_must_be_differente_of_main_one"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :school_id"/>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.state">
      <operators>==</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>'active' self.state</operants>
      <operants>'inactive' else self.state</operants>
      <operants>'active' end self.save! end protected</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="self.remove_non_alphanumeric"/>
    <classElements xsi:type="rails:OperationsChain" name="text.to_s.accents_downcase.remove_accents.gsub(NONALPHANUMERIC_REGEXP,'_') end"/>
    <classElements xsi:type="rails:RubyMethod" name="institucion_must_be_differente_of_main_one"/>
    <classElements xsi:type="rails:OperationsChain" name="errors.add(:administrator_id, &quot;No puede agregar a la instituci&#xf3;n principal&quot;) if">
      <operators>!</operators>
      <operators>&amp;&amp;</operators>
      <operators>==</operators>
      <operants>self.new_record?</operants>
      <operants>self.administrator.colegio_id</operants>
      <operants>self.super_admin.main_administrator.colegio_id end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SuperAsignatura" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":super_asignatura_pesos" relationType="has_many">
      <options key=":dependent" value=":destroy"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":asignaturas" relationType="has_many">
      <options key=":through" value=":super_asignatura_pesos"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":evaluation_plans" relationType="has_many">
      <options key=":dependent" value=":nullify"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :recalculate_weights"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :super_asignatura_pesos"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="if AWS_S3_SECURE has_attached_file :image,:styles => {:default=> &quot;160x160&quot;,:thumb=>'100x100' }, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;    },:s3_permissions => 'public-read', :bucket => AWS_S3_SECURE['bucket_name']"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :image, :content_type=>['image/jpg', 'image/jpeg','image/pjpeg',&#xA;      'image/tiff','image/png','image/gif'], :message => I18n.t(:person_photo_format_no_valid) validates_attachment_size :image, :less_than => 1.megabyte, :message => I18n.t(:person_photo_size_no_valid) end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.colegio_id">
      <operators>||=</operators>
      <operants>GestorUsuario.obtener_colegio end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.priority">
      <operators>||=</operators>
      <operators>+</operators>
      <operants>self.grade.super_asignaturas.length</operants>
      <operants>1 end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if recalculate_weights weight">
      <operators>=</operators>
      <operants>100.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="for asignatura in self.super_asignatura_pesos asignatura.update_attribute(:peso, weight.to_f) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="peso">
      <operators>=</operators>
      <operants>100.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="for peso_asignatura in self.super_asignatura_pesos peso_asignatura.peso">
      <operators>=</operators>
      <operants>peso.to_f peso_asignatura.save! end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SuperAsignaturaPeso" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":super_asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :peso, :greater_than =>">
      <operators>-</operators>
      <operants>1 validates_uniqueness_of :asignatura_id</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :asignatura_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :super_asignatura_id"/>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
  </rubyClasses>
  <rubyClasses name="SuperMateria" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":super_materia_pesos" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":materia_supermaterias" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":materias" relationType="has_many">
      <options key=":through" value=":materia_supermaterias"/>
      <options key=":conditions" value="{ :activo => true }"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":curso" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":translation" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="if AWS_S3_SECURE has_attached_file :image,:styles => {:default=> &quot;160x160&quot;,:thumb=>'100x100' }, :storage => &quot;s3&quot;, :s3_credentials => {&#xA;      :access_key_id => AWS_S3_SECURE['access_key_id'] ,&#xA;      :secret_access_key => AWS_S3_SECURE['secret_access_key']&#xA;      },:s3_permissions => 'public-read', :bucket => AWS_S3_SECURE['bucket_name']"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_attachment_content_type :image, :content_type=>['image/jpg', 'image/jpeg','image/pjpeg',&#xA;        'image/tiff','image/png','image/gif'], :message => I18n.t(:person_photo_format_no_valid) validates_attachment_size :image, :less_than => 1.megabyte, :message => I18n.t(:person_photo_size_no_valid) end validates_length_of :name, :within =>">
      <operators>..</operators>
      <operants>255 validates_presence_of :name</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :curso_id"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :translation"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :super_materia_pesos"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :recalculate_weights"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.priority">
      <operators>||=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operants>self.curso.super_materias.length</operants>
      <operants>1 self.created_by</operants>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create if self.intensidad_horaria.nil? self.intensidad_horaria">
      <operators>=</operators>
      <operants>0 self.materias.each do |mat|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.intensidad_horaria">
      <operators>+=</operators>
      <operators>=</operators>
      <operants>mat.asignatura.intensidad_horaria end self.save! end weight</operants>
      <operants>100.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="for periodo in self.curso.periodo.periodos for materia in self.materias SuperMateriaPeso.create(:periodo_id => periodo.id, :materia_id => materia.id, :super_materia_id => self.id, :weight => weight) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_descriptores"/>
    <classElements xsi:type="rails:OperationsChain" name="student_id"/>
  </rubyClasses>
  <rubyClasses name="SuperMateriaPeso" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":super_materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :materia_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :super_materia_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :periodo_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :weight"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :weight, :greater_than_or_equal_to => 0.0, :less_than_or_equal_to => 100.0"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :super_materia_id, :scope =>[:materia_id, :periodo_id]"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="SurveyPermision" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":categoria" relationType="belongs_to"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Tarea" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":tarea_resueltas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":evento" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":binarios" relationType="has_and_belongs_to_many">
      <options key=":conditions" value="{:state => Binario::ESTADO_ACTIVO}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":original" relationType="belongs_to">
      <options key=":foreign_key" value="original_id"/>
      <options key=":class_name" value="Tarea"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":copies" relationType="has_many">
      <options key=":foreign_key" value="original_id"/>
      <options key=":class_name" value="Tarea"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":book_marks" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre, :message => I18n.t('el nombre no debe estar en blanco') validate :validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_assigment"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_assigment"/>
    <classElements xsi:type="rails:OperationsChain" name="if (!self.calificacion.blank?)"/>
    <classElements xsi:type="rails:OperationsChain" name="if (!self.calificacion.evaluacion.blank? )"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:calificacion_id, I18n.t(:validate_score_assignment)) end if(self.calificacion.tarea and self.calificacion.tarea!= self)"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:calificacion_id, I18n.t(:overwrited_homework)) end end end"/>
    <classElements xsi:type="rails:RubyMethod" name="validate_dates"/>
    <classElements xsi:type="rails:OperationsChain" name="self.errors.add(:fecha_publicacion, I18n.t(&quot;validate_publication_and_limite_date&quot;)) if self.fecha_publicacion">
      <operators>&amp;&amp;</operators>
      <operators>&amp;&amp;</operators>
      <operators>></operators>
      <operants>self. fecha_limite</operants>
      <operants>self.fecha_publicacion</operants>
      <operants>self.fecha_limite end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="clone_homework"/>
    <classElements xsi:type="rails:OperationsChain" name="materia_destino">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Materia.id_equals(materia_id).first copia_tarea</operants>
      <operants>self.clone copia_tarea.nombre</operants>
      <operants>self.nombre copia_tarea.original_id</operants>
      <operants>self.id copia_tarea.materia_id</operants>
      <operants>materia_destino.id copia_tarea.calificacion</operants>
      <operants>Calificacion.create(:texto => self.nombre, :peso => 100.0, :materia_id => materia_destino.id) copia_tarea.binarios</operants>
      <operants>self.binarios.map(&amp;:clone) copia_tarea.save! end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="disponible"/>
    <classElements xsi:type="rails:OperationsChain" name="now">
      <operators>=</operators>
      <operants>DateTime.now (self.fecha_publicacion &lt;= now and now &lt;= self.fecha_limite) end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operators>||=</operators>
      <operators>||=</operators>
      <operators>+</operators>
      <operants>GestorUsuario.obtener_usuario self.activo</operants>
      <operants>true self.fecha_publicacion</operants>
      <operants>DateTime.now self.fecha_limite</operants>
      <operants>DateTime.now</operants>
      <operants>15.minutes end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create begin event">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>Evento.create(:name => &quot;Tarea #{self.nombre}&quot;,
        :descripcion => self.enunciado,
        :start_at => self.fecha_publicacion,
        :end_at => self.fecha_limite,
        :materia_id => self.materia.id,
        :all_day => false, :tarea=> self) self.evento</operants>
      <operants>event self.save if self.materia self.materia.updated_homeworks_datetime</operants>
      <operants>DateTime.now self.materia.save! end rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.calificacion.destroy if self.calificacion for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.evento event">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.evento event.update_attributes({:name => &quot;Tarea #{self.nombre}&quot;,
          :descripcion => self.enunciado,
          :start_at => self.fecha_publicacion,
          :end_at => self.fecha_limite,
          :materia_id => self.materia.id,
          :all_day => false}) else event</operants>
      <operants>Evento.create(:name => &quot;Tarea #{self.nombre}&quot;,
        :descripcion => self.enunciado,
        :start_at => self.fecha_publicacion,
        :end_at => self.fecha_limite,
        :materia_id => self.materia.id,
        :all_day => false) self.evento</operants>
      <operants>event self.save end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="Tarea.transaction do begin self.activo">
      <operators>=</operators>
      <operants>false self.send :update_without_callbacks</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.evento.destroy if self.evento rescue"/>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exc ex return false end end true end"/>
    <classElements xsi:type="rails:RubyMethod" name="presentada"/>
    <classElements xsi:type="rails:OperationsChain" name="resultados">
      <operators>=</operators>
      <operants>self.tarea_resueltas.select {|r| r.persona_id == persona_id }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="return resultados.at(0) end end"/>
  </rubyClasses>
  <rubyClasses name="TareaResuelta" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":tarea" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":binarios" relationType="has_and_belongs_to_many">
      <options key=":conditions" value="{:state => Binario::ESTADO_ACTIVO}"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":valor" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :tarea_id, :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :tarea_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :texto"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_numericality_of :calificacion, :if=>:escala"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validate_max, :validate_min, :maximun_limit, :minimum_limit"/>
    <classElements xsi:type="rails:RubyMethod" name="escala"/>
    <classElements xsi:type="rails:OperationsChain" name="self.tarea.materia.curso.periodo.escala_numerica and">
      <operators>!</operators>
      <operants>self.calificacion.blank? end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_max"/>
    <classElements xsi:type="rails:OperationsChain" name="value">
      <operators>=</operators>
      <operators>>=</operators>
      <operants>self.maximun_limit unless value</operants>
      <operants>self.calificacion.to_i self.errors.add(:calificacion, I18n.t(:the_value_must_be_less_or_equal_to, :value=>self.maximun_limit)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validate_min"/>
    <classElements xsi:type="rails:OperationsChain" name="value">
      <operators>=</operators>
      <operators>&lt;=</operators>
      <operants>self.minimum_limit unless value</operants>
      <operants>self.calificacion.to_i self.errors.add(:calificacion, I18n.t(:the_value_must_be_greater_or_equal_to, :value=>self.minimum_limit)) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="maximun_limit"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.tarea.materia.curso.periodo.periodo_id period">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.tarea.materia.curso.periodo.periodo else period</operants>
      <operants>self.tarea.materia.curso.periodo end return (period.escala ? period.escala.get_maximum_numeric_value.to_i : 0)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="minimum_limit"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.tarea.materia.curso.periodo.periodo_id period">
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.tarea.materia.curso.periodo.periodo else period</operants>
      <operants>self.tarea.materia.curso.periodo end return (period.escala ? period.escala.get_minimum_numeric_value.to_i : 0)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create begin self.tarea.materia.attributes">
      <operators>=</operators>
      <operants>{
        :didnt_see_homeworks_counter => self.tarea.materia.didnt_see_homeworks_counter+1,
        :did_homeworks_datetime => DateTime.now
      }</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.tarea.materia.save! rescue"/>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="ex logger.exception ex, :error"/>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update if self.calificacion and self.tarea and self.tarea.calificacion escala_numerica">
      <operators>=</operators>
      <operators>=</operators>
      <operators>!=</operators>
      <operators>=</operators>
      <operants>self.tarea.materia.curso.periodo.escala_numerica valor</operants>
      <operants>Valor.actualizar_valor(self.persona_id, self.tarea.calificacion.id, escala_numerica, self.calificacion) if self.valor</operants>
      <operants>valor self.valor</operants>
      <operants>valor self.save end end end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="TeacherAdvise" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":letra" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":numero" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":asignatura" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":docente" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":materia" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":valores" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :advise, :within =>">
      <operators>..</operators>
      <operants>1024</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="TeacherAdviseValor" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:TableName" name="teacher_advises_valores"/>
    <classElements xsi:type="rails:RubyMethod" name="id"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{teacher_advise_id}_#{valor_id}&quot; end end"/>
  </rubyClasses>
  <rubyClasses name="TeacherQuestionnaireAnswerSheet" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":assignment_subject" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":subject" relationType="has_one">
      <options key=":through" value=":assignment_subject"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":quality_teacher_questionnaire" relationType="has_one">
      <options key=":through" value=":assignment_subject"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":person" relationType="belongs_to">
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":student" relationType="belongs_to">
      <options key=":class_name" value="Estudiante"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="after_destroy :for_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="after_update :for_update"/>
    <classElements xsi:type="rails:OperationsChain" name="after_create :for_create"/>
    <classElements xsi:type="rails:RubyMethod" name="self.states"/>
    <classElements xsi:type="rails:OperationsChain" name="@@states">
      <operators>||=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="w{finished not_started started}"/>
    <classElements xsi:type="rails:OperationsChain" name="end validates_uniqueness_of :person_id, :scope => :assignment_subject_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :student_id, :scope => [:assignment_subject_id, :person_id], :if=> :student_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_inclusion_of :state, :in => TeacherQuestionnaireAnswerSheet.states"/>
    <classElements xsi:type="rails:RubyMethod" name="before_validation_on_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.state">
      <operators>=</operators>
      <operants>'not_started' end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="answer_sheet"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.answer_sheet_id @answer_sheet">
      <operators>||=</operators>
      <operators>!=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.assignment_subject.quality_teacher_questionnaire.questionnaire.answer_sheet(self.answer_sheet_id) if @answer_sheet.status</operants>
      <operants>self.state self.finished_at</operants>
      <operants>@answer_sheet.last_finished_at self.state</operants>
      <operants>@answer_sheet.status self.save! end @answer_sheet else begin @answer_sheet</operants>
      <operants>self.assignment_subject.quality_teacher_questionnaire.questionnaire.create_answer_sheet(:user=> person.id) self.answer_sheet_id</operants>
      <operants>@answer_sheet.id self.save! @answer_sheet rescue</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="Exception"/>
    <classElements xsi:type="rails:OperationsChain" name="e logger.exc e nil end end end end"/>
  </rubyClasses>
  <rubyClasses name="TeacherQuestionnaireParentFinder">
    <classElements xsi:type="rails:RubyMethod" name="initialize"/>
    <classElements xsi:type="rails:OperationsChain" name="@_hash">
      <operators>=</operators>
      <operants>{}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if arguments.first.is_a?(HashWithIndifferentAccess) arguments.first.to_hash.each do |key , value|"/>
    <classElements xsi:type="rails:OperationsChain" name="if key">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="@_hash[key.to_sym]">
      <operators>=</operators>
      <operators>=</operators>
      <operants>value.to_i else @_hash[key.to_sym]</operants>
      <operants>value end end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="inner_hash"/>
    <classElements xsi:type="rails:OperationsChain" name="return @_hash end"/>
    <classElements xsi:type="rails:RubyMethod" name="method_missing"/>
    <classElements xsi:type="rails:OperationsChain" name="if method_id.to_s">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if method_id.to_s">
      <operators>=</operators>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="@_hash[method_id.to_s[0..-2].to_sym]">
      <operators>=</operators>
      <operators>=</operators>
      <operants>arguments.first.to_i else @_hash[method_id.to_s[0..-2].to_sym]</operants>
      <operants>arguments.first end else @_hash[method_id]</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.smart_length_constraints"/>
  </rubyClasses>
  <rubyClasses name="TinyPrint" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="has_attached_file :image, :convert_options => { :quality =>  4 }, :styles => { :small_thumb => [ &quot;50x50&quot;, :jpg ],&#xA;    :medium_thumb => [ &quot;100x100&quot;, :jpg ],&#xA;    :large_thumb => [ &quot;370x370&quot;, :jpg ],&#xA;    :detail_preview => [ &quot;450x338&quot;, :jpg ] }, :default_url => &quot;/images/missing/prints/:style.png&quot;"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="TinyVideo" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:OperationsChain" name="has_attached_file :original"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="TipoDocumento" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":personas" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :get_types, :order => 'initials', :select => &quot;id, CONCAT(initials,' ',nombre) AS nombre&quot;"/>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="&quot;#{self.initials} - #{self.nombre}&quot; end"/>
    <classElements xsi:type="rails:RubyMethod" name="self.dane_tipo_documento"/>
    <classElements xsi:type="rails:OperationsChain" name="[['C&#xe9;dula de ciudadania', 1],&#xA;      ['Tarjeta de identidad', 2],&#xA;      ['C&#xe9;dula de extranjeria o identificaci&#xf3;n de extranjeria', 3],&#xA;      [' ', 4],&#xA;      ['Registro civil de nacimiento', 5],&#xA;      ['N&#xfa;mero de identificaci&#xf3;n personal(NIP)', 6],&#xA;      ['N&#xfa;mero unico de identificaci&#xf3;n personal(NUIP)', 7],&#xA;      ['N&#xfa;mero de identificaci&#xf3;n establecido por la secretaria de educaci&#xf3;n', 8],&#xA;      ['Certificado cabildo', 9]&#xA;    ] end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="Translation" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.colegio_id</operants>
      <operants>GestorUsuario.obtener_colegio if self.colegio_id.nil? end end</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Transporter" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to">
      <options key=":foreign_key" value="person_id"/>
      <options key=":class_name" value="Persona"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :person_id"/>
    <classElements xsi:type="rails:OperationsChain" name="accepts_nested_attributes_for :persona"/>
    <classElements xsi:type="rails:OperationsChain" name="before_validation :set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.colegio_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_monitora"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.monitor return I18n.t(:yes) else return I18n.t(:negation) end end"/>
    <classElements xsi:type="rails:RubyMethod" name="get_driver"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.monitor return I18n.t(:yes) else return I18n.t(:negation) end end end"/>
  </rubyClasses>
  <rubyClasses name="Usuario" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":perfiles" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:Relationship" name=":logins" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":reset_password_informations" relationType="has_many">
      <options key=":foreign_key" value="user_id"/>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :test"/>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:colegio_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :contrasena, :perfil_ids"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_accessor :password_confirmation, :password"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :colegio_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :nombre"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :nombre, :if => :activo, :scope => [:activo]"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_uniqueness_of :persona_id, :if => :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :nombre, :with => /^[A-Z0-9._%-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}$/i"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :password, :unless => Proc.new {|object| object.contrasena == object.contrasena_was &amp;&amp;&#xA;      object.nombre == object.nombre_was&#xA;  }"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :password_confirmation, :unless => Proc.new {|object| object.contrasena == object.contrasena_was}"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :password, :within =>">
      <operators>..</operators>
      <operants>200</operants>
    </classElements>
  </rubyClasses>
  <rubyClasses name="Valor" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":calificacion" relationType="belongs_to">
      <options key=":inverse_of" value=":valores"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":resultado" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":tarea_resuelta" relationType="has_one"/>
    <classElements xsi:type="rails:Relationship" name=":teacher_advises" relationType="has_and_belongs_to_many"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :calificacion_id"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :comments, :maximum => 8191, :allow_blank => true validates_length_of :recovery_comments, :maximum => 8191, :allow_blank => true"/>
    <classElements xsi:type="rails:RubyMethod" name="valor_real"/>
    <classElements xsi:type="rails:OperationsChain" name="if numeric_scale return self.numerical_value.to_f.round(1) else numerical_value">
      <operators>=</operators>
      <operators>==</operators>
      <operants>self.numerical_value if self.valor_alfanumerico.blank? and numerical_value</operants>
      <operants>0.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="value">
      <operators>=</operators>
      <operators>=</operators>
      <operants>'' else value</operants>
      <operants>self.calificacion.letra_por_rango(numerical_value).to_s end end value end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="numerical_value"/>
    <classElements xsi:type="rails:OperationsChain" name="numerico">
      <operators>=</operators>
      <operators>?</operators>
      <operators>: </operators>
      <operators>||</operators>
      <operants>(!self.valor_numerico_recuperacion.blank? and self.valor_numerico_recuperacion > self.valor_numerico)</operants>
      <operants>self.valor_numerico_recuperacion</operants>
      <operants>self.valor_numerico</operants>
      <operants>0 numerico end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.valor_numerico">
      <operators>=</operators>
      <operants>0.0</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if self.valor_numerico.blank? unless self.confirmar_escala_numerica letra">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.calificacion.letra_equivalente(self.valor_alfanumerico) self.valor_numerico</operants>
      <operants>(letra.nil? ? 0.0 : letra.value) if self.valor_alfanumerico_recuperacion letra</operants>
      <operants>self.calificacion.letra_equivalente(self.valor_alfanumerico_recuperacion) self.valor_numerico_recuperacion</operants>
      <operants>letra.value if letra end end self.valor_numerico</operants>
      <operants>self.valor_numerico.to_f.round(1)</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="self.valor_numerico_recuperacion">
      <operators>=</operators>
      <operants>self.valor_numerico_recuperacion.to_f.round(1) if self.valor_numerico_recuperacion</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.warn(&quot;Model created #{self.class} #{self.id} calificacion_id:#{self.calificacion_id} persona_id:#{self.persona_id}&quot;) end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update self.calificacion.lock_ascendants superior">
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.buscar_superior if superior valor_acumulado</operants>
      <operants>0 escala_numerica</operants>
      <operants>self.confirmar_escala_numerica if escala_numerica hermanos</operants>
      <operants>self.buscar_hermanos.select{|e| e.valor_numerico != nil}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="else hermanos">
      <operators>=</operators>
      <operants>self.buscar_hermanos.select{|e| !e.valor_alfanumerico.blank?}</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="end for valor_hermano in hermanos if escala_numerica valor_acumulado">
      <operators>+=</operators>
      <operators>+=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>(valor_hermano.valor_real * valor_hermano.calificacion.peso) else valor_acumulado</operants>
      <operants>(valor_hermano.numerical_value) end end unless escala_numerica if hermanos.blank? superior.update_attribute(:valor_alfanumerico, &quot;&quot;) else letra_por_rango</operants>
      <operants>superior.calificacion.letra_por_rango(valor_acumulado) if letra_por_rango superior.valor_numerico</operants>
      <operants>valor_acumulado superior.send(:update_without_callbacks) superior.update_attribute(:valor_alfanumerico, letra_por_rango.texto) end end else superior.update_attribute(:valor_numerico, valor_acumulado) end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_save"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.calificacion.tarea">
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>&amp;&amp;</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.tarea_resuelta homework</operants>
      <operants>self.tarea_resuelta homework.calificacion</operants>
      <operants>self.valor_real homework.send(:update_without_callbacks) elsif self.calificacion.evaluacion</operants>
      <operants>self.resultado test</operants>
      <operants>self.resultado test.calificacion</operants>
      <operants>self.valor_real test.send(:update_without_callbacks) end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="buscar_hermanos_old"/>
    <classElements xsi:type="rails:OperationsChain" name="logger.warn(&quot;DEPRECATED on 20160610&quot;) if self.calificacion and self.calificacion.programa and">
      <operators>!</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operators>&lt;&lt;</operators>
      <operants>self.calificacion.periodo calificacion_ids</operants>
      <operants>[self.calificacion_id] elsif self.calificacion and self.calificacion.programa and self.calificacion.periodo calificacion_ids</operants>
      <operants>Calificacion.programa_id_equals(self.calificacion.programa.id). periodo_id_not_null. actividad_id_null. logro_id_null.indicador_id_null. all(:select=>'id').map(&amp;:id) elsif self.calificacion and self.calificacion.logro and self.calificacion.logro.periodo logro_ids</operants>
      <operants>self.calificacion.logro.programa.logros.periodo_id_equals(
        self.calificacion.logro.periodo_id).map(&amp;:id) calificacion_ids</operants>
      <operants>Calificacion.logro_id_equals(logro_ids). programa_id_null. periodo_id_null. actividad_id_null. indicador_id_null. all(:select=>'id').map(&amp;:id) elsif self.calificacion and self.calificacion.indicador and self.calificacion.indicador.logro indicador_ids</operants>
      <operants>self.calificacion.indicador.logro.indicador_ids calificacion_ids</operants>
      <operants>Calificacion.indicador_id_equals(indicador_ids). logro_id_null. programa_id_null. periodo_id_null. actividad_id_null. all(:select=>'id').map(&amp;:id) elsif self.calificacion and self.calificacion.actividad and self.calificacion.actividad.indicador actividad_ids</operants>
      <operants>self.calificacion.actividad.indicador.actividad_ids calificacion_ids</operants>
      <operants>Calificacion.actividad_id_equals(actividad_ids). logro_id_null. programa_id_null. periodo_id_null. indicador_id_null. all(:select=>'id').map(&amp;:id) end return Valor.calificacion_id_equals(calificacion_ids).persona_id_equals(self.persona_id).id_does_not_equal(self.id).all</operants>
      <operants>self end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="buscar_hermanos"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.calificacion self.calificacion.siblings.map{|c| c.get_value_by_person_id(self.persona_id)}"/>
  </rubyClasses>
  <rubyClasses name="Variable" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":preguntas" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":rangos" relationType="has_many"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end end"/>
  </rubyClasses>
  <rubyClasses name="VariableAssignment" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":evaluacion" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":colegio" relationType="belongs_to">
      <options key=":foreign_key" value="school_id"/>
      <options key=":class_name" value="Colegio"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":course" relationType="belongs_to">
      <options key=":class_name" value="Curso"/>
      <options key=":foreign_key" value="course_id"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":questions" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":periodo" relationType="belongs_to">
      <options key=":foreign_key" value="period_id"/>
      <options key=":class_name" value="Periodo"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":area" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":grade" relationType="belongs_to"/>
    <classElements xsi:type="rails:Relationship" name=":resultados" relationType="has_many"/>
    <classElements xsi:type="rails:Relationship" name=":courses" relationType="has_many">
      <options key=":class_name" value="Curso"/>
    </classElements>
    <classElements xsi:type="rails:Relationship" name=":performancetests" relationType="has_many"/>
    <classElements xsi:type="rails:OperationsChain" name="TYPES">
      <operators>=</operators>
      <operants>['psicology',''] accepts_nested_attributes_for :evaluacion</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="named_scope :by_current_school, lambda { {&#xA;      :conditions => {:school_id => self.get_school()} } }"/>
    <classElements xsi:type="rails:RubyMethod" name="set_school"/>
    <classElements xsi:type="rails:OperationsChain" name="begin self.school_id">
      <operators>=</operators>
      <operants>self.class.get_school() if self.class.get_school() rescue self.logger.exc $! end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="self.evaluacion.resultados.each do |resultado|"/>
    <classElements xsi:type="rails:OperationsChain" name="if resultado.performance_result resultado.performance_result.destroy end resultado.respuestas.each do |respuesta|"/>
    <classElements xsi:type="rails:OperationsChain" name="respuesta.destroy end resultado.destroy end end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.active</operants>
      <operants>true end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="to_s"/>
    <classElements xsi:type="rails:OperationsChain" name="self.evaluacion.name end"/>
    <classElements xsi:type="rails:RubyMethod" name="clone_allocation"/>
    <classElements xsi:type="rails:OperationsChain" name="clone_evaluacion">
      <operators>=</operators>
      <operators>=</operators>
      <operators>+</operators>
      <operators>=</operators>
      <operators>=</operators>
      <operants>self.evaluacion.deep_clone_test_teacher clone_evaluacion.name</operants>
      <operants>self.evaluacion.name</operants>
      <operants>'_copia' clone_evaluacion.save! clone_allocation</operants>
      <operants>self.clone clone_allocation.evaluacion_id</operants>
      <operants>clone_evaluacion.id clone_allocation.save! unless self.evaluacion.categorias.blank? self.evaluacion.categorias.each do |cat|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="clone_theme">
      <operators>=</operators>
      <operators>=</operators>
      <operants>cat.deep_clone clone_theme.evaluacion_id</operants>
      <operants>clone_evaluacion.id clone_theme.save! unless clone_theme.preguntas.blank? clone_theme.preguntas.each do |preg_categoria|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if preg_categoria.active preg_categoria.categoria_id">
      <operators>=</operators>
      <operators>=</operators>
      <operants>clone_theme.id preg_categoria.evaluacion_id</operants>
      <operants>clone_evaluacion.id preg_categoria.save! end end end end end unless self.evaluacion.preguntas.blank? self.evaluacion.preguntas.each do |preg|</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="if preg.categoria_id.blank? if preg.active clone_pregunta">
      <operators>=</operators>
      <operators>=</operators>
      <operants>preg.deep_clone clone_pregunta.evaluacion_id</operants>
      <operants>clone_evaluacion.id clone_pregunta.save! end end end end end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_save"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario self.school_id</operants>
      <operants>self.class.get_school() if self.class.get_school() end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_materias"/>
    <classElements xsi:type="rails:OperationsChain" name="scope">
      <operators>=</operators>
      <operants>Materia.curso_by_current_school.activo_equals(true).curso_activo_equals(true).all scope.asignatura_area_id_equals(self.area_id) if self.area_id scope.curso_grade_id_equals(self.grade_id) if self.grade_id scope.curso_periodo_id_equals(self.period_id) if self.period_id scope end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="get_name_evaluacion"/>
    <classElements xsi:type="rails:OperationsChain" name="self.evaluacion.name end end"/>
  </rubyClasses>
  <rubyClasses name="WorkExperience" superType="ActiveRecord::Base">
    <classElements xsi:type="rails:Relationship" name=":persona" relationType="belongs_to"/>
    <classElements xsi:type="rails:OperationsChain" name="attr_protected :persona_id"/>
    <classElements xsi:type="rails:OperationsChain" name="CONTRACT_TYPES">
      <operators>=</operators>
      <operants>[&quot;definite_time&quot;,&quot;not_definite_time&quot;,&quot;ops&quot;,&quot;other&quot;] validates_presence_of :name_company</operants>
    </classElements>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :immediate_boss"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :position"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :functions"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_presence_of :start"/>
    <classElements xsi:type="rails:OperationsChain" name="validate :validar_start_date"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :phone, :with => /^[0-9\- ext EXT:()]*\z/"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_format_of :name_company, :immediate_boss, :position, :with => validates_numericality_of :income, :if => :income"/>
    <classElements xsi:type="rails:OperationsChain" name="validates_length_of :name_company, :immediate_boss, :position, :within =>">
      <operators>..</operators>
      <operators>..</operators>
      <operants>255 validates_length_of :functions, :within =></operants>
      <operants>1024</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="before_create"/>
    <classElements xsi:type="rails:OperationsChain" name="self.created_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="after_create"/>
    <classElements xsi:type="rails:OperationsChain" name="for_create end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_destroy"/>
    <classElements xsi:type="rails:OperationsChain" name="for_destroy end"/>
    <classElements xsi:type="rails:RubyMethod" name="after_update"/>
    <classElements xsi:type="rails:OperationsChain" name="for_update end"/>
    <classElements xsi:type="rails:RubyMethod" name="before_update"/>
    <classElements xsi:type="rails:OperationsChain" name="self.updated_by">
      <operators>=</operators>
      <operants>GestorUsuario.obtener_usuario end</operants>
    </classElements>
    <classElements xsi:type="rails:RubyMethod" name="validar_start_date"/>
    <classElements xsi:type="rails:OperationsChain" name="if self.finish and self.start unless self.finish">
      <operators>>=</operators>
      <operants>self.start self.errors.add(:finish,I18n.t(:must_be_greathen_or_equals_than_date_start)) end end end end</operants>
    </classElements>
  </rubyClasses>
</rails:Application>
